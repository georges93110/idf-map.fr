<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta name="description" content="Explorez la carte interactive de la map Ile-de-France."/>
  <meta property="og:locale" content="fr_FR"/>
  <meta property="og:type" content="website"/>
  <meta property="og:site_name" content="Ile-de-France Map - Carte Interactive"/>
  <meta property="og:title" content="Ile-de-France Map"/>
  <meta property="og:description" content="Explorez la carte interactive de la map Ile-de-France."/>
  <meta property="og:url" content="https://idf-map.fr/map.html"/>
  <meta property="og:image" content="https://idf-map.fr/images/idf_logo_new.png"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:title" content="Ile-de-France Map - Carte Interactive"/>
  <meta name="twitter:description" content="Explorez la carte interactive de la map Ile-de-France."/>
  <meta name="twitter:image" content="https://idf-map.fr/images/idf_logo_new.png"/>
  <style>
    html[data-app-ready="0"] {
      background:#000;
    }
    html[data-app-ready="0"] body {
      opacity:0 !important;
      visibility:hidden !important;
      overflow:hidden !important;
    }
  </style>
  <script>
    (function setupAppReadyGate() {
      const root = document.documentElement;
      root.setAttribute("data-app-ready", "0");
      let done = false;
      function reveal() {
        if (done) return;
        done = true;
        root.setAttribute("data-app-ready", "1");
      }
      window.__setAppReady = function __setAppReady(options) {
        const cfg = options && typeof options === "object" ? options : {};
        const minFrames = Math.max(4, Number(cfg.minFrames) || 8);
        const stableFrames = Math.max(2, Number(cfg.stableFrames) || 3);
        const maxFrames = Math.max(minFrames + stableFrames, Number(cfg.maxFrames) || 28);
        let frameCount = 0;
        let stableCount = 0;
        let previousKey = "";
        const step = () => {
          frameCount += 1;
          let layoutKey = "";
          const body = document.body;
          if (body) {
            const rect = body.getBoundingClientRect();
            layoutKey = [
              Math.round(rect.width),
              Math.round(rect.height),
              document.documentElement.scrollWidth,
              document.documentElement.scrollHeight
            ].join("x");
          }
          stableCount = layoutKey && layoutKey === previousKey ? stableCount + 1 : 0;
          previousKey = layoutKey;
          const enoughFrames = frameCount >= minFrames;
          const visuallyStable = stableCount >= stableFrames;
          const frameBudgetExceeded = frameCount >= maxFrames;
          if ((!enoughFrames || !visuallyStable) && !frameBudgetExceeded) {
            requestAnimationFrame(step);
            return;
          }
          reveal();
        };
        const start = () => requestAnimationFrame(step);
        if (document.fonts && document.fonts.ready) {
          Promise.race([
            document.fonts.ready.catch(() => {}),
            new Promise((resolve) => setTimeout(resolve, 1200))
          ]).finally(start);
          return;
        }
        start();
      };
      window.addEventListener("pageshow", reveal, { once: true });
      window.setTimeout(reveal, 7000);
    })();
  </script>
  <title>Map</title>
  <link rel="icon" type="image/png" href="images/idf_logo_new.png"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root{
      --panel:#121212;--panel2:#1a1a1a;--border:#3a3a3a;--text:#ececec;--muted:#8f8f8f;--shadow:0 10px 30px rgba(0,0,0,.40);
      --logoW:110px; --logoH:44px;
      --sidePanelW:460px;
      --busA:#3a3a3a; --busB:#3a3a3a; --busC:#3a3a3a; --busD:#3a3a3a; --busE:#3a3a3a;
      --rer-mask-url: none;
      --metro-icon-url: none;
      --metro-mask-url: none;
      --anim-fast:.16s;
      --anim-med:.24s;
      --anim-slow:.34s;
      --anim-ease:cubic-bezier(.22,.61,.36,1);
      --topbar-top:0px;
      --sitebar-height:52px;
      --mapbar-height:56px;
      --topbar-gap:10px;
      --site-header-h: calc(var(--topbar-top) + var(--sitebar-height));
      --header-stack-h: calc(var(--topbar-top) + var(--sitebar-height) + var(--topbar-gap) + var(--mapbar-height));
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji}
    #map{position:fixed;inset:0}
    .leaflet-container,html,body,#map{background:#000}
    .city-label{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      color:#fff;font-weight:600;white-space:nowrap;text-align:center;
      text-shadow:0 2px 4px rgba(0,0,0,.8);
      pointer-events:auto; cursor:pointer;
    }
    .city-selected{color:#ffda3a !important;text-shadow:0 0 0 rgba(0,0,0,0),0 2px 6px rgba(0,0,0,.9)}
    body.map-icons-disabled .leaflet-image-layer.leaflet-zoom-animated.leaflet-interactive,
    body.map-icons-disabled .dbus-stop-marker,
    body.map-icons-disabled .dbus-stop-marker-host{
      opacity:0 !important;
      visibility:hidden !important;
    }
    body.route-selected .dbus-stop-marker-wrap{
      opacity:0 !important;
      visibility:hidden !important;
      pointer-events:none !important;
    }

    .map-topbar{
      position:fixed;
      top:calc(var(--site-header-h) + var(--topbar-gap));
      left:12px;
      right:12px;
      z-index:1305;
      padding:0 10px;
      border:none;
      border-radius:14px;
      background:transparent;
      box-shadow:none;
      backdrop-filter:none;
      -webkit-backdrop-filter:none;
      transition:transform .2s ease;
      pointer-events:none;
    }
    .map-topbar.dbus-open{
      transform:none;
    }
    body.side-panel-resizing .map-topbar.dbus-open{
      transform:none;
    }
    .map-topbar-row{
      position:relative;
      display:flex;
      align-items:center;
      gap:16px;
      width:100%;
      max-width:none;
      padding:0;
      box-sizing:border-box;
      min-height:var(--mapbar-height);
      pointer-events:none;
    }
    .map-topbar-row .search-input,
    .map-topbar-row .top-actions,
    .map-topbar-row .top-actions *{
      pointer-events:auto;
    }
    .map-topbar-row .search-input{
      position:static;
      left:auto;
      transform:none;
      flex:0 1 560px;
      width:auto;
      max-width:min(560px, 64vw);
      min-width:220px;
      margin:0;
    }
    .search-panel{
      position:fixed;
      top:calc(var(--header-stack-h) + 6px);
      left:0;
      right:0;
      z-index:1000;
    }
    .top-actions{
      position:static;
      right:auto;
      top:auto;
      transform:none;
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:8px;
      transition:transform .2s ease;
    }
    .search-panel.dbus-open{z-index:1250}
    .top-actions.dbus-open{
      transform:translateX(calc(-1 * var(--activePanelShift, min(var(--sidePanelW), 50vw, 94vw))));
    }
    body.side-panel-resizing .top-actions.dbus-open{
      transform:translateX(calc(-1 * var(--activePanelShift, var(--sidePanelDragShift, 460px))));
    }
    body.compact-open-ui .map-topbar-row .search-input,
    body.compact-open-ui .map-topbar-row .top-actions{
      opacity:0;
      visibility:hidden;
      pointer-events:none;
      width:0;
      min-width:0;
      max-width:0;
      margin:0;
      overflow:hidden;
    }
    body.compact-open-ui .top-actions.dbus-open,
    body.compact-open-ui.side-panel-resizing .top-actions.dbus-open{
      transform:none;
    }
    body.compact-open-ui .map-topbar-row{
      gap:0;
      min-height:0;
    }
    .icon-btn{
      width:44px;
      min-width:44px;
      height:44px;
      padding:11px 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
    }
    #btnSettings{
      width:44px;
      min-width:44px;
      height:44px;
      padding:0;
      box-sizing:border-box;
    }
    #btnDbus{
      width:44px;
      min-width:44px;
      height:44px;
      padding:0;
      box-sizing:border-box;
    }
    .dbus-icon-logo{
      width:24px;
      height:24px;
      display:block;
      object-fit:contain;
    }
    .settings-icon{
      width:18px;
      height:18px;
      stroke:currentColor;
      fill:none;
      stroke-width:2;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .audio-panel-icon{
      width:27px;
      height:27px;
      flex:0 0 27px;
      max-width:none;
      max-height:none;
      display:block;
      stroke:currentColor;
      fill:none;
      stroke-width:2;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .saeiv-panel-icon{
      width:23px;
      height:23px;
      flex:0 0 23px;
      max-width:none;
      max-height:none;
      display:block;
      stroke:currentColor;
      fill:none;
      stroke-width:2;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .map-topbar .btn{
      background:#1a1a1a;
      border-color:#2c2c2c;
      color:#f2f2f2;
    }
    .map-topbar .btn:hover{
      background:#252525;
      border-color:#444444;
    }
    html[lang="fr"] #settingsTranslateStopsRow{
      display:none !important;
    }
    .lang-toggle-badge{
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:.08em;
      padding:2px 6px;
      border-radius:999px;
      background:rgba(245,158,11,0.15);
      border:1px solid rgba(245,158,11,0.45);
      color:#fbbf24;
      font-weight:800;
    }
    #settingsSaeivPanelBadge{
      background:rgba(59,130,246,0.18);
      border-color:rgba(96,165,250,0.55);
      color:#93c5fd;
      text-transform:none;
      letter-spacing:.02em;
    }
    #settingsSaeivPanelToggle:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    .search-input{flex:1;min-width:300px;padding:12px 14px;border-radius:12px;border:1px solid var(--border);background:color-mix(in oklab, var(--panel) 92%, #000 8%);color:var(--text);font-size:15px;box-shadow:var(--shadow);outline:none}
    .search-input:disabled{opacity:.5;cursor:not-allowed;background:color-mix(in oklab, var(--panel) 85%, #000 15%)}
    .search-input::placeholder{color:var(--muted)}
    .btn{padding:11px 14px;border-radius:12px;border:1px solid var(--border);background:color-mix(in oklab, var(--panel) 92%, #000 8%);color:var(--text);font-weight:600;cursor:pointer;box-shadow:var(--shadow);text-decoration:none;display:inline-flex;align-items:center;justify-content:center}
    .btn:hover{background:#222222}
    .btn,.dbus-mode-btn,.dbus-switch,.dbus-item,.dbus-logo,.dbus-sechead,.result-item,.line-preview-link{
      transition:
        transform var(--anim-fast) var(--anim-ease),
        opacity var(--anim-fast) var(--anim-ease),
        background var(--anim-fast) var(--anim-ease),
        border-color var(--anim-fast) var(--anim-ease),
        color var(--anim-fast) var(--anim-ease),
        box-shadow var(--anim-fast) var(--anim-ease);
    }
    .btn:disabled,
    .btn.is-disabled{opacity:.5;cursor:not-allowed;box-shadow:none}
    .btn.is-open{
      outline:2px solid #f59e0b;
      outline-offset:2px;
    }
    .results{margin-top:6px;max-height:42vh;overflow:auto;border:1px solid var(--border);border-radius:12px;background:var(--panel);box-shadow:var(--shadow);backdrop-filter:blur(6px)}
    .result-item{display:flex;align-items:center;gap:12px;padding:10px 12px;cursor:pointer;border-bottom:1px solid #2c2c2c;color:var(--text);font-size:14px}
    .result-item:last-child{border-bottom:none}
    .result-item:hover{background:#222222}
    .result-item img.ico{width:var(--logoW);height:var(--logoH);flex:0 0 auto;border-radius:6px;object-fit:contain}
    .result-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1;line-height:1.2}
    .result-empty{
      padding:10px 12px;
      color:var(--muted);
      font-size:14px;
      border-bottom:1px solid #2c2c2c;
    }
    .result-item img.ico { width: var(--logoW); height: var(--logoH); }
    .result-item img.ico.ico-service { width: calc(var(--logoW) / 2); height: calc(var(--logoH) / 2); }

    .search-panel-modal .search-toolbar{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:10px 12px;
      border-bottom:1px solid #2c2c2c;
      background:var(--panel2);
    }
    .search-panel-modal .search-input{width:100%;min-width:0;box-shadow:none}
    .search-panel-modal .results{
      margin:0;
      padding:6px;
      max-height:none;
      border:0;
      background:transparent;
      box-shadow:none;
      overflow:visible;
    }
    #searchFilters{flex:1;min-width:0}
    .search-panel-modal .dbus-header .dbus-close{margin-left:auto}
    .result-sechead{
      padding:8px 10px;
      color:#b1b1b1;
      font-size:12px;
      font-weight:700;
      letter-spacing:.04em;
      text-transform:uppercase;
      border-bottom:1px solid #2c2c2c;
      background:var(--panel2);
    }

    .dbus-panel{
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      width:min(1240px,94vw);
      height:min(760px,92vh);
      max-width:94vw;
      max-height:92vh;
      box-sizing:border-box;
      padding:12px 18px;
      border-radius:22px;
      border:1px solid var(--border);
      background:var(--panel);
      box-shadow:0 25px 90px rgba(0,0,0,.7);
      display:none;
      overflow:hidden;
      z-index:1200;
      flex-direction:column;
    }
    #dbusPanel{
      top:var(--site-header-h);
      right:0;
      left:auto;
      transform:none;
      z-index:1308;
      width:min(var(--sidePanelW),50vw,94vw);
      max-width:50vw;
      height:calc(100vh - var(--site-header-h));
      max-height:calc(100vh - var(--site-header-h));
      padding:0;
      border-radius:0;
      border-top:none;
      border-right:none;
      border-bottom:none;
      box-shadow:-16px 0 50px rgba(0,0,0,.55);
    }
    #settingsPanel{
      top:var(--site-header-h);
      right:0;
      left:auto;
      transform:none;
      z-index:1308;
      width:min(var(--sidePanelW),50vw,94vw);
      max-width:50vw;
      height:calc(100vh - var(--site-header-h));
      max-height:calc(100vh - var(--site-header-h));
      padding:0;
      border-radius:0;
      border-top:none;
      border-right:none;
      border-bottom:none;
      border-left:1px solid var(--border);
      background:var(--panel);
      box-shadow:-16px 0 50px rgba(0,0,0,.55);
    }
    #settingsPanel .dbus-content{
      padding:12px;
      display:block;
      min-height:0;
      overflow-y:auto;
      overflow-x:hidden;
      scrollbar-gutter:stable;
      background:var(--panel);
    }
    #settingsPanel .dbus-content::-webkit-scrollbar{
      width:12px;
    }
    #settingsPanel .dbus-content::-webkit-scrollbar-track{
      background:var(--panel2);
      border-radius:10px;
    }
    #settingsPanel .dbus-content::-webkit-scrollbar-thumb{
      background:#7a7a7a;
      border-radius:10px;
      border:2px solid var(--panel2);
    }
    #settingsPanel .dbus-content::-webkit-scrollbar-thumb:hover{
      background:#9d9d9d;
    }
    #settingsPanel .settings-category{
      margin:0 0 14px;
      border:1px solid var(--border);
      border-radius:12px;
      overflow:hidden;
      background:var(--panel2);
    }
    #settingsPanel .settings-category:last-child{margin-bottom:0}
    #settingsPanel .settings-group-title{
      margin:0;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:#171717;
      color:var(--text);
      font-size:12px;
      font-weight:800;
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    #settingsPanel .settings-sec{
      padding:10px 12px 12px;
      border-bottom:1px solid var(--border);
    }
    #settingsPanel .settings-category .settings-sec:last-child{border-bottom:none}
    #settingsPanel .settings-title{
      margin:0 0 10px;
      color:var(--muted);
      font-size:12px;
      font-weight:700;
      letter-spacing:.04em;
      text-transform:uppercase;
    }
    #settingsPanel .settings-legend{
      margin-top:12px;
      position:sticky;
      bottom:0;
      border:1px solid var(--border);
      border-radius:12px;
      overflow:hidden;
      background:#171717;
      backdrop-filter:blur(8px);
      -webkit-backdrop-filter:blur(8px);
      box-shadow:0 10px 28px rgba(0,0,0,.35);
      z-index:2;
    }
    #settingsPanel .settings-legend .settings-group-title{
      border-bottom:1px solid var(--border);
    }
    #settingsPanel .settings-legend-list{
      display:grid;
      grid-template-columns:repeat(2, minmax(0, 1fr));
      gap:8px;
      padding:10px 12px 12px;
    }
    #settingsPanel .settings-legend-item{
      display:flex;
      align-items:center;
      gap:10px;
      min-height:28px;
      color:#e0e0e0;
      font-size:12px;
      font-weight:700;
      letter-spacing:.01em;
    }
    #settingsPanel .settings-legend-item-main{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
      flex:1 1 auto;
    }
    #settingsPanel .settings-legend-icon{
      width:22px;
      height:22px;
      object-fit:contain;
      border-radius:5px;
      flex:0 0 auto;
      box-shadow:0 0 0 1px rgba(255,255,255,.06) inset;
      background:rgba(255,255,255,.03);
    }
    #settingsPanel .settings-legend-label{
      min-width:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    #settingsPanel .settings-legend-exp{
      margin-left:auto;
      flex:0 0 auto;
    }
    #settingsPanel .settings-legend-switch{
      margin-left:8px;
      flex:0 0 auto;
    }
    #settingsPanel .settings-legend-item-toggle{
      grid-column:1 / -1;
    }
    #settingsPanel .lang-menu{
      position:static;
      top:auto;
      right:auto;
      min-width:0;
      width:100%;
      padding:0;
      border:none;
      border-radius:0;
      background:transparent;
      box-shadow:none;
      display:block !important;
    }
    #settingsPanel .settings-map-version-row{
      display:flex;
      align-items:center;
    }
    #settingsPanel .settings-map-version-select{
      width:100%;
      max-width:100%;
      min-height:38px;
      border:1px solid var(--border);
      border-radius:10px;
      background:var(--panel2);
      color:var(--text);
      font-size:13px;
      font-weight:600;
      padding:8px 10px;
      outline:none;
    }
    #settingsPanel .settings-map-version-select:focus{
      border-color:#6f6f6f;
      box-shadow:0 0 0 2px rgba(111,111,111,.2);
    }
    #dbusPanel .dbus-header .dbus-close,
    #settingsPanel .dbus-header .dbus-close{
      order:-1;
      margin-right:4px;
    }
    #dbusPanel .dbus-header .dbus-world-link{
      margin-left:auto;
    }
    #searchPanel.search-panel-modal{
      position:absolute;
      top:calc(100% + 8px);
      left:12px;
      right:auto;
      transform:none;
      width:min(760px,calc(100vw - 24px));
      max-width:calc(100vw - 24px);
      height:auto;
      max-height:min(70vh,620px);
      padding:0;
      border-radius:14px;
    }
    #searchPanel.search-panel-modal .dbus-header{display:none}
    #searchPanel.search-panel-modal .dbus-content{
      max-height:calc(min(70vh,620px) - 56px);
      overflow:auto;
    }
    .dbus-panel.is-open,
    .dbus-stop-panel.is-open{
      outline:2px solid #ffffff33;
      outline-offset:-2px;
    }
    #dbusPanel.is-open,
    #settingsPanel.is-open{
      animation:sidePanelIn var(--anim-med) var(--anim-ease) both;
    }
    #dbusPanel.is-closing,
    #settingsPanel.is-closing{
      animation:sidePanelOut var(--anim-med) var(--anim-ease) both;
      pointer-events:none;
    }
    #searchPanel.search-panel-modal.is-open{
      animation:searchPanelIn var(--anim-med) var(--anim-ease) both;
    }
    #searchPanel.search-panel-modal.is-closing{
      animation:searchPanelOut var(--anim-med) var(--anim-ease) both;
      pointer-events:none;
    }
    .dbus-stop-panel.is-open{
      animation:modalPanelIn var(--anim-med) var(--anim-ease) both;
    }
    .dbus-stop-panel.is-closing{
      animation:modalPanelOut var(--anim-med) var(--anim-ease) both;
      pointer-events:none;
    }
    .dbus-panel .dbus-content{
      flex:1 1 auto;
      overflow:auto;
      scrollbar-gutter: stable;
      min-height:0;
    }
    .dbus-stop-panel{
      position:fixed;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      width:min(1240px,92vw);
      max-width:92vw;
      height:min(760px,92vh);
      max-height:92vh;
      box-sizing:border-box;
      padding:12px 18px 0;
      border-radius:22px;
      border:1px solid var(--border);
      background:var(--panel);
      box-shadow:0 25px 90px rgba(0,0,0,.7);
      display:none;
      overflow:hidden;
      z-index:1308;
      flex-direction:column;
    }
    .dbus-stop-panel .dbus-title{white-space:normal;line-height:1.25}
    .dbus-stop-content{flex:1 1 auto;overflow:auto;scrollbar-gutter: stable;min-height:0}
    .dbus-header{display:flex;align-items:center;gap:12px;padding:12px 16px;border-bottom:1px solid #2c2c2c;color:var(--muted);font-size:16px}
    .dbus-header .dbus-title{font-size:20px;font-weight:700;color:#f2f2f2;}
    .dbus-header .dbus-close{
      background:transparent;
      border:none;
      color:#ef4444;
      font-size:24px;
      cursor:pointer;
      line-height:1;
    }
    .dbus-mode-group{display:flex;gap:8px;align-items:center;margin-left:auto}
    .dbus-group-label{
      font-size:11px;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:#7c879d;
      font-weight:700;
    }
    .dbus-modes{display:flex;gap:6px;align-items:center}
    .dbus-mode-btn{border:1px solid #2c2c2c;background:#1a1a1a;color:#b1b1b1;padding:6px 14px;border-radius:10px;font-size:13px;font-weight:700;cursor:pointer}
    .dbus-mode-btn:hover{background:#252525;color:#d0d6e6}
    .dbus-mode-btn.active{background:#343434;color:#f2f2f2;border-color:#444444;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.04)}
    .dbus-footer{
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border-top:1px solid #2c2c2c;
      background:var(--panel2);
      border-radius:12px;
      margin-top:10px;
      flex:0 0 auto;
    }
    #dbusPanel .dbus-layout{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px 12px 12px;
    }
    #dbusPanel .dbus-box{
      border:1px solid #2c2c2c;
      border-radius:12px;
      background:#1a1a1a;
      min-height:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    #dbusPanel .dbus-lines-box{flex:1 1 auto}
    #dbusPanel .dbus-routes-box{
      flex:1 1 auto;
      min-height:220px;
      max-height:none;
    }
    #dbusPanel .dbus-network-filters{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      padding:0 6px 6px;
    }
    #dbusPanel .dbus-box-title{
      padding:10px 12px;
      border-bottom:1px solid #2c2c2c;
      color:#b1b1b1;
      font-size:12px;
      font-weight:700;
      letter-spacing:.04em;
      text-transform:uppercase;
      background:#171717;
      display:flex;
      align-items:center;
      gap:8px;
    }
    #dbusPanel .dbus-box-title-label{
      flex:1 1 auto;
      min-width:0;
    }
    #dbusPanel .dbus-box-clear{
      margin-left:auto;
      border:none;
      background:transparent;
      color:#ef4444;
      font-size:18px;
      line-height:1;
      font-weight:900;
      padding:0 2px;
      cursor:pointer;
      border-radius:6px;
    }
    #dbusPanel .dbus-box-clear:hover{
      color:#ff6666;
      background:rgba(239,68,68,0.12);
    }
    #dbusPanel .dbus-box .dbus-content{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
    }
    #dbusPanel .dbus-footer{
      margin-top:0;
      border-radius:0;
      border-top:none;
      border-bottom:1px solid #2c2c2c;
      background:#171717;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      gap:10px;
      padding:10px 12px;
    }
    #dbusPanel .dbus-footer-row{
      display:flex;
      flex-direction:column;
      gap:6px;
      width:100%;
    }
    #dbusPanel .dbus-sort-modes{
      display:flex;
      align-items:center;
      gap:6px;
      width:100%;
    }
    #dbusPanel .dbus-sort-modes .dbus-mode-btn{
      flex:1 1 0;
      text-align:center;
    }
    #dbusRoutesList .dbus-none{
      margin:6px;
    }
    .dbus-filters{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .dbus-switch{display:inline-flex;align-items:center;gap:8px;padding:4px 8px;border:1px solid #2c2c2c;border-radius:999px;background:#1a1a1a;color:#b1b1b1;font-size:12px;font-weight:700}
    .dbus-switch-label{white-space:nowrap}
    .dbus-switch input{
      appearance:none;
      width:34px;height:20px;
      background:#2a2a2a;
      border-radius:999px;
      border:1px solid #444444;
      position:relative;
      cursor:pointer;
      transition:background .2s ease,border-color .2s ease;
    }
    .dbus-switch input::after{
      content:"";
      position:absolute;
      width:16px;height:16px;
      border-radius:50%;
      background:#ececec;
      top:1px;left:1px;
      transition:transform .2s ease;
      box-shadow:0 2px 6px rgba(0,0,0,.4);
    }
    .dbus-switch input:checked{
      background:#5e5e5e;
      border-color:#5e5e5e;
    }
    .dbus-switch input:checked::after{transform:translateX(14px)}
    .dbus-depart-indicator-wrap{display:flex;justify-content:flex-end;margin-top:6px}
    .dbus-depart-indicator-wrap[hidden]{display:none !important}
    .dbus-depart-indicator{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #444444;
      background:color-mix(in oklab, var(--panel) 92%, #000 8%);
      color:#e0e0e0;
      font-size:12px;
      font-weight:700;
      box-shadow:0 8px 20px rgba(0,0,0,.35);
    }
    .dbus-depart-close{
      background:transparent;
      border:none;
      color:#ef4444;
      font-size:25px;
      line-height:1;
      cursor:pointer;
      padding:0 2px;
    }
    .dbus-depart-close:hover{color:#ff6666}
    .dbus-stop-panel .dbus-close{margin-left:auto}
    .dbus-list{padding:6px}
    .dbus-depart-actions{padding:6px 12px 0}
    .dbus-depart-map-btn{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #2c2c2c;
      background:#1a1a1a;
      color:#e0e0e0;
      font-size:20px;
      font-weight:700;
      cursor:pointer;
    }
    .dbus-depart-map-btn:hover{background:#252525;color:#f2f2f2}
    .dbus-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, 90px);
      gap: 4px; 
      padding: 6px;
      justify-content: start; 
      align-items: start;
    }
    .dbus-double {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 10px;
      padding-bottom: 10px;
      grid-auto-rows: minmax(0, auto);
    }
    .dbus-double .dbus-item {
      width: 100%;
      box-sizing: border-box;
    }
    .dbus-double .dbus-item .rname {
      max-width: 100%;
      word-break: break-word;
    }
    .line-block{display:flex;flex-direction:column;align-items:flex-start}
    .dbus-logo{width:88px;height:36px;border-radius:8px;display:flex;align-items:center;justify-content:center;border:1px solid #2c2c2c;background:#303030;color:#fff;font-weight:800;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,0.04)}
    .dbus-logo--titus{border:none;background:transparent;box-shadow:none}
    .dbus-logo.dim{opacity:.25; filter:grayscale(100%);}
    .dbus-logo.sel{position:relative}
    
    .dbus-logo img{display:block;width:100%;height:100%;object-fit:contain;border-radius:10px}
    .routes-host .dbus-item{margin:2px 6px;padding:8px 10px}
    .line-routes{margin-top:8px;width:100%}
    .dbus-item{display:flex;align-items:center;gap:10px;padding:10px 12px;border:1px solid #2c2c2c;border-radius:10px;background:var(--panel2);cursor:pointer;margin:6px}
    .dbus-item:hover{background:#222222}
    .dbus-item .badge{display:flex;align-items:center;justify-content:center;width:72px;height:32px;border-radius:8px;font-weight:800;font-size:16px}
    .dbus-route-logo{width:46px;height:26px;object-fit:contain;flex:0 0 auto}
    .dbus-route-logo + .dbus-route-logo{margin-left:6px}
    .dbus-item .rname{
      color:var(--text);
      font-size:14px;
      white-space:normal;
      overflow:hidden;
      text-overflow:clip;
      word-break:break-word;
      line-height:1.3;
    }
    .dbus-duration{margin-left:auto;min-width:90px;text-align:right;color:#a5a5a5;font-size:13px;align-self:flex-start}
    .dbus-item-length{
      align-items:flex-start;
    }
    .dbus-item-length.logo-badge-tight{
      gap:6px;
    }
    .dbus-item-length.logo-badge-tight .dbus-route-logo + .badge{
      margin-left:-4px;
    }
    .dbus-item-length .dbus-item-meta{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:4px;
      flex:1 1 auto;
      min-width:0;
    }
    .dbus-item-length .rname{
      width:100%;
    }
    .dbus-item-length .dbus-duration{
      margin-left:0;
      min-width:0;
      text-align:left;
      align-self:flex-start;
    }
    .dbus-stop-count{
      min-width:44px;
      height:32px;
      border-radius:8px;
      background:#343434;
      color:#f2f2f2;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      font-size:14px;
    }
    .dbus-none{display:flex;align-items:center;gap:10px;padding:10px 12px;border:1px dashed #303030;border-radius:10px;background:#171717;color:#a5a5a5;cursor:pointer;margin:6px}
    .dbus-item.active{ outline:2px solid #ffffff55; background:#222222; }
    .dbus-sec{margin:8px 6px 4px}
    .dbus-sec h4{
      margin:10px 6px 6px;
      color:#b1b1b1;
      font-size:12px;
      font-weight:700;
      letter-spacing:.04em;
      text-transform:uppercase;
    }
    .dbus-sechead {
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      color:#b1b1b1;
      font-size:13px;
      font-weight:700;
      text-transform:uppercase;
      border-bottom:1px solid #2c2c2c;
      background:var(--panel2);
      cursor:pointer;
      user-select:none;
    }
    .dbus-sechead-logo{
      height:20px;
      width:auto;
      object-fit:contain;
      display:block;
      border-radius:4px;
    }
    .dbus-sechead .chev {
      transition: transform .18s ease;
    }
    .dbus-sechead[aria-expanded="false"] .chev {
      transform: rotate(-90deg);
    }
    .dbus-secbody[hidden] { display:none; }
    .dbus-stop-panel .dbus-sec{margin:6px 6px 4px}
    .dbus-stop-panel .dbus-sec h4{margin:8px 6px 4px}
    .dbus-stop-panel .dbus-sec .dbus-sec{margin:6px 4px 4px}

    .dbus-depart-icon{background:transparent;border:none}
    .dbus-depart-dot{
      width:24px;height:24px;border-radius:50%;
      background:#f2f2f2;border:2px solid #121212;color:#121212;
      display:flex;align-items:center;justify-content:center;
      font-size:12px;font-weight:800;box-shadow:0 4px 10px rgba(0,0,0,.35);
    }
    .dbus-depart-dot.is-hover{background:#dbeafe}
    .dbus-depart-dot.is-selected{background:#60a5fa}
    .leaflet-tooltip.dbus-depart-tooltip{
      background:color-mix(in oklab, var(--panel2) 90%, #000 10%);
      border:1px solid #2c2c2c;
      color:var(--text);
      padding:4px 8px;
      border-radius:8px;
      box-shadow:var(--shadow);
      font-size:12px;
      font-weight:700;
    }
    .leaflet-tooltip.dbus-depart-tooltip:before{border-top-color:#2c2c2c}


    .watermark{
      position:fixed;
      right:14px;
      bottom:14px;
      z-index:400;
      pointer-events:none;
      filter:grayscale(10%);
      mix-blend-mode:screen;
      transition:transform .2s ease, opacity .2s ease;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
    }
    .watermark.dbus-open{
      transform:translateX(calc(-1 * min(var(--sidePanelW), 50vw, 94vw) - 10px));
    }
    body.side-panel-resizing .watermark.dbus-open{
      transform:translateX(calc(-1 * var(--sidePanelDragShift, 460px) - 10px));
    }
    .side-panel-resizer{
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:12px;
      cursor:ew-resize;
      z-index:3;
      touch-action:none;
      background:linear-gradient(to right, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .side-panel-resizer::after{
      content:"";
      position:absolute;
      left:2px;
      top:50%;
      transform:translateY(-50%);
      width:2px;
      height:70px;
      border-radius:2px;
      background:rgba(255,255,255,.28);
    }
    .side-panel-resizer:hover::after{
      background:rgba(255,255,255,.45);
    }
    .watermark img{
      display:block;
      width:220px;
      max-width:32vw;
      height:auto;
      opacity:.2;
      pointer-events:none;
    }
    .watermark-version{
      font-size:11px;
      font-weight:700;
      letter-spacing:.03em;
      color:#ffffff;
      opacity:.2;
      cursor:default;
      user-select:none;
      -webkit-user-select:none;
      text-align:right;
      text-shadow:0 1px 2px rgba(0,0,0,.55);
      max-width:min(340px, 56vw);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }
    .watermark-version.is-outdated{
      color:#ff0000;
    }
    .leaflet-top.leaflet-left .leaflet-control{display:none !important}

    .inline-ico{ height:1.5em; width:auto; vertical-align:-.35em; margin:0 .12em }
    .rer-invert { filter: invert(1); }
    .leaflet-popup-content{white-space:normal;overflow:visible}
    .dbus-stop-name{font-size:15px;line-height:1.35;word-break:break-word}
    .stop-popup{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-width:260px;
      max-width:420px;
      font-size:13px;
      color:#d4dcf0;
    }
    .stop-popup .sp-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 10px;
      border-radius:10px;
      background:color-mix(in oklab,var(--panel2) 85%, #000 15%);
      border:1px solid rgba(255,255,255,0.08);
    }
    .stop-popup .sp-title{
      font-weight:700;
      font-size:14px;
      color:#f2f2f2;
    }
    .stop-popup .sp-index{
      padding:2px 10px;
      border-radius:999px;
      background:#2a2a2a;
      border:1px solid #3a3a3a;
      color:#e2e2e2;
      font-weight:700;
      font-size:12px;
    }
    .stop-popup .sp-body{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .stop-popup .sp-coords{
      font-size:12px;
      line-height:1.5;
      color:#a5a5a5;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid #303030;
      background:#1a1a1a;
    }
    .stop-popup .sp-coords span{
      display:block;
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:.05em;
      font-size:11px;
      margin-bottom:3px;
      color:#c2c2c2;
    }
    .stop-popup .sp-coords-code{
      font-family: "JetBrains Mono", "Fira Code", Consolas, monospace;
      font-size:12px;
      color:#ececec;
    }
    .stop-popup .sp-coords-row{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .stop-popup .sp-coords-row .sp-coords-code{
      flex:1 1 auto;
      min-width:0;
    }
    .stop-popup .sp-copy-cmd{
      position:relative;
      flex:0 0 auto;
      margin-left:auto;
      border:1px solid #3a3a3a;
      background:#232323;
      color:#ececec;
      border-radius:8px;
      padding:4px 8px;
      font-size:11px;
      font-weight:600;
      cursor:pointer;
      white-space:nowrap;
    }
    .stop-popup .sp-copy-cmd:hover{
      background:#2c2c2c;
      border-color:#4a4a4a;
    }
    .stop-popup .sp-copy-cmd::after{
      content:attr(data-copied-label);
      position:absolute;
      right:0;
      bottom:calc(100% + 6px);
      padding:4px 7px;
      border-radius:6px;
      border:1px solid #2f4f2f;
      background:#1d3a24;
      color:#d4ffd9;
      font-size:10px;
      font-weight:700;
      white-space:nowrap;
      opacity:0;
      pointer-events:none;
      transform:translateY(3px);
      transition:opacity .16s ease, transform .16s ease;
      z-index:3;
    }
    .stop-popup .sp-copy-cmd.show-copy-tooltip::after{
      opacity:1;
      transform:translateY(0);
    }
    .dbus-stop-lines-popup{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:260px;
      max-width:420px;
      font-size:13px;
      color:#d4dcf0;
    }
    .dbus-stop-lines-title{
      font-weight:700;
      font-size:14px;
      color:#f2f2f2;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.10);
      background:color-mix(in oklab,var(--panel2) 85%, #000 15%);
    }
    .dbus-stop-lines-row{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.06);
      background:rgba(15,23,34,0.78);
    }
    .dbus-stop-lines-logo{
      width:48px;
      height:24px;
      object-fit:contain;
      flex:0 0 auto;
    }
    .dbus-stop-lines-badges{
      display:flex;
      align-items:center;
      flex-wrap:wrap;
      gap:4px;
      min-width:0;
    }
    .dbus-stop-line-badge{
      margin:0;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,0.08);
    }
    .dbus-stop-line-school-logo{
      width:20px;
      height:20px;
      object-fit:contain;
      border-radius:4px;
      box-shadow:0 0 0 1px rgba(255,255,255,0.08);
      background:rgba(8,12,20,0.7);
      padding:1px;
      box-sizing:border-box;
      flex:0 0 auto;
    }
    .dbus-stop-marker-host{
      background:transparent !important;
      border:none !important;
    }
    .dbus-stop-marker-wrap{
      position:relative;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:auto;
    }
    .dbus-stop-marker{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      filter:drop-shadow(0 1px 2px rgba(0,0,0,.55));
      pointer-events:none;
      user-select:none;
    }
    .dbus-stop-marker-count{
      position:absolute;
      right:-4px;
      top:-4px;
      min-width:14px;
      height:14px;
      padding:0 3px;
      border-radius:999px;
      background:#121212;
      border:1px solid rgba(255,255,255,0.30);
      color:#ececec;
      font-size:9px;
      font-weight:800;
      line-height:12px;
      text-align:center;
      box-shadow:0 2px 6px rgba(0,0,0,.5);
      pointer-events:none;
    }
    .leaflet-popup-content-wrapper,
    .leaflet-popup-tip{
      background:color-mix(in oklab,var(--panel) 92%, #000 8%);
      color:var(--text);
      border:1px solid #2e2e2e;
      box-shadow:0 12px 32px rgba(0,0,0,.55);
    }

    @media (max-width:800px){
      .search-panel{min-width:0;max-width:92vw}
      .search-input{min-width:180px}
      .watermark img{width:180px}
    }
    .selected-chip{margin-top:6px;display:none;width:100%}
    .line-chip{display:flex;align-items:center;padding:6px 6.5px;border:1px solid var(--border);border-radius:12px;background:color-mix(in oklab, var(--panel) 92%, #000 8%);box-shadow:var(--shadow);width:fit-content}
    .line-chip .close{margin-left:10px;border:none;background:transparent;color:#ef4444;font-weight:900;font-size:22px;cursor:pointer;line-height:1}
    .line-chip .close:hover{color:#ff6666}

    .line-preview-wrap{
      position:fixed;
      left:12px;
      top:calc(var(--header-stack-h) + 12px);
      right:auto;
      bottom:auto;
      transform:none;
      z-index:1100;
      pointer-events:none;
    }
    .line-preview-wrap.with-side-panel{
      right:auto;
    }
    .line-preview{
      margin:0;
      width:max-content;
      max-width:calc(100vw - 24px);
      background:rgba(11,17,24,0);
      padding:10px 12px;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .line-preview-wrap.is-open .line-preview{
      animation:previewIn var(--anim-slow) var(--anim-ease) both;
    }
    .line-preview-wrap.is-closing .line-preview{
      animation:previewOut var(--anim-slow) var(--anim-ease) both;
      pointer-events:none;
    }
    .line-preview-info{
      border:1px solid #2c2c2c;
      background:rgba(18,18,18,.98);
      padding:10px;
      width:100%;
      box-sizing:border-box;
      position:relative;
      overflow:hidden;
      isolation:isolate;
      pointer-events:auto;
    }
    .line-preview-info::before{
      content:"";
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      background:rgba(18,18,18,.98);
      backdrop-filter:blur(22px) saturate(1.3);
      -webkit-backdrop-filter:blur(22px) saturate(1.3);
    }
    .line-preview-info > *{
      position:relative;
      z-index:1;
    }
    .line-preview-info-header{
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .line-preview-info-text{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
      flex:1 1 auto;
    }
    .line-preview .dbus-badge {
      width:72px;
      min-width:72px;
      height:30px;
      padding:0 8px;
      box-sizing:border-box;
      font-size:18px;
      font-variant-numeric:tabular-nums;
      align-self:flex-start;
    }
    .line-preview-route{
      color:var(--text);
      font-weight:700;
      font-size:14px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .line-preview-meta{
      color:#a5a5a5;
      font-size:12px;
      font-weight:600;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .line-preview-stops{
      --lineColor:#8a8a8a;
      background:rgba(18,18,18,.98);
      padding:5px;
      width:max-content;
      max-width:calc(100vw - 48px);
      box-sizing:border-box;
      border:1px solid #2c2c2c;
      position:relative;
      overflow:hidden;
      isolation:isolate;
      pointer-events:auto;
    }
    .line-preview-scroll-cue{
      position:absolute;
      left:6px;
      right:6px;
      height:24px;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index:3;
      opacity:0;
      transition:opacity var(--anim-fast) var(--anim-ease);
    }
    .line-preview-scroll-cue::before{
      content:"";
      position:absolute;
      inset:0;
      z-index:0;
    }
    .line-preview-scroll-cue > span{
      position:relative;
      z-index:1;
      color:var(--lineColor, #8a8a8a);
      font-size:26px;
      font-weight:900;
      text-shadow:0 2px 6px rgba(0,0,0,.65);
      letter-spacing:.02em;
      opacity:.98;
      line-height:1;
    }
    .line-preview-scroll-cue.top{top:4px}
    .line-preview-scroll-cue.top::before{
      background:linear-gradient(to bottom, rgba(12,12,12,.75), rgba(12,12,12,0));
    }
    .line-preview-scroll-cue.bottom{bottom:4px}
    .line-preview-scroll-cue.bottom::before{
      background:linear-gradient(to top, rgba(12,12,12,.75), rgba(12,12,12,0));
    }
    .line-preview-stops.can-scroll-up .line-preview-scroll-cue.top,
    .line-preview-stops.can-scroll-down .line-preview-scroll-cue.bottom{
      opacity:1;
      pointer-events:auto;
      cursor:pointer;
    }
    .line-preview-stops.can-scroll-up .line-preview-scroll-cue.top > span{
      animation:scrollCuePulse 1.2s ease-in-out infinite, scrollCueNudgeUp 1.2s ease-in-out infinite;
    }
    .line-preview-stops.can-scroll-down .line-preview-scroll-cue.bottom > span{
      animation:scrollCuePulse 1.2s ease-in-out infinite, scrollCueNudgeDown 1.2s ease-in-out infinite;
    }
    .line-preview-stops::before{
      content:"";
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      background:rgba(18,18,18,.28);
      backdrop-filter:blur(55px) saturate(1.3);
      -webkit-backdrop-filter:blur(55px) saturate(1.3);
    }
    .line-preview-stops > *{
      position:relative;
      z-index:1;
    }
    .line-preview-close{ border:none;background:transparent;color:#ef4444;font-weight:900; font-size:22px;cursor:pointer;line-height:1;padding:2px 6px;border-radius:8px; }
    .line-preview-close:hover{ color:#ff6666; background:rgba(28,28,28,.45); }
    .line-preview-actions{ display:flex; align-items:center; gap:6px; flex:0 0 auto; margin-left:auto; }
    .line-preview-link{
      display:inline-flex; align-items:center; justify-content:center;
      width:28px; height:28px; border-radius:8px;
      border:1px solid #2c2c2c; background:transparent; color:#a5a5a5;
      text-decoration:none; cursor:pointer;
    }
    .line-preview-link:hover{ background:rgba(28,28,28,.45); color:#f2f2f2; }
    .line-preview-link svg{ width:16px; height:16px; display:block; stroke:currentColor; fill:none; stroke-width:2; stroke-linecap:round; stroke-linejoin:round; }
    .line-preview-audio-link{
      position:relative;
      overflow:hidden;
    }
    .line-preview-audio-link.is-route-missing::after{
      content:"";
      position:absolute;
      left:4px;
      right:4px;
      top:50%;
      height:2px;
      background:currentColor;
      border-radius:2px;
      transform:translateY(-50%) rotate(-36deg);
      opacity:.92;
      pointer-events:none;
    }
    .line-preview-audio-panel{
      position:fixed;
      z-index:1350;
      left:12px;
      top:calc(var(--header-stack-h) + 10px);
      width:min(560px, calc(100vw - 24px));
      border:none;
      border-radius:0;
      background:transparent;
      box-shadow:none;
      color:var(--text);
      display:none;
      user-select:none;
    }
    .line-preview-audio-panel.is-open{display:block}
    .line-preview-audio-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:8px 10px;
      border:1px solid #3a3a3a;
      border-radius:12px;
      background:linear-gradient(180deg, #141414 0%, #101010 100%);
      box-shadow:0 12px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
      cursor:move;
      touch-action:none;
    }
    .line-preview-audio-title-row{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
      flex:1 1 auto;
    }
    .line-preview-audio-title{
      font-size:13px;
      font-weight:700;
      color:#d9d9d9;
      flex:1 1 auto;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .line-preview-audio-exp-badge{
      flex:0 0 auto;
    }
    .line-preview-audio-body{
      padding:10px 0 0;
      display:flex;
      flex-direction:column;
      gap:12px;
      background:transparent;
    }
    .line-preview-audio-main{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .line-preview-audio-card{
      border:1px solid #3a3a3a;
      outline:1px solid #1f1f1f;
      border-radius:12px;
      background:linear-gradient(180deg, #1c1c1c 0%, #131313 100%);
      box-shadow:0 14px 30px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.02);
      padding:10px;
    }
    .line-preview-audio-route{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .line-preview-audio-section-head{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .line-preview-audio-section-title{
      font-size:13px;
      font-weight:800;
      letter-spacing:.35px;
      text-transform:uppercase;
      color:#d8d8d8;
      line-height:1.1;
      padding:2px 0;
      flex:1 1 auto;
    }
    .line-preview-audio-head-select{
      margin-left:auto;
      width:min(230px, 44vw);
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-end;
      min-width:130px;
    }
    .line-preview-audio-extension-missing{
      border:1px solid #5a1f1f;
      outline:1px solid #2c1212;
      background:linear-gradient(180deg, #2b1010 0%, #1d0b0b 100%);
      border-radius:12px;
      box-shadow:0 10px 24px rgba(0,0,0,.38), inset 0 1px 0 rgba(255,255,255,.02);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .line-preview-audio-extension-missing-title{
      color:#ffd0d0;
      font-size:13px;
      font-weight:800;
    }
    .line-preview-audio-extension-missing-text{
      color:#f2dada;
      font-size:12px;
      line-height:1.4;
    }
    .line-preview-audio-extension-missing-note{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .line-preview-audio-extension-missing-badge{
      align-self:flex-start;
      user-select:text;
      -webkit-user-select:text;
    }
    .line-preview-audio-extension-missing-actions{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:2px;
    }
    .line-preview-audio-code-badge{
      display:inline-flex;
      align-items:center;
      min-height:20px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(0,0,0,.25);
      color:#ffe6e6;
      font-size:11px;
      font-weight:700;
      letter-spacing:.02em;
      box-sizing:border-box;
      word-break:break-word;
      user-select:text;
      -webkit-user-select:text;
    }
    .line-preview-audio-extension-link{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:34px;
      border:1px solid #7a2f2f;
      border-radius:10px;
      background:#3a1515;
      color:#ffe6e6;
      text-decoration:none;
      font-size:12px;
      font-weight:700;
      padding:6px 10px;
      box-sizing:border-box;
      cursor:pointer;
    }
    .line-preview-audio-extension-link:hover{
      background:#4a1b1b;
    }
    .line-preview-audio-extension-btn{
      appearance:none;
      -webkit-appearance:none;
      font-family:inherit;
    }
    .line-preview-audio-extension-btn[hidden]{
      display:none !important;
    }
    .line-preview-audio-extension-dialog{
      border:1px solid #552424;
      border-radius:12px;
      width:min(560px, calc(100vw - 24px));
      max-height:min(82vh, 760px);
      padding:0;
      background:linear-gradient(180deg, #1c1c1c 0%, #121212 100%);
      color:#ececec;
      box-shadow:0 26px 58px rgba(0,0,0,.65);
    }
    .line-preview-audio-extension-dialog::backdrop{
      background:rgba(0,0,0,.64);
      backdrop-filter:blur(2px);
    }
    .line-preview-audio-extension-dialog-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:10px 12px;
      border-bottom:1px solid #2c2c2c;
      background:linear-gradient(180deg, #181818 0%, #121212 100%);
    }
    .line-preview-audio-extension-dialog-title{
      font-size:14px;
      font-weight:800;
      color:#ffdede;
      margin:0;
    }
    .line-preview-audio-extension-dialog-body{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      max-height:calc(min(82vh, 760px) - 56px);
      color:#e7d9d9;
      font-size:12px;
      line-height:1.45;
    }
    .line-preview-audio-extension-guide{
      margin:0;
      padding-left:18px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .line-preview-audio-extension-guide li{
      margin:0;
    }
    .line-preview-audio-extension-dialog-links{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:2px;
    }
    .line-preview-audio-style{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .line-preview-audio-style-wrap{
      display:flex;
      flex-direction:column;
      gap:4px;
      flex:1 1 auto;
      min-width:0;
    }
    .line-preview-audio-style-label{
      font-size:12px;
      font-weight:700;
      color:#c7c7c7;
      min-width:78px;
      white-space:nowrap;
    }
    .line-preview-audio-panel .line-preview-audio-head-select select,
    .line-preview-audio-panel .line-preview-audio-style select,
    .line-preview-audio-panel .line-preview-audio-global-head select{
      flex:1 1 auto;
      min-height:30px;
      border:1px solid #151515;
      border-radius:8px;
      background:#030303 !important;
      color:#ececec !important;
      font-size:13px;
      padding:4px 8px;
      outline:none;
      color-scheme:dark;
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
      background-repeat:no-repeat;
      background-position:right 8px center;
      background-size:12px 12px;
      padding-right:26px;
      forced-color-adjust:none;
      -webkit-text-fill-color:#ececec !important;
    }
    .line-preview-audio-panel .line-preview-audio-head-select select{
      width:100%;
      min-height:26px;
      font-size:12px;
      padding:3px 8px;
      padding-right:26px;
    }
    .line-preview-audio-panel .line-preview-audio-head-select select:disabled,
    .line-preview-audio-panel .line-preview-audio-style select:disabled,
    .line-preview-audio-panel .line-preview-audio-global-head select:disabled{
      opacity:1;
      background:#030303 !important;
      border-color:#151515 !important;
      color:#6c6c6c !important;
      -webkit-text-fill-color:#6c6c6c !important;
      cursor:not-allowed;
    }
    .line-preview-audio-style-byline{
      font-size:9px;
      color:#8e8e8e;
      line-height:1.25;
      min-height:11px;
      text-align:right;
      align-self:flex-end;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .line-preview-audio-now{
      min-height:54px;
      display:flex;
      align-items:center;
      min-width:0;
    }
    .line-preview-audio-now-kicker{
      font-size:11px;
      font-weight:700;
      color:#cfcfcf;
      letter-spacing:.2px;
      line-height:1.1;
    }
    .line-preview-audio-now-row{
      display:grid;
      grid-template-columns:auto 1fr auto;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .line-preview-audio-nav-btn{
      min-width:34px;
      width:34px;
      height:46px;
      padding:0;
      font-size:20px;
      font-weight:800;
      line-height:1;
      border-radius:8px;
    }
    .line-preview-audio-stop-sign{
      display:flex;
      align-items:center;
      justify-content:center;
      width:100%;
      min-width:0;
      min-height:46px;
      border-radius:3px;
      border:1px solid #0a1230;
      background:
        linear-gradient(180deg, #0d2f8b 100%, #0a2266 100%, #07184a 100%);
      padding:6px 12px;
      box-sizing:border-box;
    }
    .line-preview-audio-stop-sign-text{
      display:block;
      width:100%;
      text-align:center;
      color:#f4f7ff;
      font-weight:800;
      font-size:31px;
      line-height:1;
      letter-spacing:.3px;
      white-space:nowrap;
      overflow:hidden;
      text-shadow:0 1px 2px rgba(0,0,0,.35);
    }
    .line-preview-audio-stop-empty{
      color:#b9b9b9;
      font-size:13px;
    }
    .line-preview-audio-route-empty{
      border:1px dashed #2e2e2e;
      border-radius:10px;
      padding:12px;
      text-align:center;
      background:#161616;
    }
    .line-preview-audio-actions{
      display:grid;
      grid-template-columns:repeat(2, minmax(0, 1fr));
      gap:8px;
    }
    .line-preview-audio-global{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .line-preview-audio-global-head{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .line-preview-audio-global-wrap{
      display:flex;
      flex-direction:column;
      gap:4px;
      flex:1 1 auto;
      min-width:0;
    }
    .line-preview-audio-global-label{
      font-size:12px;
      font-weight:700;
      color:#c7c7c7;
      min-width:56px;
      white-space:nowrap;
    }
    .line-preview-audio-global-byline{
      font-size:9px;
      color:#8e8e8e;
      line-height:1.25;
      min-height:11px;
      text-align:right;
      align-self:flex-end;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .line-preview-audio-panel .line-preview-audio-head-select select option,
    .line-preview-audio-panel .line-preview-audio-head-select select optgroup,
    .line-preview-audio-panel .line-preview-audio-style select option,
    .line-preview-audio-panel .line-preview-audio-style select optgroup,
    .line-preview-audio-panel .line-preview-audio-global-head select option,
    .line-preview-audio-panel .line-preview-audio-global-head select optgroup{
      background:#030303;
      color:#ececec;
    }
    .line-preview-audio-panel .line-preview-audio-head-select select::-ms-expand{
      display:none;
    }
    .line-preview-audio-global-buttons{
      display:grid;
      grid-template-columns:repeat(2, minmax(0, 1fr));
      gap:8px;
    }
    .line-preview-audio-volume{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .line-preview-audio-volume-row{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .line-preview-audio-volume-label{
      font-size:12px;
      font-weight:700;
      color:#c7c7c7;
      min-width:52px;
      white-space:nowrap;
    }
    .line-preview-audio-volume input[type="range"]{
      flex:1 1 auto;
      accent-color:#60a5fa;
    }
    .line-preview-audio-volume-stop{
      flex:0 0 auto;
      min-height:30px;
      padding:6px 10px;
      font-size:12px;
      line-height:1;
    }
    .line-preview-audio-btn{
      border:1px solid #1c1c1c;
      border-radius:10px;
      background:#050505;
      color:#ececec;
      min-height:34px;
      padding:8px 10px;
      font-size:13px;
      font-weight:700;
      cursor:pointer;
    }
    .line-preview-audio-btn:hover{
      background:#101010;
    }
    .line-preview-audio-btn:disabled{
      opacity:1;
      background:#020202;
      border-color:#151515;
      color:#555;
      box-shadow:none;
      cursor:not-allowed;
    }
    .line-preview{
      --lp-logo-h:36px;
      --lp-chip-ratio:2.25;
    }
    .line-preview .network-badge{
      align-items:stretch;
      height:var(--lp-logo-h);
    }
    .line-preview .network-badge img{
      height:100%;
      width:auto;
    }
    .line-preview .network-badge .dbus-badge,
    .line-preview .network-badge .network-chip,
    .line-preview .network-badge .titus-chip{
      --_lp-chip-ratio:var(--lp-chip-ratio);
      height:var(--lp-logo-h) !important;
      min-height:var(--lp-logo-h) !important;
      width:calc(var(--lp-logo-h) * var(--_lp-chip-ratio)) !important;
      min-width:calc(var(--lp-logo-h) * var(--_lp-chip-ratio)) !important;
      box-sizing:border-box;
      padding:0 8px;
    }
    .line-preview .network-badge .network-chip.network-chip-express{
      --_lp-chip-ratio:3.2;
    }

    .transit-scroll{
      overflow-x:auto;
      overflow-y:auto;
      white-space:normal;
      max-height:min(130vh,620px);
      padding-right:4px;
      width:max-content;
      max-width:calc(100vw - 64px);
      box-sizing:border-box;
      direction:rtl;
    }
    .transit{
      --lineColor:#8a8a8a;
      --lineX:14px;
      --dot:14px;
      --gapY:8px;
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:var(--gapY);
      min-height:0;
      padding:1px 0 4px;
      width:max-content;
      direction:ltr;
    }
    .transit-main-line{
      position:absolute;
      top:0;
      left:calc(var(--lineX) - 2px);
      width:4px;
      height:0;
      border-radius:2px;
      background:var(--lineColor);
      pointer-events:none;
      z-index:0;
    }

    .stop{
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      flex:0 0 auto;
      box-sizing:border-box;
      width:max-content;
      min-height:var(--dot);
      padding-left:30px;
      padding-right:2px;
      z-index:1;
    }
    .stop .dot{
      position:absolute;
      left:var(--lineX);
      top:0;
      transform:translateX(-50%);
      width:var(--dot);
      height:var(--dot);
      border-radius:50%;
      background:var(--lineColor);
      border:none; box-shadow:0 1px 2px rgba(0,0,0,.5); }
    .stop.first .dot,
    .stop.last .dot{
      background:#fff;
      border:2px solid #000;
      box-sizing:border-box;
    }
    .stop.first .dot::after,
    .stop.last .dot::after{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      width:5px;
      height:5px;
      border-radius:50%;
      background:var(--lineColor);
      transform:translate(-50%,-50%);
    }
    .stop .name{
      color:var(--text);
      font-size:11px;
      line-height:1.3;
      display:inline-block;
      width:auto;
      min-width:auto;
      text-align:left;
      margin-top:0;
      font-weight:700;
      max-width:none;
      white-space:nowrap;
      overflow:visible;
      text-overflow:clip;
    }
    .stop-flag{
      font-size:8px;
      color:#fbbf24;
      background:rgba(251,191,36,0.2);
      border:1px solid rgba(251,191,36,0.4);
      border-radius:999px;
      padding:2px 6px;
      margin-left:6px;
      white-space:nowrap;
      display:inline-block;
      text-transform:uppercase;
      letter-spacing:0.1em;
    }
    .stop .name .inline-ico{ height:1em; vertical-align:-.2em; }
    .stop.active .name{ color:#ffda3a; }

    @media (max-width:800px){
      .transit-scroll{max-height:min(44vh,280px)}
      .stop{padding-left:34px}
    }

    .rer-ico{
      display:inline-block;
      width:1.1em; height:1.1em;
      vertical-align:-.2em;
      background-color: currentColor;
      -webkit-mask: var(--rer-mask-url) no-repeat center / contain;
              mask: var(--rer-mask-url) no-repeat center / contain;
    }
    .metro-ico{
      display:inline-block;
      width:1.1em; height:1.1em;
      vertical-align:-.2em;
      background: var(--metro-icon-url) no-repeat center / contain;
    }

    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner{
      display:inline-block; width:16px; height:16px;
      border:2px solid #8f8f8f; border-top-color:#ececec;
      border-radius:50%; animation:spin .8s linear infinite;
      vertical-align:-.2em;
    }
    .route-dir-arrow-host{
      background:transparent;
      border:none;
    }
    .route-dir-arrow-rot{
      display:block;
      width:18px;
      height:18px;
      transform:rotate(var(--dir-angle, 0deg));
      transform-origin:50% 50%;
      pointer-events:none;
    }
    .route-dir-arrow-glyph{
      display:block;
      width:18px;
      height:18px;
      line-height:18px;
      text-align:center;
      font-size:18px;
      font-weight:900;
      color:var(--dir-color, #ffffff);
      text-shadow:
        0 0 2px rgba(0,0,0,.95),
        0 0 4px rgba(0,0,0,.85),
        -1px -1px 0 rgba(0,0,0,.95),
        1px -1px 0 rgba(0,0,0,.95),
        -1px 1px 0 rgba(0,0,0,.95),
        1px 1px 0 rgba(0,0,0,.95);
      opacity:.98;
      user-select:none;
      pointer-events:none;
      will-change:transform;
    }

    .results::-webkit-scrollbar,
    .dbus-content::-webkit-scrollbar,
    .dbus-stop-content::-webkit-scrollbar,
    .transit-scroll::-webkit-scrollbar { width: 10px; height: 10px; }
    .results::-webkit-scrollbar-track,
    .dbus-content::-webkit-scrollbar-track,
    .dbus-stop-content::-webkit-scrollbar-track,
    .transit-scroll::-webkit-scrollbar-track { background: var(--panel2); border-radius: 8px; }
    .results::-webkit-scrollbar-thumb,
    .dbus-content::-webkit-scrollbar-thumb,
    .dbus-stop-content::-webkit-scrollbar-thumb,
    .transit-scroll::-webkit-scrollbar-thumb {
      background: var(--muted); border-radius: 8px; border: 2px solid var(--panel2);
    }
    .results::-webkit-scrollbar-thumb:hover,
    .dbus-content::-webkit-scrollbar-thumb:hover,
    .dbus-stop-content::-webkit-scrollbar-thumb:hover,
    .transit-scroll::-webkit-scrollbar-thumb:hover { background: var(--text); }
    .results, .dbus-content, .dbus-stop-content, .transit-scroll { scrollbar-width: thin; scrollbar-color: var(--muted) var(--panel2); }
    .line-preview-stops .transit-scroll{
      scrollbar-width:none;
      -ms-overflow-style:none;
    }
    .line-preview-stops .transit-scroll::-webkit-scrollbar{
      width:0;
      height:0;
    }
    .line-preview-stops .transit-scroll::-webkit-scrollbar-track,
    .line-preview-stops .transit-scroll::-webkit-scrollbar-thumb{
      background:transparent;
      border:none;
    }
    body.line-preview-horizontal .line-preview-wrap{
      left:0;
      right:0;
      top:auto;
      bottom:0;
      transform:none;
      padding-bottom:env(safe-area-inset-bottom, 0);
    }
    body.line-preview-horizontal .line-preview-wrap.with-side-panel{
      right:min(var(--sidePanelW),50vw,94vw);
    }
    body.line-preview-horizontal .line-preview{
      margin:10px auto 12px;
      width:auto;
      max-width:min(1100px,94vw);
      background:color-mix(in oklab, var(--panel) 92%, #000 8%);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow:var(--shadow);
      padding:10px 12px;
      pointer-events:auto;
      display:block;
    }
    body.line-preview-horizontal .line-preview-info{
      width:auto;
      max-width:none;
      border:0;
      padding:0;
      margin:0 0 8px;
      background:transparent;
      isolation:auto;
      overflow:visible;
    }
    body.line-preview-horizontal .line-preview-info::before{
      display:none;
    }
    body.line-preview-horizontal .line-preview-info-header{
      align-items:center;
    }
    body.line-preview-horizontal .line-preview .dbus-badge{
      width:auto;
      min-width:56px;
      height:28px;
      padding:4px 10px;
      font-size:18px;
    }
    body.line-preview-horizontal .line-preview{
      --lp-logo-h:28px;
    }
    body.line-preview-horizontal .line-preview-stops{
      width:auto;
      max-width:none;
      padding:0;
      border:0;
      background:transparent;
      isolation:auto;
      overflow:visible;
    }
    body.line-preview-horizontal .line-preview-stops::before{
      display:none;
    }
    body.line-preview-horizontal .line-preview-scroll-cue{
      display:none !important;
    }
    body.line-preview-horizontal .transit-scroll{
      overflow-x:auto;
      overflow-y:hidden;
      white-space:nowrap;
      max-height:none;
      width:100%;
      max-width:none;
      padding-right:0;
      padding-bottom:4px;
      direction:ltr;
    }
    body.line-preview-horizontal .line-preview-stops .transit-scroll{
      scrollbar-width:thin;
      scrollbar-color:var(--muted) var(--panel2);
      -ms-overflow-style:auto;
    }
    body.line-preview-horizontal .line-preview-stops .transit-scroll::-webkit-scrollbar{
      width:10px;
      height:10px;
    }
    body.line-preview-horizontal .line-preview-stops .transit-scroll::-webkit-scrollbar-track{
      background:var(--panel2);
      border-radius:8px;
    }
    body.line-preview-horizontal .line-preview-stops .transit-scroll::-webkit-scrollbar-thumb{
      background:var(--muted);
      border-radius:8px;
      border:2px solid var(--panel2);
    }
    body.line-preview-horizontal .line-preview-stops .transit-scroll::-webkit-scrollbar-thumb:hover{
      background:var(--text);
    }
    body.line-preview-horizontal .transit{
      --rail-h:26px;
      --dot:16px;
      --gap:50px;
      --nameH:18px;
      position:relative;
      display:flex;
      flex-direction:row;
      align-items:flex-start;
      gap:0;
      min-height:calc(var(--rail-h) + var(--nameH) + 14px);
      padding:2px 2px 6px;
      width:max-content;
      direction:ltr;
    }
    body.line-preview-horizontal .transit-main-line{
      top:calc(var(--rail-h)/2 - 2px);
      left:0;
      width:0;
      height:4px;
      border-radius:2px;
    }
    body.line-preview-horizontal .stop{
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:center;
      flex:0 0 auto;
      box-sizing:border-box;
      width:auto;
      min-height:0;
      padding-top:calc(var(--rail-h) - var(--dot)/2);
      padding-left:0;
      padding-right:0;
      margin:0 calc(var(--gap)/2);
      z-index:1;
    }
    body.line-preview-horizontal .stop .dot{
      position:absolute;
      left:50%;
      top:calc(var(--rail-h)/2 - var(--dot)/2);
      transform:translateX(-50%);
      width:var(--dot);
      height:var(--dot);
    }
    body.line-preview-horizontal .stop .name{
      color:var(--text);
      font-size:12px;
      line-height:1.3;
      text-align:center;
      margin-top:8px;
      font-weight:700;
      max-width:110px;
      white-space:normal;
      overflow:visible;
      text-overflow:clip;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:2px;
    }
    body.line-preview-horizontal .stop-flag{
      margin-left:0;
    }

    .result-sechead{ display:flex;align-items:center;justify-content:space-between; cursor:pointer; user-select:none; }
    .result-sechead .chev{ font-size:14px; opacity:.9; transition:transform .18s ease; }
    .result-sechead[aria-expanded="false"] .chev{ transform:rotate(-90deg); }
    .result-secbody[hidden]{ display:none !important; }
    
    .results-filters,
    .search-categories{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:6px;
      width:100%;
    }
    .search-categories .dbus-mode-btn{
      padding:6px 10px;
      font-size:12px;
    }

    .result-sechead{ display:block; cursor:default; user-select:text; }
    .result-sechead .chev{ display:none !important; }

    .dbus-badge {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      font-size:20px;
      background:#444;
      color:#fff;
      padding:6px 14px;
      border-radius:8px;
      min-width:48px;
      text-align:center;
      position:relative; 
    }
    
    .titus-chip{
      height:32px;
      padding:0 8px;
      font-size:16px;
      min-width:72px;
      width:72px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      font-variant-numeric:tabular-nums;
    }
    .network-badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .network-badge img{
      height:36px;
      width:auto;
      object-fit:contain;
    }
    .network-logo-invert{
      filter: invert(1);
    }
    .network-chip{
      min-width:72px;
      width:72px;
      height:32px;
      padding:0 8px;
      font-size:16px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      font-variant-numeric:tabular-nums;
    }
    .line-preview .network-chip-express{
      min-width:116px;
      width:116px;
    }
    #lpBadge.lp-badge-wrapper{
      display:flex;
      align-items:center;
      background:transparent;
      padding:0;
    }
    
    .dbus-badge .noctilien-stripe {
      position:absolute;
      left:0; right:0; bottom:0;
      height:4px;
      border-bottom-left-radius:8px;
      border-bottom-right-radius:8px;
    }
    .has-noctilien-stripe .badge-label{
      transform:translateY(-1px);
    }

    .route-flag {
      font-size:8px;
      color:#fbbf24;
      background:rgba(255, 255, 255, 0.15);
      border:1px solid rgba(251,191,36,0.4);
      border-radius:999px;
      padding:1px 5px;
      text-transform:uppercase;
      letter-spacing:0.1em;
    }

    .badge.fictive {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-top: 10px;
      box-sizing: border-box;
    }

    .badge .fictive-stripe {
      position: absolute;
      top: 2px;
      left: 6px;
      right: 6px;
      height: 10px;
      border-radius: 4px;
      background: #000000;
      color: #fff;
      font-size: 8px;
      font-weight: 600;
      text-align: center;
      line-height: 10px;
      text-transform: uppercase;
      pointer-events: none;
      overflow: hidden;
      white-space: nowrap;
    }

    .badge-label {
      display: inline-block;
      white-space: nowrap;
      line-height: 1;
      position: relative;
      z-index: 1;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dbus-sechead .chev {
      transition: transform .18s ease;
    }
    .dbus-sechead[aria-expanded="false"] .chev {
      transform: rotate(-90deg);
    }

    .results {
      overflow-y: auto;
      scrollbar-gutter: stable;
    }

    .custom-scale {
      position: relative;
      height: 8px;
      margin: 10px;
      background: transparent;
      color: var(--text);
      font-size: 12px;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,.8);
      width: fit-content;
    }

    .custom-scale .bar {
      height: 3px;
      background: var(--text);
      border-radius: 2px;
    }

    .custom-scale span {
      position: absolute;
      top: -18px;
      left: 0;
    }

    @keyframes sidePanelIn{
      from{opacity:0;transform:translateX(22px)}
      to{opacity:1;transform:translateX(0)}
    }
    @keyframes sidePanelOut{
      from{opacity:1;transform:translateX(0)}
      to{opacity:0;transform:translateX(22px)}
    }
    @keyframes searchPanelIn{
      from{opacity:0;transform:translateY(-8px)}
      to{opacity:1;transform:translateY(0)}
    }
    @keyframes searchPanelOut{
      from{opacity:1;transform:translateY(0)}
      to{opacity:0;transform:translateY(-8px)}
    }
    @keyframes modalPanelIn{
      from{opacity:0;transform:translate(-50%,-47%) scale(.985)}
      to{opacity:1;transform:translate(-50%,-50%) scale(1)}
    }
    @keyframes modalPanelOut{
      from{opacity:1;transform:translate(-50%,-50%) scale(1)}
      to{opacity:0;transform:translate(-50%,-47%) scale(.985)}
    }
    @keyframes previewIn{
      from{opacity:0;transform:translateY(12px)}
      to{opacity:1;transform:translateY(0)}
    }
    @keyframes previewOut{
      from{opacity:1;transform:translateY(0)}
      to{opacity:0;transform:translateY(12px)}
    }
    @keyframes scrollCuePulse{
      0%,100%{opacity:.35}
      50%{opacity:1}
    }
    @keyframes scrollCueNudgeUp{
      0%,100%{transform:translateY(0)}
      50%{transform:translateY(-3px)}
    }
    @keyframes scrollCueNudgeDown{
      0%,100%{transform:translateY(0)}
      50%{transform:translateY(3px)}
    }

    body.animations-off *,
    body.animations-off *::before,
    body.animations-off *::after{
      animation:none !important;
      transition:none !important;
      scroll-behavior:auto !important;
    }
    @media (max-width:1200px){
      .map-topbar{left:12px;right:12px}
      .search-panel{left:0;right:0}
    }
    @media (max-width:980px){
      :root{
        --sitebar-height:52px;
        --mapbar-height:56px;
      }
      .map-topbar{left:12px;right:12px}
      .search-panel{left:0;right:0}
      .map-topbar-row{
        width:100%;
        max-width:none;
        flex-wrap:nowrap;
        min-height:var(--mapbar-height);
      }
      .map-topbar-row .search-input{
        position:static;
        left:auto;
        transform:none;
        width:auto;
        max-width:none;
        min-width:0;
        flex:1 1 auto;
        order:0;
      }
      .top-actions{
        order:0;
        margin-left:auto;
        width:auto;
        flex:0 0 auto;
      }
      .map-topbar.dbus-open{transform:none}
      .top-actions.dbus-open,
      body.side-panel-resizing .top-actions.dbus-open{transform:none}
      .watermark.dbus-open{transform:none}
      #btnSettings{width:44px;justify-content:center}
      .results{max-height:50vh}
      #dbusPanel{
        top:var(--site-header-h);
        left:0;
        right:0;
        transform:none;
        width:100%;
        max-width:none;
        height:calc(100vh - var(--site-header-h));
        max-height:calc(100vh - var(--site-header-h));
      }
      #settingsPanel{
        top:var(--site-header-h);
        left:0;
        right:0;
        transform:none;
        width:100%;
        max-width:none;
        height:calc(100vh - var(--site-header-h));
        max-height:calc(100vh - var(--site-header-h));
      }
      .line-preview-wrap{
        left:0;
        right:0;
        top:calc(var(--header-stack-h) + 18px);
        bottom:auto;
        transform:none;
        padding-top:0;
      }
      .line-preview-wrap.with-side-panel{right:0}
      .line-preview{
        margin:8px auto 10px;
        width:max-content;
        max-width:min(760px,94vw);
      }
      #dbusPanel .dbus-routes-box{
        flex:1 1 auto;
        min-height:170px;
        max-height:none;
      }
      .side-panel-resizer{display:none}
      #searchPanel.search-panel-modal{
        left:0;
        right:0;
        transform:none;
        width:auto;
        max-width:none;
      }
      .dbus-header{flex-wrap:wrap;align-items:flex-start}
      .dbus-mode-group{width:100%;flex-wrap:wrap;justify-content:flex-start}
      .dbus-modes{flex-wrap:wrap}
      .dbus-mode-btn{padding:6px 12px;font-size:12px}
      .dbus-footer{flex-wrap:wrap}
    }
    @media (max-width:700px){
      .dbus-panel,.dbus-stop-panel{border-radius:16px}
      #dbusPanel{border-radius:0}
      .dbus-header{gap:8px;font-size:14px}
      .dbus-header .dbus-title{font-size:18px}
      .dbus-grid{grid-template-columns:repeat(auto-fill,72px)}
      .dbus-double{grid-template-columns:1fr}
      .dbus-item{flex-wrap:wrap;gap:8px}
      .dbus-item .badge{width:64px;height:28px;font-size:14px}
      .dbus-route-logo{width:38px;height:22px}
      .line-preview{padding:8px 10px;margin:8px auto 10px}
      .line-preview .dbus-badge{
        width:64px;
        min-width:64px;
        height:28px;
        padding:0 6px;
        font-size:16px;
      }
      .line-preview .network-chip-express{width:96px;min-width:96px}
      .line-preview-route{font-size:13px}
      .stop .name{font-size:11px;max-width:100%}
      .watermark img{width:150px}
    }
    @media (max-width:520px){
      :root{
        --topbar-top:0px;
        --sitebar-height:52px;
        --mapbar-height:56px;
        --topbar-gap:8px;
      }
      .map-topbar{left:8px;right:8px}
      .search-panel{left:0;right:0}
      .map-topbar{padding:0 8px;border-radius:12px}
      .map-topbar-row{gap:6px}
      .btn{padding:10px 12px;font-size:13px}
      .search-input{padding:10px 12px;font-size:14px}
      .dbus-panel{padding:10px 12px}
      #dbusPanel{padding:0}
      .dbus-footer{padding:8px 10px}
      .dbus-group-label{font-size:10px}
      .dbus-switch{padding:3px 6px}
      .dbus-switch-label{font-size:11px}
      .dbus-route-logo{width:34px;height:20px}
      .results{max-height:55vh}
    }
    @media (max-height:700px){
      .dbus-panel,.dbus-stop-panel{height:92vh}
    }

    .analysis-hud{
      position:fixed; right:8px; bottom:6px; z-index:1500;
      color:#ffffff; font-size:5px; font-weight:600; letter-spacing:.02em;
      background:rgba(11,17,24,0.6); border:1px solid rgba(255,255,255,0.05);
      border-radius:6px; padding:2px 4px; user-select:none; pointer-events:none;
    }

  </style>
  
</head>
<body>
  <div id="map"></div>

  <script src="config/config.js"></script>
  <script src="config/shared-header.js"></script>

  <div class="map-topbar" id="topBar">
    <div class="map-topbar-row">
      <input id="search" class="search-input" type="search" placeholder="Rechercher..." autocomplete="off" aria-label="Recherche"/>
      <div class="top-actions">
        <button id="btnSaeivPanel" class="btn icon-btn" type="button" aria-expanded="false" aria-label="Ecran SAEIV" title="Ecran SAEIV">
          <svg class="saeiv-panel-icon" viewBox="0 0 24 24" aria-hidden="true">
            <rect x="3" y="4" width="18" height="12" rx="2" ry="2"></rect>
            <path d="M12 16v4"></path>
            <path d="M8 20h8"></path>
          </svg>
        </button>
        <button id="btnAudioPanel" class="btn icon-btn" type="button" aria-expanded="false" aria-label="Système d'annonces sonores bus" title="Système d'annonces sonores bus">
          <svg class="audio-panel-icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M11 5 6 9H3v6h3l5 4V5z"></path>
            <path d="M15 9a5 5 0 0 1 0 6"></path>
            <path d="M18 6a9 9 0 0 1 0 12"></path>
          </svg>
        </button>
        <button id="btnDbus" class="btn icon-btn" type="button" aria-expanded="false" aria-label="Lignes Dbus World" title="Lignes Dbus World">
          <img id="btnDbusLogo" class="dbus-icon-logo" src="map_files/0.1.5a/Overlays/bus_logo_idfm.png" alt="" aria-hidden="true"/>
        </button>
        <button id="btnSettings" class="btn icon-btn" type="button" aria-expanded="false" aria-label="Parametres" title="Parametres">
          <svg class="settings-icon" viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.7 1.7 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06A1.7 1.7 0 0 0 15 19.4a1.7 1.7 0 0 0-1 .6 1.7 1.7 0 0 0-.4 1.1V21a2 2 0 1 1-4 0v-.1a1.7 1.7 0 0 0-.4-1.1 1.7 1.7 0 0 0-1-.6 1.7 1.7 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.7 1.7 0 0 0 4.6 15a1.7 1.7 0 0 0-.6-1 1.7 1.7 0 0 0-1.1-.4H2.8a2 2 0 1 1 0-4h.1a1.7 1.7 0 0 0 1.1-.4 1.7 1.7 0 0 0 .6-1 1.7 1.7 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.7 1.7 0 0 0 9 4.6a1.7 1.7 0 0 0 1-.6 1.7 1.7 0 0 0 .4-1.1V2.8a2 2 0 1 1 4 0v.1a1.7 1.7 0 0 0 .4 1.1 1.7 1.7 0 0 0 1 .6 1.7 1.7 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.7 1.7 0 0 0 19.4 9a1.7 1.7 0 0 0 .6 1 1.7 1.7 0 0 0 1.1.4h.1a2 2 0 1 1 0 4h-.1a1.7 1.7 0 0 0-1.1.4 1.7 1.7 0 0 0-.6 1z"></path>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <div class="search-panel">
    <div id="dbusDepartIndicatorWrap" class="dbus-depart-indicator-wrap" hidden>
      <div class="dbus-depart-indicator" role="status" aria-live="polite">
        <span id="dbusDepartIndicatorLabel"></span>
        <button type="button" class="dbus-depart-close" id="dbusDepartIndicatorClose" aria-label="Désactiver">&times;</button>
      </div>
    </div>
    
    <div id="selectedChip" class="selected-chip"></div>

    <div id="searchPanel" class="dbus-panel search-panel-modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="searchPanelTitle">
      <div class="dbus-header">
        <div class="dbus-title" id="searchPanelTitle">Recherche</div>
        <button type="button" class="line-preview-close dbus-close" id="searchPanelClose" aria-label="Fermer">&times;</button>
      </div>
      <div class="dbus-content">
        <div id="results" class="results results-panel" hidden></div>
      </div>
      <div class="dbus-footer">
        <span class="dbus-group-label" id="searchFilterLabel">Filtres</span>
        <div id="searchFilters"></div>
      </div>
    </div>

    <div id="dbusPanel" class="dbus-panel">
      <div class="side-panel-resizer" data-panel-resizer aria-hidden="true"></div>
      <div class="dbus-header">
        <div class="dbus-title" id="dbusPanelTitle">Lignes Dbus World</div>
        <a
          class="line-preview-link dbus-world-link"
          id="dbusWorldLink"
          data-offsite-key="dbus_world"
          href="#"
          target="_blank"
          rel="noopener"
          aria-label="Ouvrir le lien"
          title="Ouvrir le lien"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
          </svg>
        </a>
        <button type="button" class="line-preview-close dbus-close" id="dbusPanelClose" aria-label="Fermer">&times;</button>
      </div>
      <div class="dbus-layout">
        <div class="dbus-box dbus-lines-box">
          <div class="dbus-box-title" id="dbusLinesTitle">Lignes</div>
          <div class="dbus-content">
            <div id="dbusList" class="dbus-list"></div>
            <div id="dbusDepartActions" class="dbus-depart-actions" hidden>
              <button type="button" id="dbusDepartMapBtn" class="dbus-depart-map-btn"></button>
            </div>
            <div id="dbusDepartList" class="dbus-list"></div>
          </div>
        </div>
        <div class="dbus-box dbus-routes-box" id="dbusRoutesBox">
          <div class="dbus-box-title" id="dbusRoutesTitle">
            <span class="dbus-box-title-label" id="dbusRoutesTitleLabel">Liste des routes</span>
            <button type="button" class="dbus-box-clear" id="dbusRoutesClear" aria-label="Désélectionner" hidden>&times;</button>
          </div>
          <div class="dbus-content">
            <div id="dbusRoutesList" class="dbus-list"></div>
          </div>
        </div>
        <div class="dbus-footer">
          <div class="dbus-footer-row">
            <span class="dbus-group-label" id="dbusFilterLabel">Filtres</span>
            <div class="dbus-filters">
              <label class="dbus-switch">
                <span class="dbus-switch-label" id="dbusSchoolLabel">Scolaires</span>
                <input type="checkbox" id="dbusSchoolToggle">
              </label>
              <label class="dbus-switch">
                <span class="dbus-switch-label" id="dbusFictiveLabel">Fictives</span>
                <input type="checkbox" id="dbusFictiveToggle">
              </label>
            </div>
          </div>
          <div class="dbus-footer-row">
            <span class="dbus-group-label" id="dbusSortLabel">Trier par (Lignes)</span>
            <div class="dbus-modes dbus-sort-modes" id="dbusSortModes" role="tablist" aria-label="Trier par">
              <button type="button" class="dbus-mode-btn active" data-mode="lines" aria-pressed="true">Catégorie</button>
              <button type="button" class="dbus-mode-btn" data-mode="length" aria-pressed="false">Longueur</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="settingsPanel" class="dbus-panel" aria-hidden="true" aria-labelledby="settingsPanelTitle">
      <div class="side-panel-resizer" data-panel-resizer aria-hidden="true"></div>
      <div class="dbus-header">
        <div class="dbus-title" id="settingsPanelTitle">Parametres</div>
        <button type="button" class="line-preview-close dbus-close" id="settingsPanelClose" aria-label="Fermer">&times;</button>
      </div>
      <div class="dbus-content">
        <div class="settings-category">
          <h3 class="settings-group-title" id="settingsWebCategoryTitle">PAGE WEB</h3>
          <section class="settings-sec">
            <h4 class="settings-title" id="settingsAnimationsTitle">General</h4>
            <div class="dbus-filters">
              <label class="dbus-switch">
                <span class="dbus-switch-label" id="settingsAnimationsLabel">Animations des menus</span>
                <input type="checkbox" id="settingsAnimationsToggle" checked>
              </label>
              <label class="dbus-switch" id="settingsSaeivPanelRow" hidden>
                <span class="dbus-switch-label" id="settingsSaeivPanelLabel">Ecran SAEIV</span>
                <span class="lang-toggle-badge" id="settingsSaeivPanelBadge">En développement</span>
                <input type="checkbox" id="settingsSaeivPanelToggle">
              </label>
              <label class="dbus-switch" id="settingsAudioPanelRow" hidden>
                <span class="dbus-switch-label" id="settingsAudioPanelLabel">Système d'annonces sonores bus</span>
                <span class="lang-toggle-badge" id="settingsAudioPanelBadge">Expérimental</span>
                <input type="checkbox" id="settingsAudioPanelToggle">
              </label>
              <label class="dbus-switch" id="settingsTranslateStopsRow">
                <span class="dbus-switch-label" id="settingsTranslateStopsLabel">Traduire les arrêts</span>
                <input type="checkbox" id="settingsTranslateStopsToggle">
              </label>
            </div>
          </section>
          <section class="settings-sec" id="settingsMapVersionSection" hidden>
            <h4 class="settings-title" id="settingsMapVersionTitle">Version de la carte</h4>
            <div class="settings-map-version-row">
              <select id="settingsMapVersionSelect" class="settings-map-version-select"></select>
            </div>
          </section>
        </div>
        <div class="settings-category">
          <h3 class="settings-group-title" id="settingsDbusCategoryTitle">PANNEAU DE LIGNES DBUS</h3>
          <section class="settings-sec">
            <h4 class="settings-title" id="settingsCenteringTitle">General</h4>
            <div class="dbus-filters">
              <label class="dbus-switch">
                <span class="dbus-switch-label" id="settingsCenterLineLabel">Centrer sur la ligne sélectionnée</span>
                <input type="checkbox" id="settingsCenterLineToggle" checked>
              </label>
            </div>
          </section>
          <section class="settings-sec">
            <h4 class="settings-title" id="settingsNavigationTypeTitle">Type de navigation</h4>
            <div class="dbus-footer-row">
              <div class="dbus-modes dbus-sort-modes" id="settingsNavigationTypeModes" role="tablist" aria-label="Type de navigation">
                <button type="button" class="dbus-mode-btn active" data-nav-type="gps" aria-pressed="true">GPS</button>
                <button type="button" class="dbus-mode-btn" data-nav-type="legacy" aria-pressed="false">Ancien</button>
              </div>
            </div>
          </section>
          <section class="settings-sec">
            <h4 class="settings-title" id="settingsPreviewLayoutTitle">Aperçu de ligne</h4>
            <div class="dbus-footer-row">
              <div class="dbus-modes dbus-sort-modes" id="settingsPreviewLayoutModes" role="tablist" aria-label="Orientation de l'aperçu de ligne">
                <button type="button" class="dbus-mode-btn active" data-preview-layout="vertical" aria-pressed="true">Vertical</button>
                <button type="button" class="dbus-mode-btn" data-preview-layout="horizontal" aria-pressed="false">Horizontal</button>
              </div>
            </div>
          </section>
        </div>
        <div class="settings-legend" id="settingsLeafletLegend" aria-labelledby="settingsLeafletLegendTitle">
          <h3 class="settings-group-title" id="settingsLeafletLegendTitle">Légende</h3>
          <div class="settings-legend-list">
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="overlay_monument.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendMonumentLabel">Lieux emblématiques</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="overlay_centrecom.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendMallLabel">Centres commerciaux</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="service_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendRepairLabel">Ateliers de réparation</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="recruitment_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendAgencyLabel">Agences de recrutement</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="dealer_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendDealerLabel">Concessionnaires</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="garage_large_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendGarageLabel">Garages</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="gas_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendGasLabel">Station service</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="bus_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendBusStationLabel">Gare routière</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="border_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendBorderLabel">Contrôle d'identité</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="toll_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendTollLabel">Péage</span>
            </div>
            <div class="settings-legend-item">
              <img class="settings-legend-icon" data-overlay-src="parking_ico.png" alt="" aria-hidden="true"/>
              <span class="settings-legend-label" id="settingsLegendParkingLabel">Parking</span>
            </div>
            <div class="settings-legend-item settings-legend-item-toggle">
              <div class="settings-legend-item-main">
                <img class="settings-legend-icon" data-overlay-src="bus_logo_idfm.png" alt="" aria-hidden="true"/>
                <span class="settings-legend-label" id="settingsLegendBusStopsLabel">Arrêts de bus</span>
                <span class="lang-toggle-badge settings-legend-exp" id="settingsLegendBusStopsBadge">Expérimental</span>
              </div>
              <label class="dbus-switch settings-legend-switch">
                <span class="dbus-switch-label" id="settingsLegendBusStopsToggleLabel">Afficher</span>
                <input type="checkbox" id="settingsBusStopsToggle">
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="dbusStopPanel" class="dbus-stop-panel">
    <div class="dbus-header">
      <div class="dbus-title" id="dbusStopTitle">Arrêt</div>
      <button type="button" class="line-preview-close dbus-close" id="dbusStopClose" aria-label="Fermer">&times;</button>
    </div>
    <div class="dbus-stop-content">
      <div id="dbusStopList" class="dbus-list"></div>
    </div>
  </div>

  <div id="linePreviewWrap" class="line-preview-wrap" style="display:none">
    <div class="line-preview" id="linePreview">
      <div class="line-preview-info">
        <div class="line-preview-info-header">
          <div class="dbus-badge" id="lpBadge">?</div>
          <div class="line-preview-info-text">
            <div class="line-preview-route" id="lpRouteTitle">-</div>
            <div class="line-preview-meta" id="lpRouteMeta">-</div>
          </div>
          <div class="line-preview-actions">
            <a class="line-preview-link" id="lpLink" href="" target="_blank" rel="noopener" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
              </svg>
            </a>
            <button type="button" class="line-preview-close" id="lpClose" aria-label="Fermer">X</button>
          </div>
        </div>
      </div>
      <div class="line-preview-stops">
        <div class="line-preview-scroll-cue top" role="button" tabindex="0" aria-label="Monter d'un arrêt"><span>▲</span></div>
        <div class="transit-scroll">
          <div class="transit" id="lpTransit"></div>
        </div>
        <div class="line-preview-scroll-cue bottom" role="button" tabindex="0" aria-label="Descendre d'un arrêt"><span>▼</span></div>
      </div>
    </div>
  </div>
  <div id="lpAudioPanel" class="line-preview-audio-panel" role="dialog" aria-hidden="true" aria-label="Système d'annonces sonores bus">
    <div class="line-preview-audio-head" id="lpAudioPanelHead">
      <div class="line-preview-audio-title-row">
        <div class="line-preview-audio-title" id="lpAudioPanelTitle">Système d'annonces sonores bus</div>
        <span class="lang-toggle-badge line-preview-audio-exp-badge">EXPERIMENTAL</span>
      </div>
      <button type="button" class="line-preview-close" id="lpAudioPanelClose" aria-label="Fermer">X</button>
    </div>
    <div class="line-preview-audio-body">
      <div class="line-preview-audio-main" id="lpAudioMainContent">
        <div class="line-preview-audio-route line-preview-audio-card" id="lpAudioRouteBlock">
          <div class="line-preview-audio-section-head">
            <div class="line-preview-audio-section-title">Annonces de Ligne</div>
            <div class="line-preview-audio-style-wrap line-preview-audio-head-select">
              <select id="lpAudioStyleSelect"></select>
              <div class="line-preview-audio-style-byline" id="lpAudioStyleByline" hidden></div>
            </div>
          </div>
          <div class="line-preview-audio-now-kicker">Prochain Arrêt :</div>
          <div class="line-preview-audio-now-row">
            <button type="button" class="line-preview-audio-btn line-preview-audio-nav-btn" id="lpAudioPrevBtn">&lt;</button>
            <div class="line-preview-audio-now" id="lpAudioNowStop">-</div>
            <button type="button" class="line-preview-audio-btn line-preview-audio-nav-btn" id="lpAudioNextBtn">&gt;</button>
          </div>
          <div class="line-preview-audio-actions">
            <button type="button" class="line-preview-audio-btn" id="lpAudioCurrentBtn">Annonce Arrêt</button>
            <button type="button" class="line-preview-audio-btn" id="lpAudioTerminusBtn">Annonce Destination</button>
          </div>
        </div>
        <div class="line-preview-audio-route-empty line-preview-audio-card line-preview-audio-stop-empty" id="lpAudioNoLineHint" hidden>Aucune ligne sélectionnée</div>
        <div class="line-preview-audio-global line-preview-audio-card" id="lpAudioGlobalBlock">
          <div class="line-preview-audio-section-head">
            <div class="line-preview-audio-section-title">Annonces Globales</div>
            <div class="line-preview-audio-global-wrap line-preview-audio-head-select">
              <select id="lpAudioGlobalFolderSelect"></select>
              <div class="line-preview-audio-global-byline" id="lpAudioGlobalByline" hidden></div>
            </div>
          </div>
          <div class="line-preview-audio-global-buttons" id="lpAudioGlobalButtons"></div>
        </div>
        <div class="line-preview-audio-volume line-preview-audio-card">
          <div class="line-preview-audio-section-title">Volume</div>
          <div class="line-preview-audio-volume-row">
            <label class="line-preview-audio-volume-label" id="lpAudioVolumeLabel" for="lpAudioVolumeRange">Volume</label>
            <input id="lpAudioVolumeRange" type="range" min="0" max="200" step="1" value="100" />
            <button type="button" class="line-preview-audio-btn line-preview-audio-volume-stop" id="lpAudioStopBtn">Stop</button>
          </div>
        </div>
      </div>
      <div class="line-preview-audio-extension-missing" id="lpAudioExtensionMissing" hidden>
        <div class="line-preview-audio-extension-missing-title" id="lpAudioExtMissingTitle">Raccourcis clavier indisponibles</div>
        <div class="line-preview-audio-extension-missing-text" id="lpAudioExtMissingText">Les annonces sonores restent utilisables dans ce panneau. Les raccourcis clavier nécessitent l'extension Chrome.</div>
        <div class="line-preview-audio-extension-missing-note">
          <span class="line-preview-audio-extension-missing-text" id="lpAudioExtUnsupportedHint" hidden>Ce navigateur ne supporte pas les extensions Chrome, veuillez utiliser un navigateur compatible pour utiliser les raccourcis clavier.</span>
        </div>
        <div class="line-preview-audio-extension-missing-actions">
          <button type="button" class="line-preview-audio-extension-link line-preview-audio-extension-btn" id="lpAudioExtHowToBtn" hidden>Comment faire ?</button>
        </div>
      </div>
      <dialog class="line-preview-audio-extension-dialog" id="lpAudioExtGuideDialog" aria-label="Guide d'installation extension audio">
        <div class="line-preview-audio-extension-dialog-head">
          <div class="line-preview-audio-extension-dialog-title">Activer les raccourcis clavier</div>
          <button type="button" class="line-preview-close" id="lpAudioExtGuideClose" aria-label="Fermer">X</button>
        </div>
        <div class="line-preview-audio-extension-dialog-body">
          <div>Téléchargez et installez l'extension pour utiliser les annonces avec les raccourcis clavier.</div>
          <div class="line-preview-audio-extension-dialog-links">
            <a class="line-preview-audio-extension-link" id="lpAudioExtInstallLink" href="#" target="_blank" rel="noopener">Télécharger l'extension</a>
          </div>
          <ol class="line-preview-audio-extension-guide">
          <li>Décompressez le fichier <span class="line-preview-audio-code-badge">.zip</span> que vous avez téléchargé</li>
          <li>Placez le dossier <span class="line-preview-audio-code-badge">idf_annonces_sonores_extension</span> dans un emplacement où vous serez sûr qu'il ne sera pas déplacé ou de le supprimé</li>
          <li>Ouvrez la page <span class="line-preview-audio-code-badge">chrome://extensions/</span></li>
          <li>Cliquez sur le bouton <span class="line-preview-audio-code-badge">Charger l’extension non empaquetée</span> en haut à gauche</li>
          <li>Sélectionnez le dossier extrait <span class="line-preview-audio-code-badge">idf_annonces_sonores_extension</span>, ouvrez le et cliquez sur le bouton <span class="line-preview-audio-code-badge">Sélectionner un dossier</span></li>
          <li>
          Vous devez maintenant configurer vos raccourcis clavier. Rendez-vous sur 
          <span class="line-preview-audio-code-badge">chrome://extensions/shortcuts</span> 
          (aucun raccourci n’est défini par défaut).  
          ATTENTION : pour chaque raccourci, veillez à sélectionner, à droite de l’icône crayon, l’option 
          <span class="line-preview-audio-code-badge">Raccourcis globaux</span> dans le menu déroulant.
          </li>
          <li>Revenez ensuite ici et rechargez la page</li>
          </ol>
        </div>
      </dialog>
    </div>
  </div>
  <div class="watermark">
    <img id="watermarkLogo" src="" alt="IDF Logo">
    <div id="watermarkVersionLabel" class="watermark-version"></div>
  </div>

  <!-- <div id="analysisHUD" class="analysis-hud"></div>*/ -->

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="config/translations.js"></script>
  <script src="config/site-nav.js"></script>

  <script>

  const LINE_STYLES = {
    "24":         ["#ab5798", "#FFFFFF","https://www.bonjour-ratp.fr/lignes-bus/ligne-24/","1"],
    "63":         ["#cdc74f", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-63/","1"],
    "109":        ["#cdc74f", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-109/","1"],
    "112":        ["#e69459", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-112/","1"],
    "114":        ["#8cc299", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-114/","1"],
    "121":        ["#d63e34", "#FFFFFF","https://www.bonjour-ratp.fr/lignes-bus/ligne-121/","1"],
    "124":        ["#e6a4b2", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-124/","1"],
    "210":        ["#fecd08", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-210/","1"],
    "221":        ["#e7a5b3", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-221/","1"],
    "303":        ["#99974a", "#FFFFFF","https://www.bonjour-ratp.fr/lignes-bus/ligne-303/","1"],
    "325":        ["#9ad1dc", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-325/","1"],
    "351":        ["#d7b152", "#221f20","https://www.bonjour-ratp.fr/lignes-bus/ligne-351/","1"],
    "FLIXBUS":    ["#a7d245", "#FFFFFF","https://www.flixbus.fr/","9"],
    "N11":        ["#e9682a", "#221f20","https://www.ratp.fr/plans-lignes/noctilien/n11","1,2"],
    "N23":        ["#d09835", "#221f20","https://www.ratp.fr/plans-lignes/noctilien/n23","1,2"],
    "N33":        ["#e9682a", "#221f20","https://www.ratp.fr/plans-lignes/noctilien/n33","1,2"],
    "Titus 1":    ["#e63b20", "#FFFFFF","https://www.rosnysousbois.fr/mobilites/le-titus/","1"],
    "Titus 2":    ["#49713e", "#FFFFFF","https://www.rosnysousbois.fr/mobilites/le-titus/","1"],
    "Fictives":   ["#cfcfcf", "#221f20","","0"],
    "Autocar":    ["#cfcfcf", "#221f20","","0"],
    "Scolaire":   ["#f0c748", "#221f20","","0"],
    "Express":    ["#6fb2e1", "#FFFFFF","","0"],
    "Express 75": ["#6fb2e1", "#FFFFFF","","0"],
    "Express 77": ["#6fb2e1", "#FFFFFF","","0"],
    "Express 93": ["#6fb2e1", "#FFFFFF","","0"],
    "Express 94": ["#6fb2e1", "#FFFFFF","","0"],
  };

  const I18N = window.I18N || {};
  const I18N_COMPAT_PATCH = window.I18N_COMPAT_PATCH || {};
  Object.entries(I18N_COMPAT_PATCH).forEach(([code, patch]) => {
    if (!I18N[code]) return;
    Object.entries(patch).forEach(([key, value]) => {
      const current = I18N[code][key];
      if (typeof current !== "string" || !current.trim()) {
        I18N[code][key] = value;
        return;
      }
      if (current === key) {
        I18N[code][key] = value;
        return;
      }
      if (code === "en") return;
      const enValue = I18N.en && typeof I18N.en[key] === "string" ? I18N.en[key] : "";
      if (enValue && current === enValue) {
        I18N[code][key] = value;
      }
    });
  });
  const LANG_OPTIONS = [
    { code: "fr", label: "Français", flagSrc: "https://flagcdn.com/w40/fr.png" },
    { code: "en", label: "English", flagSrc: "https://flagcdn.com/w40/gb.png" },
    { code: "es", label: "Español", flagSrc: "https://flagcdn.com/w40/es.png" },
    { code: "de", label: "Deutsch", flagSrc: "https://flagcdn.com/w40/de.png" },
    { code: "pl", label: "Polski", flagSrc: "https://flagcdn.com/w40/pl.png" },
    { code: "pt", label: "Português", flagSrc: "https://flagcdn.com/w40/pt.png" },
    { code: "nl", label: "Nederlands", flagSrc: "https://flagcdn.com/w40/nl.png" },
    { code: "it", label: "Italiano", flagSrc: "https://flagcdn.com/w40/it.png" },
    { code: "ru", label: "Русский", flagSrc: "https://flagcdn.com/w40/ru.png" },
    { code: "zh", label: "中文", flagSrc: "https://flagcdn.com/w40/cn.png" },
    { code: "ko", label: "한국어", flagSrc: "https://flagcdn.com/w40/kr.png" },
    { code: "ja", label: "日本語", flagSrc: "https://flagcdn.com/w40/jp.png" }
  ];
  const LANG_META = Object.fromEntries(LANG_OPTIONS.map(entry => [entry.code, entry]));
  const SUPPORTED = new Set(LANG_OPTIONS.map(entry => entry.code));
  function detectInitialLang(){
    const qs = new URLSearchParams(location.search);
    const fromURL = (qs.get("lang")||"").toLowerCase();
    if (SUPPORTED.has(fromURL)) return fromURL;
    const stored = localStorage.getItem("idf_lang");
    if (SUPPORTED.has(stored)) return stored;
    const nav = (navigator.language||"fr").slice(0,2).toLowerCase();
    return SUPPORTED.has(nav) ? nav : "fr";
  }
  let LANG = detectInitialLang();
  const STOP_TYPE_TRANSLATION_KEY = "idf_translate_stop_types";
  const UI_ANIMATIONS_KEY = "idf_ui_animations";
  const SAEIV_PANEL_BUTTON_KEY = "idf_saeiv_panel_button_enabled";
  const AUDIO_PANEL_BUTTON_KEY = "idf_audio_panel_button_enabled";
  const SAEIV_SETTINGS_FEATURE_ALLOWED = (() => {
    const qs = new URLSearchParams(location.search);
    return qs.has("dev");
  })();
  const LINE_PREVIEW_LAYOUT_KEY = "idf_line_preview_layout";
  const CENTER_ON_LINE_SELECT_KEY = "idf_center_on_line_select";
  const DBUS_STOP_ICONS_KEY = "idf_dbus_stop_icons";
  const DBUS_NAVIGATION_TYPE_KEY = "idf_dbus_navigation_type";
  const LINE_PREVIEW_LAYOUTS = { VERTICAL: "vertical", HORIZONTAL: "horizontal" };
  const DBUS_NAVIGATION_TYPES = { GPS: "gps", LEGACY: "legacy" };
  let TRANSLATE_STOP_TYPES = (() => {
    const stored = localStorage.getItem(STOP_TYPE_TRANSLATION_KEY);
    return stored === "1" || stored === "true";
  })();
  let UI_ANIMATIONS = (() => {
    const stored = localStorage.getItem(UI_ANIMATIONS_KEY);
    return !(stored === "0" || stored === "false");
  })();
  let SAEIV_PANEL_BUTTON_ENABLED = (() => {
    const stored = localStorage.getItem(SAEIV_PANEL_BUTTON_KEY);
    return stored === "1" || stored === "true";
  })();
  let AUDIO_PANEL_BUTTON_ENABLED = (() => {
    const stored = localStorage.getItem(AUDIO_PANEL_BUTTON_KEY);
    return stored === "1" || stored === "true";
  })();
  let LINE_PREVIEW_LAYOUT = (() => {
    const stored = String(localStorage.getItem(LINE_PREVIEW_LAYOUT_KEY) || "").toLowerCase();
    return (stored === LINE_PREVIEW_LAYOUTS.HORIZONTAL) ? LINE_PREVIEW_LAYOUTS.HORIZONTAL : LINE_PREVIEW_LAYOUTS.VERTICAL;
  })();
  let CENTER_ON_LINE_SELECT = (() => {
    const stored = localStorage.getItem(CENTER_ON_LINE_SELECT_KEY);
    return !(stored === "0" || stored === "false");
  })();
  let DBUS_STOP_ICONS_ENABLED = (() => {
    const stored = localStorage.getItem(DBUS_STOP_ICONS_KEY);
    return stored === "1" || stored === "true";
  })();
  let DBUS_NAVIGATION_TYPE = (() => {
    const stored = String(localStorage.getItem(DBUS_NAVIGATION_TYPE_KEY) || "").toLowerCase().trim();
    return stored === DBUS_NAVIGATION_TYPES.LEGACY ? DBUS_NAVIGATION_TYPES.LEGACY : DBUS_NAVIGATION_TYPES.GPS;
  })();
  var currentSelectedKey = "";
  var currentSelectedLineUid = "";
  var dbusRoutesClosedByPanel = false;
  function t(key){ return (I18N[LANG] && I18N[LANG][key]) || (I18N.fr[key]||key); }
  const SITE_NAV_TREE = Array.isArray(window.SITE_NAV_TREE) && window.SITE_NAV_TREE.length
    ? window.SITE_NAV_TREE
    : [
        {
          labelKey: "nav_group_maps",
          items: [
            { href: "./", labelKey: "nav_page_index" },
            { href: "test.html", labelKey: "nav_page_test" }
          ]
        }
      ];
  function closeSiteNavMenus(){
    window.sharedHeader?.closeSiteNavMenus?.();
  }
  function renderSiteNav(){
    window.sharedHeader?.renderSiteNav?.();
  }
  const STOP_PREFIXES = [
    { re: /^centre\s+de\s+protection\s+maternelle\s+et\s+infantile\b/i, key: "stop_centre_pmi" },
    { re: /^centre\s+aquanautique\b/i, key: "stop_centre_aquanautique" },
    { re: /^centre\s+aquatique\b/i, key: "stop_centre_aquatique" },
    { re: /^centre\s+commercial\b/i, key: "stop_centre_commercial" },
    { re: /^centre\s+municipal\b/i, key: "stop_centre_municipal" },
    { re: /^march[ée]\s+international\b/i, key: "stop_marche_international" },
    { re: /^parc\s+floral\b/i, key: "stop_parc_floral" },
    { re: /^plateau\b/i, key: "stop_plateau" },
    { re: /^h(?:ô|o)tel\s+de\s+ville\b/i, key: "stop_hotel_de_ville" },
    { re: /^(?:é|e)cole\s+(?:élémentaire|elementaire)\b/i, key: "stop_ecole_elementaire" },
    { re: /^(?:é|e)l[ée]mentaire\b/i, key: "stop_ecole" },
    { re: /^(?:é|e)cole\s+primaire\b/i, key: "stop_ecole_primaire" },
    { re: /^(?:é|e)cole\s+maternelle\s+publique\b/i, key: "stop_ecole_maternelle_publique" },
    { re: /^(?:é|e)cole\s+maternelle\b/i, key: "stop_ecole_maternelle" },
    { re: /^cit[ée]\s+scolaire\b/i, key: "stop_cite_scolaire" },
    { re: /^(?:é|e)cole\b/i, key: "stop_ecole" },
    { re: /^coll[èe]ge\b/i, key: "stop_college" },
    { re: /^lyc[ée]e\s+polyvalent\b/i, key: "stop_lycee_polyvalent" },
    { re: /^lyc[ée]e\b/i, key: "stop_lycee" },
    { re: /^h[ôo]pital\b/i, key: "stop_hopital" },
    { re: /^(?:é|e)glise\b/i, key: "stop_eglise" },
    { re: /^square\b/i, key: "stop_square" },
    { re: /^all[ée]e\b/i, key: "stop_allee" },
    { re: /^chemin\b/i, key: "stop_chemin" },
    { re: /^tour\b/i, key: "stop_tour" },
    { re: /^ferme\s+p[ée]dagogique\b/i, key: "stop_ferme_pedagogique" },
    { re: /^ferme\b/i, key: "stop_ferme" },
    { re: /^minist[èe]re\s+de\s+l['’]?(?:é|e)conomie\s+et\s+des\s+finances\b/i, key: "stop_ministere_economie_finances" },
    { re: /^minist[èe]re\b/i, key: "stop_ministere" },
    { re: /^(?:é|e)changeur\b/i, key: "stop_echangeur" },
    { re: /^(?:cimetière|cimetiere)\b/i, key: "stop_cimetiere" },
    { re: /^(?:château|chateau)\b/i, key: "stop_chateau" },
    { re: /^gare\b/i, key: "stop_gare" },
    { re: /^piscine\b/i, key: "stop_piscine" },
    { re: /^stade\b/i, key: "stop_stade" },
    { re: /^mairie\b/i, key: "stop_mairie" },
    { re: /^pont\b/i, key: "stop_pont" },
    { re: /^porte\b/i, key: "stop_porte" },
    { re: /^place\b/i, key: "stop_place" },
    { re: /^avenue\b/i, key: "stop_avenue" },
    { re: /^rue\b/i, key: "stop_rue" },
    { re: /^parc\b/i, key: "stop_parc" },
    { re: /^centre\b/i, key: "stop_centre" },
    { re: /^maison\b/i, key: "stop_maison" },
    { re: /^jaune\b/i, key: "color_yellow" },
    { re: /^vert\b/i, key: "color_green" },
    { re: /^verte\b/i, key: "color_green" },
    { re: /^rouge\b/i, key: "color_red" },
    { re: /^bleu/i, key: "color_blue" },
    { re: /^bleue/i, key: "color_blue" },
    { re: /^orange\b/i, key: "color_orange" },
    { re: /^violet\b/i, key: "color_purple" },
    { re: /^violete\b/i, key: "color_purple" },
    { re: /^blanc\b/i, key: "color_white" },
    { re: /^blanche\b/i, key: "color_white" },
    { re: /^noir\b/i, key: "color_black" },
    { re: /^noire\b/i, key: "color_black" },
    { re: /^gris\b/i, key: "color_grey" },
    { re: /^grise\b/i, key: "color_grey" },
  ];
  const POSTFIX_LANGS = new Set(["en"]);
  function stripFrenchJoiners(text){
    let s = String(text || "").trim();
    let prev;
    do {
      prev = s;
      s = s.replace(/^(?:d['’]|de l['’]|de la|du|des|de|l['’]|la|le|les)\s*/i, "").trim();
    } while (s && s !== prev);
    return s;
  }
  function appendPostfix(base, postfix){
    const trimmed = String(base || "").trim();
    if (!trimmed) return postfix;
    const m = trimmed.match(/^(.*?)(\s*\([^)]*\))$/);
    if (m) {
      const main = (m[1] || "").trim();
      if (main) return `${main} ${postfix}${m[2]}`.replace(/\s+/g, " ").trim();
      return `${postfix}${m[2]}`.replace(/\s+/g, " ").trim();
    }
    return `${trimmed} ${postfix}`.replace(/\s+/g, " ").trim();
  }
  function endsWithWord(text, word){
    const t = String(text || "").trim();
    const w = String(word || "").trim();
    if (!t || !w) return false;
    const m = t.match(/^(.*?)(\s*\([^)]*\))$/);
    const core = (m ? m[1] : t).trim();
    const escaped = w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(`\\b${escaped}$`, "i").test(core);
  }
  function startsWithWord(text, word){
    const t = String(text || "").trim();
    const w = String(word || "").trim();
    if (!t || !w) return false;
    const m = t.match(/^(.*?)(\s*\([^)]*\))$/);
    const core = (m ? m[1] : t).trim();
    const escaped = w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(`^${escaped}\\b`, "i").test(core);
  }
  function translateDirectionTokens(text){
    if (!TRANSLATE_STOP_TYPES || LANG === "fr") return text;
    let s = String(text || "");
    const tokens = [
      { re: /\bnord\b/gi, key: "dir_north" },
      { re: /\bsud\b/gi, key: "dir_south" },
      { re: /\best\b/gi, key: "dir_east" },
      { re: /\bouest\b/gi, key: "dir_west" },
    ];
    tokens.forEach(({ re, key }) => { s = s.replace(re, t(key)); });
    return s;
  }
  function translateStopNameSegment(name, depth = 0){
    const raw = String(name || "").trim();
    if (!raw || !TRANSLATE_STOP_TYPES || LANG === "fr") return raw;
    if (depth > 2) return raw;
    for (const { re, key } of STOP_PREFIXES){
      if (re.test(raw)) {
        const translatedPrefix = t(key);
        const remainderRaw = raw.replace(re, "").trim();
        const remainderNoJoin = stripFrenchJoiners(remainderRaw);
        let remainderTranslated = remainderNoJoin ? translateStopNameSegment(remainderNoJoin, depth + 1) : "";
        remainderTranslated = translateDirectionTokens(remainderTranslated);
        if (POSTFIX_LANGS.has(LANG) && remainderTranslated) {
          if (endsWithWord(remainderTranslated, translatedPrefix)) return remainderTranslated;
          return appendPostfix(remainderTranslated, translatedPrefix);
        }
        if (remainderTranslated) {
          if (startsWithWord(remainderTranslated, translatedPrefix)) return remainderTranslated;
          return `${translatedPrefix} ${remainderTranslated}`.replace(/\s+/g, " ").trim();
        }
        return translatedPrefix;
      }
    }
    return raw;
  }
  function translateStopName(raw){
    const name = String(raw || "").trim();
    if (!name || !TRANSLATE_STOP_TYPES || LANG === "fr") return name;
    const parts = name.split(/(\s+[–—/]\s+|\s+-\s+)/);
    if (parts.length > 1) {
      const translated = parts.map(part => {
        if (/^\s*[-–—/]\s*$/.test(part)) return part;
        return translateStopNameSegment(part, 0);
      }).join("");
      return translateDirectionTokens(translated).replace(/\s+/g, " ").trim();
    }
    return translateDirectionTokens(translateStopNameSegment(name, 0)).replace(/\s+/g, " ").trim();
  }
  const I18N_LAYERS = [];
  function registerI18nLayer(layer, updater){
    if (!layer || typeof updater !== "function") return;
    I18N_LAYERS.push({ layer, updater });
  }
  function refreshI18nLayers(){
    I18N_LAYERS.forEach(entry => {
      const layer = entry.layer;
      if (!layer || typeof layer.getPopup !== "function") return;
      if (!layer.getPopup()) return;
      try { entry.updater(); } catch {}
    });
  }
  const SEARCH_CATEGORY_ALL = "ALL";
  const ALL_TYPES = [ "Ville","Monument","Atelier","Agence","Concessionnaire","Entreprise" ];
  let ACTIVE_SEARCH_CATEGORY = SEARCH_CATEGORY_ALL;
  let SEARCH_CATEGORY_COUNTS = Object.fromEntries(ALL_TYPES.map(t => [t, 0]));
  let SEARCH_CATEGORY_TOTAL = 0;
  function searchCategoryLabel(typeKey){
    const map = {
      "Ville": t("villes"),
      "Monument": t("emblematic"),
      "Atelier": t("repair_shops"),
      "Agence": t("agencies"),
      "Concessionnaire": t("dealers"),
      "Entreprise": t("companies")
    };
    return map[typeKey] || typeKey;
  }
  function searchCategoryDisplay(typeKey){
    if (typeKey === SEARCH_CATEGORY_ALL) return t("search_category_all");
    return searchCategoryLabel(typeKey);
  }
  function searchCategoryButtonLabel(typeKey){
    const label = searchCategoryDisplay(typeKey);
    const count = typeKey === SEARCH_CATEGORY_ALL
      ? SEARCH_CATEGORY_TOTAL
      : (SEARCH_CATEGORY_COUNTS[typeKey] ?? 0);
    return `${label} (${count})`;
  }
  function resultsEmptyText(){
    const label = searchCategoryDisplay(ACTIVE_SEARCH_CATEGORY);
    return t("results_empty_category").replace("{category}", label);
  }
  function langLabel(code){
    const meta = LANG_META[code];
    if (meta && meta.label) return meta.label;
    return String(code || "").toUpperCase();
  }
  function formatStopCount(count){
    const key = count === 1 ? "stop_count_singular" : "stop_count_plural";
    return t(key).replace("{count}", count);
  }
  function formatStopDuration(count, durationText, format = "paren"){
    const base = formatStopCount(count);
    if (!durationText) return base;
    if (format === "dash") return `${base} - ${durationText}`;
    return `${base} (${durationText})`;
  }
  const MINUTE_SHORT_LABELS = {
    fr: "min", en: "min", es: "min", de: "min", pl: "min", pt: "min",
    nl: "min", it: "min", ru: "мин", zh: "分", ko: "분", ja: "分"
  };
  function minuteShortLabel(){
    return MINUTE_SHORT_LABELS[LANG] || "min";
  }
  const NIGHT_BUS_LABELS = {
    fr: "Noctilien", en: "Night Bus", es: "Bus nocturno", de: "Nachtbus",
    pl: "Autobus nocny", pt: "Ônibus noturno", nl: "Nachtbus", it: "Bus notturno",
    ru: "Ночной автобус", zh: "夜间巴士", ko: "심야 버스", ja: "深夜バス"
  };
  const SCHOOL_BADGE_LABELS = {
    fr: "Scolaire", en: "School", es: "Escolar", de: "Schule",
    pl: "Szkolna", pt: "Escolar", nl: "School", it: "Scolastica",
    ru: "Школьный", zh: "校车", ko: "스쿨", ja: "スクール"
  };
  const EXPRESS_BADGE_LABELS = {
    fr: "Express", en: "Express", es: "Expres", de: "Express",
    pl: "Express", pt: "Expresso", nl: "Express", it: "Express",
    ru: "Экспресс", zh: "快线", ko: "급행", ja: "急行"
  };
  const FICTIVE_BADGE_LABELS = {
    fr: "Fictive", en: "Fictional", es: "Ficticia", de: "Fiktiv",
    pl: "Fikcyjna", pt: "Ficticia", nl: "Fictief", it: "Fittizia",
    ru: "Фиктивная", zh: "虚构", ko: "가상", ja: "架空"
  };
  const AUTOCAR_BADGE_LABELS = {
    fr: "Autocar", en: "Coach", es: "Autocar", de: "Reisebus",
    pl: "Autokar", pt: "Autocarro", nl: "Touringcar", it: "Pullman",
    ru: "Междугородний автобус", zh: "长途客车", ko: "장거리 버스", ja: "観光バス"
  };
  function localizedLabel(mapObj, fallback = ""){
    return mapObj[LANG] || mapObj.fr || fallback;
  }
  function normalizeBadgeToken(value){
    return String(value || "")
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/\s+/g, "")
      .trim();
  }
  function translatedNightBusLabel(){
    return localizedLabel(NIGHT_BUS_LABELS, t("dbus_sub_noctilien"));
  }
  function translateBadgeToken(value){
    const raw = String(value || "").trim();
    if (!raw) return raw;
    if (/^\d+$/.test(raw) || /^N\d+$/i.test(raw) || /^titus\s*\d+/i.test(raw)) return raw;
    const expressMatch = /^express\b\s*(.*)$/i.exec(raw);
    if (expressMatch) {
      const base = localizedLabel(EXPRESS_BADGE_LABELS, "Express");
      const suffix = String(expressMatch[1] || "").trim();
      return suffix ? `${base} ${suffix}` : base;
    }
    const normalized = normalizeBadgeToken(raw);
    if (normalized.startsWith("scolaire")) return localizedLabel(SCHOOL_BADGE_LABELS, t("dbus_school_toggle"));
    if (normalized.startsWith("fictive")) return localizedLabel(FICTIVE_BADGE_LABELS, t("dbus_fictive_toggle"));
    if (normalized.startsWith("noctilien") || normalized === "busdenuit") return translatedNightBusLabel();
    if (normalized.startsWith("autocar")) return localizedLabel(AUTOCAR_BADGE_LABELS, "Autocar");
    return raw;
  }
  function dbusCategoryTitle(key){
    if (key === "Express") return translateBadgeToken("Express");
    if (key === "urban") return t("dbus_sub_urban");
    if (key === "noctilien") return translatedNightBusLabel();
    if (key === "other_networks") return t("dbus_sub_other_networks");
    if (key === "others") return localizedLabel(AUTOCAR_BADGE_LABELS, "Autocar");
    if (key === "Scolaire") return translateBadgeToken("Scolaire");
    if (key === "Autres") return localizedLabel(AUTOCAR_BADGE_LABELS, "Autocar");
    if (key === "Urbain") return "IDFM";
    if (key === "Noctilien") return translatedNightBusLabel();
    if (key === "FlixBus") return "FlixBus";
    return key;
  }
  function setStopDurationText(el, stopCount, durationText, format){
    if (!el) return;
    el.dataset.stopCount = String(stopCount);
    el.dataset.durationText = String(durationText || "");
    el.dataset.durationFormat = format || "paren";
    el.textContent = formatStopDuration(stopCount, durationText, format);
  }
  function typeFallbackLabel(type){
    if (type === "Agence") return t("recruitment_agency");
    if (type === "Atelier") return t("repair_shop");
    if (type === "Garage") return t("garage");
    return type;
  }
  function setStopTypeTranslation(enabled, { persist = true, apply = true } = {}) {
    TRANSLATE_STOP_TYPES = !!enabled;
    if (persist) {
      localStorage.setItem(STOP_TYPE_TRANSLATION_KEY, TRANSLATE_STOP_TYPES ? "1" : "0");
    }
    if (apply) applyI18N();
  }
  function setUiAnimationsEnabled(enabled, { persist = true } = {}) {
    UI_ANIMATIONS = !!enabled;
    document.body.classList.toggle("animations-off", !UI_ANIMATIONS);
    if (persist) {
      localStorage.setItem(UI_ANIMATIONS_KEY, UI_ANIMATIONS ? "1" : "0");
    }
    const toggle = document.getElementById("settingsAnimationsToggle");
    if (toggle) toggle.checked = UI_ANIMATIONS;
  }
  function isSaeivFeatureAllowed(){
    return SAEIV_SETTINGS_FEATURE_ALLOWED;
  }
  function setSaeivPanelButtonEnabled(enabled, { persist = true, apply = true } = {}) {
    SAEIV_PANEL_BUTTON_ENABLED = !!enabled;
    if (persist) {
      localStorage.setItem(SAEIV_PANEL_BUTTON_KEY, SAEIV_PANEL_BUTTON_ENABLED ? "1" : "0");
    }
    const toggle = document.getElementById("settingsSaeivPanelToggle");
    if (toggle) toggle.checked = isSaeivFeatureAllowed() ? SAEIV_PANEL_BUTTON_ENABLED : false;
    if (apply) {
      if (typeof refreshSaeivTopButtonVisibility === "function") {
        try { refreshSaeivTopButtonVisibility(); } catch {}
      }
      if (typeof updateUiOverlays === "function") {
        try { updateUiOverlays(); } catch {}
      }
    }
  }
  function setAudioPanelButtonEnabled(enabled, { persist = true, apply = true } = {}) {
    AUDIO_PANEL_BUTTON_ENABLED = !!enabled;
    if (persist) {
      localStorage.setItem(AUDIO_PANEL_BUTTON_KEY, AUDIO_PANEL_BUTTON_ENABLED ? "1" : "0");
    }
    const toggle = document.getElementById("settingsAudioPanelToggle");
    if (toggle) toggle.checked = AUDIO_PANEL_BUTTON_ENABLED;
    if (apply) {
      if (typeof refreshLinePreviewAudioTopButtonVisibility === "function") {
        try { refreshLinePreviewAudioTopButtonVisibility({ closePanelOnHide: true }); } catch {}
      }
      if (typeof updateUiOverlays === "function") {
        try { updateUiOverlays(); } catch {}
      }
    }
  }
  function isLinePreviewHorizontal(){
    return LINE_PREVIEW_LAYOUT === LINE_PREVIEW_LAYOUTS.HORIZONTAL;
  }
  function setLinePreviewLayout(layout, { persist = true } = {}) {
    const next = (layout === LINE_PREVIEW_LAYOUTS.HORIZONTAL)
      ? LINE_PREVIEW_LAYOUTS.HORIZONTAL
      : LINE_PREVIEW_LAYOUTS.VERTICAL;
    LINE_PREVIEW_LAYOUT = next;
    document.body.classList.toggle("line-preview-horizontal", isLinePreviewHorizontal());
    if (persist) {
      localStorage.setItem(LINE_PREVIEW_LAYOUT_KEY, LINE_PREVIEW_LAYOUT);
    }
    document.querySelectorAll("#settingsPreviewLayoutModes .dbus-mode-btn[data-preview-layout]").forEach(btn => {
      const active = btn.dataset.previewLayout === LINE_PREVIEW_LAYOUT;
      btn.classList.toggle("active", active);
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
    if (typeof refreshLinePreviewRail === "function") {
      try { refreshLinePreviewRail(); } catch {}
    }
    if (typeof updateLinePreviewScrollCues === "function") {
      try { updateLinePreviewScrollCues(); } catch {}
    }
  }
  function setCenterOnLineSelectEnabled(enabled, { persist = true } = {}) {
    CENTER_ON_LINE_SELECT = !!enabled;
    if (persist) {
      localStorage.setItem(CENTER_ON_LINE_SELECT_KEY, CENTER_ON_LINE_SELECT ? "1" : "0");
    }
    const toggle = document.getElementById("settingsCenterLineToggle");
    if (toggle) toggle.checked = CENTER_ON_LINE_SELECT;
  }
  function setDbusStopIconsEnabled(enabled, { persist = true, apply = true } = {}) {
    DBUS_STOP_ICONS_ENABLED = !!enabled;
    if (persist) {
      localStorage.setItem(DBUS_STOP_ICONS_KEY, DBUS_STOP_ICONS_ENABLED ? "1" : "0");
    }
    const toggle = document.getElementById("settingsBusStopsToggle");
    if (toggle) toggle.checked = DBUS_STOP_ICONS_ENABLED;
    if (apply && typeof renderDbusStopsLayer === "function") {
      try { renderDbusStopsLayer(); } catch {}
    }
  }
  function isDbusGpsNavigationMode(){
    return DBUS_NAVIGATION_TYPE !== DBUS_NAVIGATION_TYPES.LEGACY;
  }
  function setDbusNavigationType(mode, { persist = true, apply = true } = {}){
    const normalized = String(mode || "").toLowerCase().trim();
    DBUS_NAVIGATION_TYPE = normalized === DBUS_NAVIGATION_TYPES.LEGACY
      ? DBUS_NAVIGATION_TYPES.LEGACY
      : DBUS_NAVIGATION_TYPES.GPS;
    if (persist) {
      localStorage.setItem(DBUS_NAVIGATION_TYPE_KEY, DBUS_NAVIGATION_TYPE);
    }
    document.querySelectorAll("#settingsNavigationTypeModes .dbus-mode-btn[data-nav-type]").forEach(btn => {
      const active = btn.dataset.navType === DBUS_NAVIGATION_TYPE;
      btn.classList.toggle("active", active);
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
    if (apply && typeof window.refreshSelectedDbusRouteNavigationMode === "function") {
      try { window.refreshSelectedDbusRouteNavigationMode(); } catch {}
    }
  }
  function wikiBase(){ return LANG === "en" ? "https://en.wikipedia.org/wiki/" : "https://fr.wikipedia.org/wiki/"; }
  function buildLangMenu(){
    window.sharedHeader?.buildLangMenu?.();
  }
  function updateLangButtonUI(){
    window.sharedHeader?.updateLangButtonUI?.();
  }
  function setLangMenuOpen(open){
    window.sharedHeader?.setLangMenuOpen?.(open);
  }
  function isLangMenuOpen(){
    return !!window.sharedHeader?.isLangMenuOpen?.();
  }
  function openLangMenu(){
    window.sharedHeader?.openLangMenu?.();
  }
  function closeLangMenu(){
    window.sharedHeader?.closeLangMenu?.();
  }
  function toggleLangMenu(){ window.sharedHeader?.toggleLangMenu?.(); }
  function dbusLinesPanelTitleByMode(){
    return t("dbus_button");
  }
  function updateDbusPanelTitles(){
    const title = dbusLinesPanelTitleByMode();
    const panelTitle = document.getElementById("dbusPanelTitle");
    if (panelTitle) panelTitle.textContent = title;
    const linesTitle = document.getElementById("dbusLinesTitle");
    if (linesTitle) linesTitle.textContent = t("dbus_lines_title");
  }
  function updateLangUI(){
    updateLangButtonUI();
    const btnSettings = document.getElementById("btnSettings");
    if (btnSettings) {
      const label = t("settings_button");
      btnSettings.setAttribute("aria-label", label);
      btnSettings.title = label;
    }
    const settingsTitle = document.getElementById("settingsPanelTitle");
    if (settingsTitle) settingsTitle.textContent = t("settings_button");
    const settingsClose = document.getElementById("settingsPanelClose");
    if (settingsClose) {
      settingsClose.setAttribute("aria-label", t("close"));
      settingsClose.title = t("close");
    }
    const menu = document.getElementById("langMenu");
    if (menu) {
      menu.setAttribute("aria-label", t("language_label"));
      menu.querySelectorAll(".lang-option").forEach(option => {
        const isActive = option.dataset.lang === LANG;
        option.setAttribute("aria-selected", isActive ? "true" : "false");
        const name = option.querySelector(".lang-name");
        if (name) name.textContent = langLabel(option.dataset.lang);
      });
    }
    const settingsWebCategoryTitle = document.getElementById("settingsWebCategoryTitle");
    if (settingsWebCategoryTitle) settingsWebCategoryTitle.textContent = t("settings_web_category");
    const settingsDbusCategoryTitle = document.getElementById("settingsDbusCategoryTitle");
    if (settingsDbusCategoryTitle) settingsDbusCategoryTitle.textContent = t("settings_dbus_category");
    const settingsMapVersionTitle = document.getElementById("settingsMapVersionTitle");
    if (settingsMapVersionTitle) settingsMapVersionTitle.textContent = t("settings_map_version");
    const settingsMapVersionSelect = document.getElementById("settingsMapVersionSelect");
    if (settingsMapVersionSelect) {
      const label = t("settings_map_version");
      settingsMapVersionSelect.setAttribute("aria-label", label);
      settingsMapVersionSelect.title = label;
    }
    const settingsAnimationsTitle = document.getElementById("settingsAnimationsTitle");
    if (settingsAnimationsTitle) settingsAnimationsTitle.textContent = t("settings_animations_title");
    const settingsAnimationsLabel = document.getElementById("settingsAnimationsLabel");
    if (settingsAnimationsLabel) settingsAnimationsLabel.textContent = t("settings_animations_toggle");
    const settingsAnimationsToggle = document.getElementById("settingsAnimationsToggle");
    if (settingsAnimationsToggle) {
      const label = t("settings_animations_toggle");
      settingsAnimationsToggle.setAttribute("aria-label", label);
      settingsAnimationsToggle.title = label;
      settingsAnimationsToggle.checked = !!UI_ANIMATIONS;
    }
    const settingsSaeivPanelRow = document.getElementById("settingsSaeivPanelRow");
    const settingsSaeivPanelLabel = document.getElementById("settingsSaeivPanelLabel");
    const settingsSaeivPanelBadge = document.getElementById("settingsSaeivPanelBadge");
    const settingsSaeivPanelToggle = document.getElementById("settingsSaeivPanelToggle");
    const showSaeivPanelSetting = LANG === "fr";
    const disableSaeivPanelSetting = !isSaeivFeatureAllowed();
    if (settingsSaeivPanelRow) {
      settingsSaeivPanelRow.hidden = !showSaeivPanelSetting;
      settingsSaeivPanelRow.style.display = showSaeivPanelSetting ? "" : "none";
    }
    if (settingsSaeivPanelLabel) settingsSaeivPanelLabel.textContent = "Ecran SAEIV";
    if (settingsSaeivPanelBadge) settingsSaeivPanelBadge.textContent = "En développement";
    if (settingsSaeivPanelToggle) {
      const label = "Ecran SAEIV";
      settingsSaeivPanelToggle.setAttribute("aria-label", label);
      settingsSaeivPanelToggle.title = label;
      settingsSaeivPanelToggle.checked = disableSaeivPanelSetting ? false : !!SAEIV_PANEL_BUTTON_ENABLED;
      settingsSaeivPanelToggle.disabled = !showSaeivPanelSetting || disableSaeivPanelSetting;
    }
    const settingsAudioPanelRow = document.getElementById("settingsAudioPanelRow");
    const settingsAudioPanelLabel = document.getElementById("settingsAudioPanelLabel");
    const settingsAudioPanelBadge = document.getElementById("settingsAudioPanelBadge");
    const settingsAudioPanelToggle = document.getElementById("settingsAudioPanelToggle");
    const showAudioPanelSetting = LANG === "fr";
    if (settingsAudioPanelRow) {
      settingsAudioPanelRow.hidden = !showAudioPanelSetting;
      settingsAudioPanelRow.style.display = showAudioPanelSetting ? "" : "none";
    }
    if (settingsAudioPanelLabel) settingsAudioPanelLabel.textContent = t("audio_panel_title");
    if (settingsAudioPanelBadge) settingsAudioPanelBadge.textContent = t("experimental");
    if (settingsAudioPanelToggle) {
      const label = t("audio_panel_title");
      settingsAudioPanelToggle.setAttribute("aria-label", label);
      settingsAudioPanelToggle.title = label;
      settingsAudioPanelToggle.checked = !!AUDIO_PANEL_BUTTON_ENABLED;
      settingsAudioPanelToggle.disabled = !showAudioPanelSetting;
    }
    const settingsTranslateStopsLabel = document.getElementById("settingsTranslateStopsLabel");
    if (settingsTranslateStopsLabel) settingsTranslateStopsLabel.textContent = t("translate_stop_types");
    const settingsTranslateStopsRow = document.getElementById("settingsTranslateStopsRow");
    const settingsTranslateStopsToggle = document.getElementById("settingsTranslateStopsToggle");
    const hideTranslateStops = LANG === "fr";
    if (settingsTranslateStopsRow) {
      settingsTranslateStopsRow.hidden = hideTranslateStops;
      settingsTranslateStopsRow.style.display = hideTranslateStops ? "none" : "";
    }
    if (settingsTranslateStopsToggle) {
      const label = t("translate_stop_types");
      settingsTranslateStopsToggle.setAttribute("aria-label", label);
      settingsTranslateStopsToggle.title = label;
      settingsTranslateStopsToggle.checked = !!TRANSLATE_STOP_TYPES;
      settingsTranslateStopsToggle.disabled = hideTranslateStops;
    }
    const settingsPreviewLayoutTitle = document.getElementById("settingsPreviewLayoutTitle");
    if (settingsPreviewLayoutTitle) settingsPreviewLayoutTitle.textContent = t("settings_preview_layout_title");
    const settingsPreviewLayoutModes = document.getElementById("settingsPreviewLayoutModes");
    if (settingsPreviewLayoutModes) settingsPreviewLayoutModes.setAttribute("aria-label", t("settings_preview_layout_label"));
    document.querySelectorAll("#settingsPreviewLayoutModes .dbus-mode-btn[data-preview-layout]").forEach(btn => {
      const mode = btn.dataset.previewLayout;
      if (mode === LINE_PREVIEW_LAYOUTS.VERTICAL) btn.textContent = t("settings_preview_layout_vertical");
      if (mode === LINE_PREVIEW_LAYOUTS.HORIZONTAL) btn.textContent = t("settings_preview_layout_horizontal");
      const active = mode === LINE_PREVIEW_LAYOUT;
      btn.classList.toggle("active", active);
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
    const settingsCenteringTitle = document.getElementById("settingsCenteringTitle");
    if (settingsCenteringTitle) settingsCenteringTitle.textContent = t("settings_centering_title");
    const settingsCenterLineLabel = document.getElementById("settingsCenterLineLabel");
    if (settingsCenterLineLabel) settingsCenterLineLabel.textContent = t("settings_center_line_toggle");
    const settingsCenterLineToggle = document.getElementById("settingsCenterLineToggle");
    if (settingsCenterLineToggle) {
      const label = t("settings_center_line_toggle");
      settingsCenterLineToggle.setAttribute("aria-label", label);
      settingsCenterLineToggle.title = label;
      settingsCenterLineToggle.checked = !!CENTER_ON_LINE_SELECT;
    }
    const settingsNavigationTypeTitle = document.getElementById("settingsNavigationTypeTitle");
    if (settingsNavigationTypeTitle) settingsNavigationTypeTitle.textContent = t("settings_navigation_type_title");
    const settingsNavigationTypeModes = document.getElementById("settingsNavigationTypeModes");
    if (settingsNavigationTypeModes) settingsNavigationTypeModes.setAttribute("aria-label", t("settings_navigation_type_label"));
    document.querySelectorAll("#settingsNavigationTypeModes .dbus-mode-btn[data-nav-type]").forEach(btn => {
      const mode = String(btn.dataset.navType || "").toLowerCase();
      if (mode === DBUS_NAVIGATION_TYPES.GPS) btn.textContent = t("settings_navigation_type_gps");
      if (mode === DBUS_NAVIGATION_TYPES.LEGACY) btn.textContent = t("settings_navigation_type_legacy");
      const active = mode === DBUS_NAVIGATION_TYPE;
      btn.classList.toggle("active", active);
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
    const settingsLeafletLegendTitle = document.getElementById("settingsLeafletLegendTitle");
    if (settingsLeafletLegendTitle) settingsLeafletLegendTitle.textContent = t("settings_leaflet_legend_title");
    const settingsLegendMonumentLabel = document.getElementById("settingsLegendMonumentLabel");
    if (settingsLegendMonumentLabel) settingsLegendMonumentLabel.textContent = t("emblematic");
    const settingsLegendMallLabel = document.getElementById("settingsLegendMallLabel");
    if (settingsLegendMallLabel) settingsLegendMallLabel.textContent = t("malls");
    const settingsLegendRepairLabel = document.getElementById("settingsLegendRepairLabel");
    if (settingsLegendRepairLabel) settingsLegendRepairLabel.textContent = t("repair_shops");
    const settingsLegendAgencyLabel = document.getElementById("settingsLegendAgencyLabel");
    if (settingsLegendAgencyLabel) settingsLegendAgencyLabel.textContent = t("agencies");
    const settingsLegendDealerLabel = document.getElementById("settingsLegendDealerLabel");
    if (settingsLegendDealerLabel) settingsLegendDealerLabel.textContent = t("dealers");
    const settingsLegendGarageLabel = document.getElementById("settingsLegendGarageLabel");
    if (settingsLegendGarageLabel) settingsLegendGarageLabel.textContent = t("garage");
    const settingsLegendGasLabel = document.getElementById("settingsLegendGasLabel");
    if (settingsLegendGasLabel) settingsLegendGasLabel.textContent = t("icon_gas");
    const settingsLegendBusStationLabel = document.getElementById("settingsLegendBusStationLabel");
    if (settingsLegendBusStationLabel) settingsLegendBusStationLabel.textContent = t("icon_bus_station");
    const settingsLegendBorderLabel = document.getElementById("settingsLegendBorderLabel");
    if (settingsLegendBorderLabel) settingsLegendBorderLabel.textContent = t("icon_border_control");
    const settingsLegendTollLabel = document.getElementById("settingsLegendTollLabel");
    if (settingsLegendTollLabel) settingsLegendTollLabel.textContent = t("icon_toll");
    const settingsLegendParkingLabel = document.getElementById("settingsLegendParkingLabel");
    if (settingsLegendParkingLabel) settingsLegendParkingLabel.textContent = t("icon_parking");
    const settingsLegendBusStopsLabel = document.getElementById("settingsLegendBusStopsLabel");
    if (settingsLegendBusStopsLabel) settingsLegendBusStopsLabel.textContent = t("settings_legend_bus_stops");
    const settingsLegendBusStopsToggleLabel = document.getElementById("settingsLegendBusStopsToggleLabel");
    if (settingsLegendBusStopsToggleLabel) settingsLegendBusStopsToggleLabel.textContent = t("settings_legend_bus_stops_toggle");
    const settingsLegendBusStopsBadge = document.getElementById("settingsLegendBusStopsBadge");
    if (settingsLegendBusStopsBadge) settingsLegendBusStopsBadge.textContent = t("experimental");
    const settingsBusStopsToggle = document.getElementById("settingsBusStopsToggle");
    if (settingsBusStopsToggle) {
      const label = t("settings_legend_bus_stops");
      settingsBusStopsToggle.setAttribute("aria-label", label);
      settingsBusStopsToggle.title = label;
      settingsBusStopsToggle.checked = !!DBUS_STOP_ICONS_ENABLED;
    }
    const settingsSortTitle = document.getElementById("settingsSortTitle");
    if (settingsSortTitle) settingsSortTitle.textContent = t("settings_category_sort");
    const dbusSortLabel = document.getElementById("dbusSortLabel");
    if (dbusSortLabel) dbusSortLabel.textContent = t("settings_category_sort");
    const settingsFilterTitle = document.getElementById("settingsFilterTitle");
    if (settingsFilterTitle) settingsFilterTitle.textContent = t("dbus_filter_label");
    const settingsSchoolLabel = document.getElementById("settingsSchoolLabel");
    if (settingsSchoolLabel) settingsSchoolLabel.textContent = t("dbus_school_toggle");
    const settingsFictiveLabel = document.getElementById("settingsFictiveLabel");
    if (settingsFictiveLabel) settingsFictiveLabel.textContent = t("dbus_fictive_toggle");
    const settingsSortModes = document.getElementById("settingsSortModes");
    if (settingsSortModes) settingsSortModes.setAttribute("aria-label", t("settings_category_sort"));
    const dbusSortModes = document.getElementById("dbusSortModes");
    if (dbusSortModes) dbusSortModes.setAttribute("aria-label", t("settings_category_sort"));
    if (typeof window.updateMapVersionSettingsUI === "function") {
      try { window.updateMapVersionSettingsUI(); } catch {}
    }
    if (typeof window.updateWatermarkVersionLabel === "function") {
      try { window.updateWatermarkVersionLabel(); } catch {}
    }
  }
  function setLang(lang, {persist=true, apply=true} = {}){
    const previousLang = LANG;
    if (!SUPPORTED.has(lang)) lang = "fr";
    LANG = lang;
    const langChanged = previousLang !== LANG;
    if (persist) localStorage.setItem("idf_lang", lang);
    document.documentElement.setAttribute("lang", lang);
    if (LANG === "fr" && TRANSLATE_STOP_TYPES) {
      setStopTypeTranslation(false, { persist: true, apply: false });
    }
    if (typeof isLinePreviewOpen === "function" && isLinePreviewOpen()) {
      try { currentSelectedKey = ""; } catch {}
      try { currentSelectedLineUid = ""; } catch {}
      if (typeof hideAllRoutes === "function") {
        try { hideAllRoutes(); } catch {}
      }
      if (typeof hideLinePreview === "function") {
        try { hideLinePreview(); } catch {}
      }
      document.getElementById("dbusList")?.querySelectorAll(".dbus-item").forEach(it => {
        it.classList.remove("active");
        it.style.outline = "none";
      });
      if (typeof renderSelectedChip === "function") {
        try { renderSelectedChip(); } catch {}
      }
    }
    if (apply) applyI18N();
    if (langChanged) {
      const dbusPanelEl = document.getElementById("dbusPanel");
      const dbusStopPanelEl = document.getElementById("dbusStopPanel");
      const isDbusPanelOpenNow = !!dbusPanelEl && getComputedStyle(dbusPanelEl).display !== "none" && !dbusPanelEl.classList.contains("is-closing");
      const isDbusStopOpenNow = !!dbusStopPanelEl && getComputedStyle(dbusStopPanelEl).display !== "none" && !dbusStopPanelEl.classList.contains("is-closing");
      if (isDbusPanelOpenNow || isDbusStopOpenNow) {
        try {
          if (typeof closeDbusPanel === "function") closeDbusPanel();
          else throw new Error("closeDbusPanel_unavailable");
        } catch {
          if (dbusPanelEl) {
            dbusPanelEl.classList.remove("is-open", "is-closing");
            dbusPanelEl.style.display = "none";
            dbusPanelEl.setAttribute("aria-hidden", "true");
          }
          if (dbusStopPanelEl) {
            dbusStopPanelEl.classList.remove("is-open", "is-closing");
            dbusStopPanelEl.style.display = "none";
            dbusStopPanelEl.setAttribute("aria-hidden", "true");
          }
          const btnDbusEl = document.getElementById("btnDbus");
          if (btnDbusEl) btnDbusEl.setAttribute("aria-expanded", "false");
        }
      }
    }
    if (typeof updateUiOverlays === "function") {
      try { updateUiOverlays(); } catch {}
    }
  }
    function applyI18N(){
    renderSiteNav();
    const routeTitleFn = (typeof translateRouteTitle === "function")
      ? translateRouteTitle
      : (title) => translateStopName(title);
    const $search = document.getElementById("search");
    if ($search) {
      const label = t("search_placeholder");
      $search.placeholder = label;
      $search.setAttribute("aria-label", label);
    }
    const $btnSearch = document.getElementById("btnSearch");
    if ($btnSearch) $btnSearch.textContent = t("search_button");
    const $searchPanelTitle = document.getElementById("searchPanelTitle");
    if ($searchPanelTitle) $searchPanelTitle.textContent = t("search_button");
    const $searchPanelClose = document.getElementById("searchPanelClose");
    if ($searchPanelClose){ $searchPanelClose.setAttribute("aria-label", t("close")); $searchPanelClose.title = t("close"); }
    const $searchFilterLabel = document.getElementById("searchFilterLabel");
    if ($searchFilterLabel) $searchFilterLabel.textContent = t("search_category_label");
    document.querySelectorAll(".search-categories .dbus-mode-btn").forEach(btn => {
      const key = btn.dataset.category;
      if (key) btn.textContent = searchCategoryButtonLabel(key);
    });
    const $btnDbus = document.getElementById("btnDbus");
    if ($btnDbus) {
      const label = t("dbus_button");
      $btnDbus.setAttribute("aria-label", label);
      $btnDbus.title = label;
    }
    const $btnSaeivPanel = document.getElementById("btnSaeivPanel");
    if ($btnSaeivPanel) {
      const label = "Ecran SAEIV";
      $btnSaeivPanel.setAttribute("aria-label", label);
      $btnSaeivPanel.title = label;
    }
    const $btnAudioPanel = document.getElementById("btnAudioPanel");
    if ($btnAudioPanel) {
      const label = t("audio_panel_title");
      $btnAudioPanel.setAttribute("aria-label", label);
      $btnAudioPanel.title = label;
    }
    updateDbusPanelTitles();
    const $dbusModeLabel = document.getElementById("dbusModeLabel");
    if ($dbusModeLabel) $dbusModeLabel.textContent = t("dbus_mode_label");
    document.querySelectorAll(".dbus-mode-btn").forEach(btn => {
      const mode = btn.dataset.mode;
      if (mode === "lines") btn.textContent = t("dbus_mode_lines");
      if (mode === "length") btn.textContent = t("dbus_mode_length");
      if (mode === "departures") btn.textContent = t("dbus_mode_stops");
    });
    const $dbusDepartMapBtn = document.getElementById("dbusDepartMapBtn");
    if ($dbusDepartMapBtn) {
      const label = t("dbus_depart_map_btn");
      $dbusDepartMapBtn.textContent = label;
      $dbusDepartMapBtn.setAttribute("aria-label", label);
      $dbusDepartMapBtn.title = label;
    }
    const $dbusFilterLabel = document.getElementById("dbusFilterLabel");
    if ($dbusFilterLabel) $dbusFilterLabel.textContent = t("dbus_filter_label");
    const $dbusSortLabel = document.getElementById("dbusSortLabel");
    if ($dbusSortLabel) $dbusSortLabel.textContent = t("settings_category_sort");
    const $dbusRoutesTitleLabel = document.getElementById("dbusRoutesTitleLabel");
    if ($dbusRoutesTitleLabel) {
      const count = parseInt($dbusRoutesTitleLabel.dataset.routeCount || "", 10);
      if (Number.isFinite(count) && count >= 0) $dbusRoutesTitleLabel.textContent = `${t("dbus_routes_title")} (${count})`;
      else $dbusRoutesTitleLabel.textContent = t("dbus_routes_title");
    }
    const $dbusRoutesClear = document.getElementById("dbusRoutesClear");
    if ($dbusRoutesClear) {
      $dbusRoutesClear.setAttribute("aria-label", t("close"));
      $dbusRoutesClear.title = t("close");
    }
    const $dbusSchoolLabel = document.getElementById("dbusSchoolLabel");
    const $dbusSchoolToggle = document.getElementById("dbusSchoolToggle");
    if ($dbusSchoolLabel) $dbusSchoolLabel.textContent = t("dbus_school_toggle");
    if ($dbusSchoolToggle) {
      const label = t("dbus_school_toggle");
      $dbusSchoolToggle.setAttribute("aria-label", label);
      $dbusSchoolToggle.title = label;
    }
    const $dbusFictiveLabel = document.getElementById("dbusFictiveLabel");
    const $dbusFictiveToggle = document.getElementById("dbusFictiveToggle");
    if ($dbusFictiveLabel) $dbusFictiveLabel.textContent = t("dbus_fictive_toggle");
    if ($dbusFictiveToggle) {
      const label = t("dbus_fictive_toggle");
      $dbusFictiveToggle.setAttribute("aria-label", label);
      $dbusFictiveToggle.title = label;
    }
    const $settingsSchoolToggle = document.getElementById("settingsSchoolToggle");
    if ($settingsSchoolToggle) {
      const label = t("dbus_school_toggle");
      $settingsSchoolToggle.setAttribute("aria-label", label);
      $settingsSchoolToggle.title = label;
    }
    const $settingsFictiveToggle = document.getElementById("settingsFictiveToggle");
    if ($settingsFictiveToggle) {
      const label = t("dbus_fictive_toggle");
      $settingsFictiveToggle.setAttribute("aria-label", label);
      $settingsFictiveToggle.title = label;
    }
    const $lpClose = document.getElementById("lpClose");
    if ($lpClose){ $lpClose.setAttribute("aria-label", t("close")); $lpClose.title = t("close"); }
    const $lpCueUp = document.querySelector("#linePreview .line-preview-scroll-cue.top");
    if ($lpCueUp) $lpCueUp.setAttribute("aria-label", t("line_preview_scroll_up"));
    const $lpCueDown = document.querySelector("#linePreview .line-preview-scroll-cue.bottom");
    if ($lpCueDown) $lpCueDown.setAttribute("aria-label", t("line_preview_scroll_down"));
    const $lpLink = document.getElementById("lpLink");
    if ($lpLink){
      const label = t("open_link");
      $lpLink.setAttribute("aria-label", label);
      $lpLink.title = label;
    }
    const $lpAudioLink = document.getElementById("lpAudioLink");
    if ($lpAudioLink){
      const label = t("audio_system_enable");
      $lpAudioLink.setAttribute("aria-label", label);
      $lpAudioLink.title = label;
    }
    const $lpAudioPanel = document.getElementById("lpAudioPanel");
    if ($lpAudioPanel) $lpAudioPanel.setAttribute("aria-label", t("audio_panel_title"));
    const $lpAudioPanelTitle = document.getElementById("lpAudioPanelTitle");
    if ($lpAudioPanelTitle) $lpAudioPanelTitle.textContent = t("audio_panel_title");
    const $lpAudioNoLineHint = document.getElementById("lpAudioNoLineHint");
    if ($lpAudioNoLineHint) {
      const noLineSelected = !String(currentSelectedKey || "").trim();
      $lpAudioNoLineHint.textContent = noLineSelected ? t("audio_no_line_selected") : t("audio_line_unavailable");
    }
    const $lpAudioPanelClose = document.getElementById("lpAudioPanelClose");
    if ($lpAudioPanelClose) {
      $lpAudioPanelClose.setAttribute("aria-label", t("close"));
      $lpAudioPanelClose.title = t("close");
    }
    const $lpAudioPrevBtn = document.getElementById("lpAudioPrevBtn");
    if ($lpAudioPrevBtn) {
      const label = t("audio_prev_stop");
      $lpAudioPrevBtn.textContent = "<";
      $lpAudioPrevBtn.setAttribute("aria-label", label);
      $lpAudioPrevBtn.title = label;
    }
    const $lpAudioCurrentBtn = document.getElementById("lpAudioCurrentBtn");
    if ($lpAudioCurrentBtn) {
      const label = t("audio_current_stop");
      $lpAudioCurrentBtn.textContent = label;
      $lpAudioCurrentBtn.setAttribute("aria-label", label);
      $lpAudioCurrentBtn.title = label;
    }
    const $lpAudioNextBtn = document.getElementById("lpAudioNextBtn");
    if ($lpAudioNextBtn) {
      const label = t("audio_next_stop");
      $lpAudioNextBtn.textContent = ">";
      $lpAudioNextBtn.setAttribute("aria-label", label);
      $lpAudioNextBtn.title = label;
    }
    const $lpAudioTerminusBtn = document.getElementById("lpAudioTerminusBtn");
    if ($lpAudioTerminusBtn) {
      const label = t("audio_terminus_btn");
      $lpAudioTerminusBtn.textContent = label;
      $lpAudioTerminusBtn.setAttribute("aria-label", label);
      $lpAudioTerminusBtn.title = label;
    }
    const $lpAudioStyleLabel = document.getElementById("lpAudioStyleLabel");
    if ($lpAudioStyleLabel) $lpAudioStyleLabel.textContent = t("audio_voice_style");
    const $lpAudioStyleSelect = document.getElementById("lpAudioStyleSelect");
    if ($lpAudioStyleSelect) {
      const label = t("audio_voice_style");
      $lpAudioStyleSelect.setAttribute("aria-label", label);
      $lpAudioStyleSelect.title = label;
    }
    const $lpAudioVolumeLabel = document.getElementById("lpAudioVolumeLabel");
    if ($lpAudioVolumeLabel) $lpAudioVolumeLabel.textContent = t("audio_volume");
    const $lpAudioVolumeRange = document.getElementById("lpAudioVolumeRange");
    if ($lpAudioVolumeRange) {
      const label = t("audio_volume");
      $lpAudioVolumeRange.setAttribute("aria-label", label);
      $lpAudioVolumeRange.title = label;
    }
    const $lpAudioStopBtn = document.getElementById("lpAudioStopBtn");
    if ($lpAudioStopBtn) {
      const label = t("audio_stop");
      $lpAudioStopBtn.textContent = label;
      $lpAudioStopBtn.setAttribute("aria-label", label);
      $lpAudioStopBtn.title = label;
    }
    if (typeof updateLinePreviewAudioStyleSelect === "function") {
      updateLinePreviewAudioStyleSelect();
    }
    if (typeof refreshSaeivTopButtonVisibility === "function") {
      refreshSaeivTopButtonVisibility();
    }
    if (typeof refreshLinePreviewAudioTopButtonVisibility === "function") {
      refreshLinePreviewAudioTopButtonVisibility({ closePanelOnHide: true });
    }
    if (typeof refreshLinePreviewAudioButtonVisibility === "function") {
      refreshLinePreviewAudioButtonVisibility();
    }
    const $dbusWorldLink = document.getElementById("dbusWorldLink");
    if ($dbusWorldLink){
      const offsite = window.SITE_OFFSITE_LINKS && typeof window.SITE_OFFSITE_LINKS === "object"
        ? window.SITE_OFFSITE_LINKS
        : {};
      const offsiteKey = String($dbusWorldLink.getAttribute("data-offsite-key") || "").trim();
      const offsiteHref = String(offsite[offsiteKey] || "").trim();
      if (offsiteHref) $dbusWorldLink.href = offsiteHref;
      const label = t("dbus_world_button");
      $dbusWorldLink.setAttribute("aria-label", label);
      $dbusWorldLink.title = label;
    }
    const $dbusStopClose = document.getElementById("dbusStopClose");
    if ($dbusStopClose){ $dbusStopClose.setAttribute("aria-label", t("close")); $dbusStopClose.title = t("close"); }
    const $dbusDepartIndicatorLabel = document.getElementById("dbusDepartIndicatorLabel");
    if ($dbusDepartIndicatorLabel) $dbusDepartIndicatorLabel.textContent = t("departures_active");
    const $dbusDepartIndicatorClose = document.getElementById("dbusDepartIndicatorClose");
    if ($dbusDepartIndicatorClose){
      $dbusDepartIndicatorClose.setAttribute("aria-label", t("departures_disable"));
      $dbusDepartIndicatorClose.title = t("departures_disable");
    }
    const $dbusRoutesListLocal = document.getElementById("dbusRoutesList");
    if ($dbusRoutesListLocal && !$dbusRoutesListLocal.querySelector(".dbus-item")) {
      $dbusRoutesListLocal.innerHTML = `<div class="dbus-none">${t("none")}</div>`;
    }
    const home = document.querySelector(".leaflet-custom-home a.home-btn");
    if (home) home.title = t("home_tooltip");

    const results = document.getElementById("results");
    if (results && !results.hidden) {
      const empty = results.querySelector(".result-empty");
      if (empty) empty.textContent = resultsEmptyText();
      results.querySelectorAll(".result-sechead").forEach(h => {
        const raw = h.textContent.trim().toLowerCase();
        const map = {
          "villes": t("villes"),
          "lieux emblématiques": t("emblematic"),
          "ateliers de réparation": t("repair_shops"),
          "agences de recrutement": t("agencies"),
          "concessionnaires": t("dealers"),
          "entreprises": t("companies"),
          "centres commerciaux": t("malls"),
        };
        if (map[raw]) h.textContent = map[raw];
      });
    }
    if (results && !results.hidden) {
      results.querySelectorAll(".result-sechead").forEach(h => {
        const typeKey = h.dataset.type;
        const count = h.dataset.count;
        if (typeKey && count !== undefined) {
          h.textContent = `${searchCategoryLabel(typeKey)} (${count})`;
        }
      });
    }
    const $dbusStopTitle = document.getElementById("dbusStopTitle");
    if ($dbusStopTitle) {
      const mode = $dbusStopTitle.dataset.stopMode || "";
      const name = $dbusStopTitle.dataset.stopName || "";
      if (mode === "single" && name) {
        $dbusStopTitle.innerHTML = `${t("stop")} : ${withRERIcon(translateStopName(name))}`;
      } else if (mode === "group") {
        const raw = $dbusStopTitle.dataset.stopNames || "[]";
        let list = [];
        try { list = JSON.parse(raw); } catch { list = []; }
        const translated = list.map(n => translateStopName(n));
        $dbusStopTitle.innerHTML = translated.map(n => withRERIcon(n)).join(" / ");
      } else if (!mode) {
        $dbusStopTitle.textContent = t("stop");
      }
    }
    document.querySelectorAll(".stop-flag").forEach(flag => {
      const label = t("temporary_stop");
      flag.textContent = label;
      flag.setAttribute("aria-label", label);
    });
    document.querySelectorAll(".stop[data-raw-label]").forEach(stop => {
      const raw = stop.dataset.rawLabel || "";
      const isProv = stop.dataset.provisoire === "1";
      const label = translateStopName(raw);
      const nameEl = stop.querySelector(".name");
      if (nameEl) {
        const flag = isProv ? ` <span class="stop-flag" aria-label="${t("temporary_stop")}">${t("temporary_stop")}</span>` : "";
        nameEl.innerHTML = `${withRERIcon(label)}${flag}`;
      }
    });
    document.querySelectorAll(".sp-coords span").forEach(span => {
      span.textContent = t("coordinates");
    });
    document.querySelectorAll(".sp-copy-cmd").forEach(btn => {
      const label = t("copy_command_button");
      const copiedLabel = t("copy_command_copied");
      const failedLabel = t("copy_command_failed");
      btn.textContent = label;
      btn.setAttribute("aria-label", label);
      btn.title = label;
      btn.dataset.copiedLabel = copiedLabel;
      btn.dataset.copyFailedLabel = failedLabel;
    });
    document.querySelectorAll(".dbus-sec h4[data-stop-name]").forEach(h => {
      const raw = h.dataset.stopName || "";
      const count = h.dataset.stopCount || "";
      const label = withRERIcon(translateStopName(raw));
      h.innerHTML = `${label}${count ? ` (${count})` : ""}`;
    });
    document.querySelectorAll(".rname[data-raw-name]").forEach(el => {
      const raw = el.dataset.rawName || "";
      el.innerHTML = withRERIcon(translateStopName(raw));
    });
    document.querySelectorAll(".rname[data-route-kind]").forEach(el => {
      const kind = el.dataset.routeKind;
      const routeTitle = el.dataset.routeTitle || "";
      const flag = el.dataset.routeFlag || "";
      if (kind === "line") {
        const displayTitle = routeTitleFn(routeTitle);
        let html = withRERIcon(displayTitle || routeTitle);
        if (flag) html += ` <span class="route-flag">${flag}</span>`;
        el.innerHTML = html;
      } else if (kind === "depart") {
        const titleEnd = el.dataset.routeEnd || "";
        const dirName = getRouteTerminusLabel({ stops: [] }, titleEnd) || String(titleEnd || routeTitle || "").trim();
        const dirLabel = t("destination");
        const dirText = dirName || routeTitle || "?";
        let html = `${dirLabel} : ${withRERIcon(dirText)}`;
        if (flag) html += ` <span class="route-flag">${flag}</span>`;
        el.innerHTML = html;
      }
    });
    document.querySelectorAll(".result-text[data-route-title]").forEach(el => {
      const raw = el.dataset.routeTitle || "";
      el.textContent = routeTitleFn(raw);
    });
    document.querySelectorAll("[data-stop-count]").forEach(el => {
      const count = parseInt(el.dataset.stopCount || "0", 10);
      const durationText = el.dataset.durationText || "";
      const format = el.dataset.durationFormat || "paren";
      if (Number.isFinite(count)) {
        el.textContent = formatStopDuration(count, durationText, format);
      }
    });
    document.querySelectorAll(".badge[data-badge-raw], .dbus-badge[data-badge-raw]").forEach(badgeEl => {
      const raw = badgeEl.dataset.badgeRaw || "";
      const labelText = translateBadgeToken(raw);
      const labelEl = ensureBadgeLabel(badgeEl, labelText);
      if (!labelEl) return;
      const box = badgeEl.getBoundingClientRect();
      const width = Math.max(24, Math.round(box.width || parseInt(badgeEl.style.width || "72", 10)));
      const height = Math.max(16, Math.round(box.height || parseInt(badgeEl.style.height || "32", 10)));
      labelEl.style.fontSize = computeBadgeFontSize(labelText, width, height) + "px";
    });
    const $lpRouteTitle = document.getElementById("lpRouteTitle");
    const $lpRouteMeta = document.getElementById("lpRouteMeta");
    if ($lpRouteTitle && ($lpRouteTitle.dataset.rawStart || $lpRouteTitle.dataset.rawEnd)) {
      const start = translateStopName($lpRouteTitle.dataset.rawStart || "");
      const end = translateStopName($lpRouteTitle.dataset.rawEnd || "");
      $lpRouteTitle.innerHTML = `${withRERIcon(start)} &gt; ${withRERIcon(end)}`;
      if ($lpRouteMeta) {
        const count = parseInt($lpRouteMeta.dataset.stopCount || "0", 10);
        const durationText = $lpRouteMeta.dataset.durationText || "";
        const format = $lpRouteMeta.dataset.durationFormat || "dash";
        if (Number.isFinite(count)) {
          setStopDurationText($lpRouteMeta, count, durationText, format);
        }
      }
    }
    document.querySelectorAll(".dbus-sechead").forEach(head => {
      const key = head.dataset.cat;
      const count = head.dataset.count;
      if (!key || !count) return;
      if (typeof dbusSectionHeadHTML === "function") {
        head.innerHTML = dbusSectionHeadHTML(key, Number(count));
      } else {
        const label = dbusCategoryTitle(key);
        head.innerHTML = `<span>${label} (${count})</span><span class="chev" style="margin-left:auto">▼</span>`;
      }
    });
    document.querySelectorAll("h4[data-sub-key]").forEach(head => {
      const key = head.dataset.subKey || "";
      if (key) head.textContent = t(key);
    });
    document.querySelectorAll(".dbus-none").forEach(none => {
      none.textContent = t("none");
    });
    if (typeof window.refreshLinePreviewRail === "function") {
      window.refreshLinePreviewRail();
    }
    refreshI18nLayers();
    updateLangUI();
  }
  window.sharedHeader?.init?.({
    t,
    getLang: () => LANG,
    setLang: (nextLang) => setLang(nextLang),
    langOptions: LANG_OPTIONS,
    langMeta: LANG_META,
    langLabel: (code) => langLabel(code),
    navTree: SITE_NAV_TREE
  });
  buildLangMenu();
  document.getElementById("btnSettings")?.addEventListener("click", (event) => {
    event.stopPropagation();
    closeLangMenu();
    if (isSettingsOpen()) closeSettingsPanel();
    else openSettingsPanel();
  });
  const settingsAnimationsToggleEl = document.getElementById("settingsAnimationsToggle");
  if (settingsAnimationsToggleEl) {
    settingsAnimationsToggleEl.addEventListener("change", () => {
      setUiAnimationsEnabled(settingsAnimationsToggleEl.checked);
    });
  }
  const settingsSaeivPanelToggleEl = document.getElementById("settingsSaeivPanelToggle");
  if (settingsSaeivPanelToggleEl) {
    settingsSaeivPanelToggleEl.addEventListener("change", () => {
      if (LANG !== "fr" || !isSaeivFeatureAllowed()) {
        settingsSaeivPanelToggleEl.checked = false;
        setSaeivPanelButtonEnabled(false);
        return;
      }
      setSaeivPanelButtonEnabled(settingsSaeivPanelToggleEl.checked);
    });
  }
  const settingsAudioPanelToggleEl = document.getElementById("settingsAudioPanelToggle");
  if (settingsAudioPanelToggleEl) {
    settingsAudioPanelToggleEl.addEventListener("change", () => {
      if (LANG !== "fr") {
        settingsAudioPanelToggleEl.checked = false;
        setAudioPanelButtonEnabled(false);
        return;
      }
      setAudioPanelButtonEnabled(settingsAudioPanelToggleEl.checked);
    });
  }
  const settingsTranslateStopsToggleEl = document.getElementById("settingsTranslateStopsToggle");
  if (settingsTranslateStopsToggleEl) {
    settingsTranslateStopsToggleEl.addEventListener("change", () => {
      if (LANG === "fr") {
        settingsTranslateStopsToggleEl.checked = false;
        return;
      }
      setStopTypeTranslation(settingsTranslateStopsToggleEl.checked);
    });
  }
  document.querySelectorAll("#settingsPreviewLayoutModes .dbus-mode-btn[data-preview-layout]").forEach(btn => {
    btn.addEventListener("click", () => {
      setLinePreviewLayout(btn.dataset.previewLayout);
    });
  });
  const settingsCenterLineToggleEl = document.getElementById("settingsCenterLineToggle");
  if (settingsCenterLineToggleEl) {
    settingsCenterLineToggleEl.addEventListener("change", () => {
      setCenterOnLineSelectEnabled(settingsCenterLineToggleEl.checked);
    });
  }
  document.querySelectorAll("#settingsNavigationTypeModes .dbus-mode-btn[data-nav-type]").forEach(btn => {
    btn.addEventListener("click", () => {
      setDbusNavigationType(btn.dataset.navType);
    });
  });
  const settingsBusStopsToggleEl = document.getElementById("settingsBusStopsToggle");
  if (settingsBusStopsToggleEl) {
    settingsBusStopsToggleEl.addEventListener("change", () => {
      setDbusStopIconsEnabled(settingsBusStopsToggleEl.checked);
    });
  }
  setUiAnimationsEnabled(UI_ANIMATIONS, { persist: false });
  setSaeivPanelButtonEnabled(SAEIV_PANEL_BUTTON_ENABLED, { persist: false, apply: false });
  setAudioPanelButtonEnabled(AUDIO_PANEL_BUTTON_ENABLED, { persist: false, apply: false });
  setLinePreviewLayout(LINE_PREVIEW_LAYOUT, { persist: false });
  setCenterOnLineSelectEnabled(CENTER_ON_LINE_SELECT, { persist: false });
  setDbusNavigationType(DBUS_NAVIGATION_TYPE, { persist: false, apply: false });
  setDbusStopIconsEnabled(DBUS_STOP_ICONS_ENABLED, { persist: false, apply: false });
  setLang(LANG, {persist:false, apply:true});
  </script>

  <script>
    const QS = new URLSearchParams(location.search);
    const DEV_GRAPH = QS.has("dev_graph");
    const DEV_NAV_BRIDGES_DEBUG = DEV_GRAPH || QS.has("dev_bridges");
    const MAP_FILES_ROOT = "./map_files";
    const VERSION_PATTERN = /^(\d+)\.(\d+)\.(\d+)([a-z])$/i;
    function parseVersion(value){
      const match = VERSION_PATTERN.exec(String(value || "").trim());
      if (!match) return null;
      return {
        raw: `${parseInt(match[1], 10)}.${parseInt(match[2], 10)}.${parseInt(match[3], 10)}${match[4].toLowerCase()}`,
        major: parseInt(match[1], 10),
        minor: parseInt(match[2], 10),
        patch: parseInt(match[3], 10),
        suffix: match[4].toLowerCase()
      };
    }
    function compareVersions(a, b){
      if (a.major !== b.major) return a.major - b.major;
      if (a.minor !== b.minor) return a.minor - b.minor;
      if (a.patch !== b.patch) return a.patch - b.patch;
      return a.suffix.localeCompare(b.suffix);
    }
    function loadVersionsFromManifestSync(root){
      try {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", `${root}/versions.json`, false);
        xhr.send(null);
        if (xhr.status < 200 || xhr.status >= 300) return [];
        const data = JSON.parse(xhr.responseText);
        if (Array.isArray(data)) {
          return data.map(v => String(v || "").trim()).filter(Boolean);
        }
        if (data && Array.isArray(data.versions)) {
          return data.versions.map(v => String(v || "").trim()).filter(Boolean);
        }
        return [];
      } catch {
        return [];
      }
    }
    function loadVersionsFromDirectorySync(root){
      return [];
    }
    function selectLatestVersion(candidates){
      const parsed = [...new Set(candidates)]
        .map(parseVersion)
        .filter(Boolean);
      if (!parsed.length) return null;
      parsed.sort(compareVersions);
      return parsed[parsed.length - 1].raw;
    }
    function getSortedAvailableVersions(candidates){
      const byRaw = new Map();
      candidates.forEach((candidate) => {
        const parsed = parseVersion(candidate);
        if (parsed) byRaw.set(parsed.raw, parsed);
      });
      return [...byRaw.values()]
        .sort((a, b) => compareVersions(b, a))
        .map(v => v.raw);
    }
    const forcedVersion = String(QS.get("version") || QS.get("v") || "").trim();
    const parsedForcedVersion = parseVersion(forcedVersion);
    const manifestVersions = loadVersionsFromManifestSync(MAP_FILES_ROOT);
    const dirVersions = [];
    const AVAILABLE_MAP_VERSIONS = getSortedAvailableVersions([...manifestVersions, ...dirVersions]);
    const latestVersion = selectLatestVersion(AVAILABLE_MAP_VERSIONS);
    const SELECTED_VERSION = parsedForcedVersion ? parsedForcedVersion.raw : latestVersion;
    if (QS.has("version") || QS.has("v")) {
      try {
        const cleanUrl = new URL(location.href);
        cleanUrl.searchParams.delete("version");
        cleanUrl.searchParams.delete("v");
        history.replaceState(null, "", cleanUrl.toString());
      } catch {}
    }
    const DATA_BASE = SELECTED_VERSION ? `${MAP_FILES_ROOT}/${SELECTED_VERSION}` : MAP_FILES_ROOT;
    const OVERLAY_BASE = `${DATA_BASE}/Overlays`;
    const TILE_BASE = `${DATA_BASE}/Tiles`;
    const DBUS_BASE = `${DATA_BASE}/DBus`;
    const dataPath = (file) => `${DATA_BASE}/${file}`;
    const overlayPath = (file) => `${OVERLAY_BASE}/${file}`;
    function updateMapVersionSettingsUI(){
      const section = document.getElementById("settingsMapVersionSection");
      const title = document.getElementById("settingsMapVersionTitle");
      const select = document.getElementById("settingsMapVersionSelect");
      if (title && typeof t === "function") title.textContent = t("settings_map_version");
      if (!section || !select) return;
      if (!AVAILABLE_MAP_VERSIONS.length) {
        section.hidden = true;
        select.innerHTML = "";
        return;
      }
      section.hidden = false;
      if (select.dataset.versionsHash !== AVAILABLE_MAP_VERSIONS.join("|")) {
        select.innerHTML = "";
        AVAILABLE_MAP_VERSIONS.forEach((version) => {
          const option = document.createElement("option");
          option.value = version;
          option.textContent = version;
          select.appendChild(option);
        });
        select.dataset.versionsHash = AVAILABLE_MAP_VERSIONS.join("|");
      }
      const currentVersion = (SELECTED_VERSION && AVAILABLE_MAP_VERSIONS.includes(SELECTED_VERSION))
        ? SELECTED_VERSION
        : AVAILABLE_MAP_VERSIONS[0];
      select.value = currentVersion;
      if (typeof t === "function") {
        const label = t("settings_map_version");
        select.setAttribute("aria-label", label);
        select.title = label;
      }
    }
    function updateWatermarkVersionLabel(){
      const labelEl = document.getElementById("watermarkVersionLabel");
      if (!labelEl) return;
      const currentVersion = (SELECTED_VERSION && AVAILABLE_MAP_VERSIONS.includes(SELECTED_VERSION))
        ? SELECTED_VERSION
        : (AVAILABLE_MAP_VERSIONS[0] || "");
      const prefix = (typeof t === "function") ? t("settings_map_version") : "Map version";
      labelEl.textContent = currentVersion ? `${prefix}: ${currentVersion}` : prefix;
      const isOutdated = !!(currentVersion && latestVersion && currentVersion !== latestVersion);
      labelEl.classList.toggle("is-outdated", isOutdated);
      labelEl.removeAttribute("title");
      labelEl.setAttribute("aria-label", labelEl.textContent);
    }
    window.updateWatermarkVersionLabel = updateWatermarkVersionLabel;
    window.updateMapVersionSettingsUI = updateMapVersionSettingsUI;
    updateMapVersionSettingsUI();
    updateWatermarkVersionLabel();
    const settingsMapVersionSelectEl = document.getElementById("settingsMapVersionSelect");
    if (settingsMapVersionSelectEl && !settingsMapVersionSelectEl.dataset.boundMapVersion) {
      settingsMapVersionSelectEl.dataset.boundMapVersion = "1";
      settingsMapVersionSelectEl.addEventListener("change", () => {
        const nextParsed = parseVersion(settingsMapVersionSelectEl.value);
        if (!nextParsed || nextParsed.raw === SELECTED_VERSION) return;
        try {
          const nextUrl = new URL(location.href);
          nextUrl.searchParams.set("version", nextParsed.raw);
          if (window.sharedHeader?.startPageTransition) {
            window.sharedHeader.startPageTransition();
          } else if (window.sharedHeader?.showPageLoader) {
            window.sharedHeader.showPageLoader({ persist: true });
          }
          location.assign(nextUrl.toString());
        } catch {}
      });
    }

    const watermarkLogo = document.getElementById("watermarkLogo");
    if (watermarkLogo) watermarkLogo.src = overlayPath("idf_logo.png");
    const siteTopbarLogo = document.getElementById("siteTopbarLogo");
    if (siteTopbarLogo) siteTopbarLogo.src = overlayPath("idf_logo.png");
    const btnDbusLogo = document.getElementById("btnDbusLogo");
    if (btnDbusLogo) btnDbusLogo.src = overlayPath("bus_logo_idfm.png");
    document.querySelectorAll("#settingsLeafletLegend [data-overlay-src]").forEach((img) => {
      const file = img.getAttribute("data-overlay-src");
      if (!file) return;
      img.setAttribute("src", overlayPath(file));
    });
    document.documentElement.style.setProperty(
      "--rer-mask-url",
      `url("${overlayPath("o_rer.png")}")`
    );
    document.documentElement.style.setProperty(
      "--metro-icon-url",
      `url("${overlayPath("o_metro.png")}")`
    );

    const minNativeZoom=0,maxNativeZoom=8,tileSize=256;
    const widthPx=tileSize*Math.pow(2,maxNativeZoom),heightPx=tileSize*Math.pow(2,maxNativeZoom);

    const map=L.map('map',{
      crs:L.CRS.Simple,
      attributionControl:false,
      zoomControl:false,
      minZoom:minNativeZoom+4,
      maxZoom:maxNativeZoom+2,
      zoomSnap:0.25,
      zoomDelta:0.25,
      wheelPxPerZoomLevel:80,
      maxBoundsViscosity:1.0,
      inertia:true,
      preferCanvas:true,
      zoomAnimation:true,
      fadeAnimation:true,
      markerZoomAnimation:true
    });
    const dbusRoutePane = map.createPane("dbusRoutePane");
    dbusRoutePane.style.zIndex = "320";
    dbusRoutePane.style.pointerEvents = "none";
    const devGraphEdgePane = map.createPane("devGraphEdgePane");
    devGraphEdgePane.style.zIndex = "245";
    devGraphEdgePane.style.pointerEvents = "none";
    const devGraphNodePane = map.createPane("devGraphNodePane");
    devGraphNodePane.style.zIndex = "246";
    devGraphNodePane.style.pointerEvents = "none";
    const dbusRouteDirectionPane = map.createPane("dbusRouteDirectionPane");
    dbusRouteDirectionPane.style.zIndex = "325";
    dbusRouteDirectionPane.style.pointerEvents = "none";
    const dbusRouteMarkerPane = map.createPane("dbusRouteMarkerPane");
    dbusRouteMarkerPane.style.zIndex = "330";
    dbusRouteMarkerPane.style.pointerEvents = "auto";
    const fullBounds=L.latLngBounds(map.unproject(L.point(0,heightPx),maxNativeZoom),map.unproject(L.point(widthPx,0),maxNativeZoom));
    const MARGIN=64;
    function innerBounds(m){const sw=L.point(0+m,heightPx-m),ne=L.point(widthPx-m,0+m);return L.latLngBounds(map.unproject(sw,maxNativeZoom),map.unproject(ne,maxNativeZoom));}

    const SCALE_RATIO = 0.95;

    function updateCustomScale() {
      const zoom = map.getZoom();
      const scaleFactor = Math.pow(2, zoom - maxNativeZoom);
      const metersPerPixel = SCALE_RATIO / scaleFactor;

      const zoomScales = {
        [maxNativeZoom - 5]: 16000,
        [maxNativeZoom - 4]: 8000,
        [maxNativeZoom - 3]: 4000,
        [maxNativeZoom - 2]: 2000,
        [maxNativeZoom - 1]: 1000,
        [maxNativeZoom]: 500,
        [maxNativeZoom + 1]: 200,
        [maxNativeZoom + 2]: 100,
      };

      let targetMeters = zoomScales[zoom];
      if (targetMeters === undefined) {
        const keys = Object.keys(zoomScales).map(k => parseInt(k));
        const closest = keys.reduce((a, b) =>
          Math.abs(b - zoom) < Math.abs(a - zoom) ? b : a
        );
        targetMeters = zoomScales[closest];
      }

      const pxLength = targetMeters / metersPerPixel;

      const scaleEl = document.getElementById("custom-scale");
      if (scaleEl) {
        scaleEl.style.width = `${pxLength}px`;
        scaleEl.querySelector("span").textContent =
          targetMeters >= 1000 ? `${(targetMeters / 1000).toFixed(0)} km` : `${targetMeters} m`;
      }
    }

    const scaleDiv = L.control({ position: 'bottomleft' });
    scaleDiv.onAdd = () => {
      const div = L.DomUtil.create('div', 'custom-scale');
      div.id = 'custom-scale';
      div.innerHTML = '<div class="bar"></div><span></span>';
      return div;
    };
    scaleDiv.addTo(map);

    map.on('zoom', updateCustomScale);
    updateCustomScale();


    L.tileLayer(`${TILE_BASE}/{z}/{x}/{y}.png`,{
      tileSize,minNativeZoom,maxNativeZoom,maxZoom:maxNativeZoom+2,
      noWrap:true,bounds:fullBounds,crossOrigin:true,referrerPolicy:"no-referrer",
      updateWhenIdle:false,updateWhenZooming:true,keepBuffer:3
    }).addTo(map);
    function applyBounds(){const ib=innerBounds(MARGIN);map.setMaxBounds(ib);map.panInsideBounds(ib,{animate:false});}
    map.fitBounds(innerBounds(MARGIN),{animate:false});applyBounds();map.on('zoomend resize',applyBounds);

    let TileMapInfo;
    const tileInfoReady = fetch(dataPath("TileMapInfo.json")).then(r=>{ if(!r.ok) throw new Error('TileMapInfo'); return r.json(); }).then(info => (TileMapInfo = info));
    const OX = parseFloat(QS.get('ox') ?? '0');
    const OY = parseFloat(QS.get('oy') ?? '0');
    const SX = parseFloat(QS.get('sx') ?? '1');
    const SY = parseFloat(QS.get('sy') ?? '1');
    
    const $search = document.getElementById("search");
    const $results = document.getElementById("results");
    const $siteTopBar = document.getElementById("siteTopBar");
    const $topBar = document.getElementById("topBar");
    const $searchPanelHost = document.querySelector(".search-panel");
    const $searchPanel = document.getElementById("searchPanel");
    const $searchFilters = document.getElementById("searchFilters");
    const $topActions = document.querySelector(".top-actions");
    const $btnLang = document.getElementById("btnLang");
    const $btnSettings = document.getElementById("btnSettings");
    const $panelSettings = document.getElementById("settingsPanel");
    const $panelResizers = document.querySelectorAll("[data-panel-resizer]");
    const $settingsPanelClose = document.getElementById("settingsPanelClose");
    const $btnSearch = document.getElementById("btnSearch");
    const $searchPanelClose = document.getElementById("searchPanelClose");
    const $analysisHUD = document.getElementById("analysisHUD");
    const $watermark = document.querySelector(".watermark");
    const SIDE_PANEL_WIDTH_KEY = "idf_side_panel_width";
    const SIDE_PANEL_MIN_WIDTH = 460;
    const COMPACT_UI_MAX_WIDTH = 1120;
    const COMPACT_UI_MAX_HEIGHT = 760;

    function isCompactViewportForOpenPanels(){
      return window.matchMedia("(max-width: 980px)").matches
        || window.innerWidth <= COMPACT_UI_MAX_WIDTH
        || window.innerHeight <= COMPACT_UI_MAX_HEIGHT;
    }
    function isPanelActuallyOpen(el){
      return !!el && getComputedStyle(el).display !== "none" && !el.classList.contains("is-closing");
    }
    function getActiveRightPanelWidth(){
      const dbusPanel = document.getElementById("dbusPanel");
      if (isPanelActuallyOpen(dbusPanel)) {
        return Math.round(dbusPanel.getBoundingClientRect().width);
      }
      const settingsPanel = document.getElementById("settingsPanel");
      if (isPanelActuallyOpen(settingsPanel)) {
        return Math.round(settingsPanel.getBoundingClientRect().width);
      }
      return 0;
    }
    function refreshHeaderMetrics(){
      const root = document.documentElement;
      const computed = getComputedStyle(root);
      const topOffset = parseFloat(computed.getPropertyValue("--topbar-top")) || 0;
      const gap = parseFloat(computed.getPropertyValue("--topbar-gap")) || 0;
      const fallbackSiteHeight = parseFloat(computed.getPropertyValue("--sitebar-height")) || 52;
      const fallbackMapHeight = parseFloat(computed.getPropertyValue("--mapbar-height")) || 56;
      const siteHeight = $siteTopBar ? Math.ceil($siteTopBar.getBoundingClientRect().height) : fallbackSiteHeight;
      const mapHeight = $topBar ? Math.ceil($topBar.getBoundingClientRect().height) : fallbackMapHeight;
      const siteHeaderHeight = topOffset + siteHeight;
      const stackHeight = siteHeaderHeight + gap + mapHeight;
      root.style.setProperty("--site-header-h", `${siteHeaderHeight}px`);
      root.style.setProperty("--header-stack-h", `${stackHeight}px`);
    }
    if ("ResizeObserver" in window) {
      const headerResizeObserver = new ResizeObserver(() => {
        refreshHeaderMetrics();
        if (typeof updateUiOverlays === "function") updateUiOverlays();
      });
      if ($siteTopBar) headerResizeObserver.observe($siteTopBar);
      if ($topBar) headerResizeObserver.observe($topBar);
    }
    refreshHeaderMetrics();
    window.addEventListener("load", () => {
      refreshHeaderMetrics();
      if (typeof updateUiOverlays === "function") updateUiOverlays();
    });

    function getSidePanelMaxWidth(){
      return Math.floor(window.innerWidth / 2);
    }
    function clampSidePanelWidth(width){
      const max = getSidePanelMaxWidth();
      if (max <= SIDE_PANEL_MIN_WIDTH) return SIDE_PANEL_MIN_WIDTH;
      const parsed = Number(width);
      const safe = Number.isFinite(parsed) ? parsed : SIDE_PANEL_MIN_WIDTH;
      return Math.max(SIDE_PANEL_MIN_WIDTH, Math.min(max, Math.round(safe)));
    }
    function setSidePanelWidth(width, { persist = true } = {}){
      const value = clampSidePanelWidth(width);
      document.documentElement.style.setProperty("--sidePanelW", `${value}px`);
      if (persist) localStorage.setItem(SIDE_PANEL_WIDTH_KEY, String(value));
      return value;
    }
    function syncSidePanelWidthFromStorage(){
      const saved = parseInt(localStorage.getItem(SIDE_PANEL_WIDTH_KEY) || "", 10);
      if (Number.isFinite(saved)) setSidePanelWidth(saved, { persist: false });
      else setSidePanelWidth(SIDE_PANEL_MIN_WIDTH, { persist: false });
    }
    function bindSidePanelResize(){
      if (!$panelResizers.length) return;
      const start = (event) => {
        if (window.matchMedia("(max-width: 980px)").matches) return;
        event.preventDefault();
        try { event.currentTarget.setPointerCapture(event.pointerId); } catch {}
        document.body.style.userSelect = "none";
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--sidePanelW"), 10);
        const frozenWidth = clampSidePanelWidth(Number.isFinite(currentWidth) ? currentWidth : SIDE_PANEL_MIN_WIDTH);
        document.documentElement.style.setProperty("--sidePanelDragShift", `${frozenWidth}px`);
        document.body.classList.add("side-panel-resizing");
        const move = (e) => {
          setSidePanelWidth(window.innerWidth - e.clientX);
        };
        const stop = () => {
          window.removeEventListener("pointermove", move);
          window.removeEventListener("pointerup", stop);
          window.removeEventListener("pointercancel", stop);
          document.body.style.userSelect = "";
          document.body.classList.remove("side-panel-resizing");
          document.documentElement.style.removeProperty("--sidePanelDragShift");
          if (typeof updateUiOverlays === "function") updateUiOverlays();
        };
        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", stop);
        window.addEventListener("pointercancel", stop);
      };
      $panelResizers.forEach(handle => handle.addEventListener("pointerdown", start));
      window.addEventListener("resize", () => {
        const current = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--sidePanelW"), 10);
        setSidePanelWidth(Number.isFinite(current) ? current : SIDE_PANEL_MIN_WIDTH, { persist: false });
        refreshHeaderMetrics();
        if (typeof updateUiOverlays === "function") updateUiOverlays();
      });
    }
    syncSidePanelWidthFromStorage();
    bindSidePanelResize();

    const BRAND_DISPLAY = { renault: 'Renault Trucks', daf: 'DAF', mercedes: 'Mercedes-Benz', volvo : 'Volvo Trucks' };
    function brandLabel(key){
      const k = String(key||'').trim().toLowerCase();
      if (!k) return '';
      if (BRAND_DISPLAY[k]) return BRAND_DISPLAY[k];
      return k.charAt(0).toUpperCase() + k.slice(1);
    }
    function brandsText(ov){
      const arr = Array.isArray(ov.Brands) ? ov.Brands : (ov.Brands ? [ov.Brands] : []);
      return arr.map(brandLabel).join(', ');
    }

    let _resIdx = -1;
    function highlightResult(i){
      const items=[...$results.querySelectorAll('.result-item')];
      items.forEach((el,idx)=> el.style.background = idx===i ? "#222222" : "");
    }
    $search.addEventListener('keydown', e=>{
      const items=[...$results.querySelectorAll('.result-item')];
      if(!items.length) return;
      if(e.key==="ArrowDown"){ e.preventDefault(); _resIdx=Math.min(_resIdx+1, items.length-1); highlightResult(_resIdx); }
      if(e.key==="ArrowUp"){ e.preventDefault(); _resIdx=Math.max(_resIdx-1, 0); highlightResult(_resIdx); }
      if(e.key==="Enter" && _resIdx>=0){ items[_resIdx].click(); }
    });

    function dealerBrandKeyFrom(ov){
      const arr = Array.isArray(ov.Brands) ? ov.Brands : (ov.Brands ? [ov.Brands] : []);
      const raw = String(arr[0] || "").toLowerCase().trim();
      if (!raw) return "";
      const MAP = { "renault trucks": "renault", "DAF": "daf", "mercedes-benz": "mercedes", "volvo trucks": "volvo" };
      const canonical = MAP[raw] || raw;
      return canonical.replace(/trucks?|camions?/g, "").replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
    }

    function addSectionBlock(typeKey, label){
      const head = document.createElement("div");
      head.className = "result-sechead";
        const labelMap = {
          "Ville": t("villes"),
          "Monument": t("emblematic"),
          "Atelier": t("repair_shops"),
          "Agence": t("agencies"),
          "Concessionnaire": t("dealers"),
          "Entreprise": t("companies")
        };
      head.textContent = labelMap[typeKey] || label;
      $results.appendChild(head);

      const body = document.createElement("div");
      body.className = "result-secbody";
      $results.appendChild(body);
      return body;
    }

    window.addEventListener('keydown', e=>{
      if(document.getElementById("linePreviewWrap")?.style.display!=="block") return;
      if(!currentSelectedKey) return;
      const route = (()=> {
        const [lu,ru]=currentSelectedKey.split(":");
        const line=DBUS_LINES.find(l=>l.uid===lu); if(!line) return null;
        return line.routes.find(r=>r.uid===ru);
      })();
      if(!route) return;

      const ids=(route.stops||[]).map(s=>s.uid);
      const idx = ids.indexOf(currentActiveStopId);
      if((e.key==="ArrowRight" || e.key==="ArrowDown") && idx>=0 && idx<ids.length-1){
        const nextId = ids[idx+1];
        const st=DBUS_STOPS.get(nextId);
        const nextMarker = dbusRouteLayers.get(currentSelectedKey)?.stops?.[idx+1];
        centerMarkerWithPreview(nextMarker, st?.latlng, { zoom: map.getZoom(), openPopup: true });
        setActiveStopById(nextId);
      }
      if((e.key==="ArrowLeft" || e.key==="ArrowUp") && idx>0){
        const prevId = ids[idx-1];
        const st=DBUS_STOPS.get(prevId);
        const prevMarker = dbusRouteLayers.get(currentSelectedKey)?.stops?.[idx-1];
        centerMarkerWithPreview(prevMarker, st?.latlng, { zoom: map.getZoom(), openPopup: true });
        setActiveStopById(prevId);
      }
    });


    function applyXY(x, y){ return { x: x * SX + OX, y: y * SY + OY }; }
    function toLatLng(X,Y){
      const px=(X-TileMapInfo.x1)/(TileMapInfo.x2-TileMapInfo.x1)*widthPx;
      const py=(Y-TileMapInfo.y1)/(TileMapInfo.y2-TileMapInfo.y1)*heightPx;
      return map.unproject([px,py],maxNativeZoom);
    }
    function fromLatLngToXY(latlng){
      const pt = map.project(latlng, maxNativeZoom);
      const X = (pt.x/widthPx) * (TileMapInfo.x2 - TileMapInfo.x1) + TileMapInfo.x1;
      const Y = (pt.y/heightPx) * (TileMapInfo.y2 - TileMapInfo.y1) + TileMapInfo.y1;
      return { X, Y };
    }
    const ZOOM_SIZED_IMAGE_OVERLAYS = [];
    let MAP_POI_OVERLAYS_HIDDEN = false;
    const OVERLAY_ZOOM_SCALE_MIN = 0.01;
    const OVERLAY_ZOOM_SCALE_MAX = 1;
    const OVERLAY_ZOOM_SCALE_STEP = 1;
    function getOverlayZoomScale(zoom = map.getZoom()){
      const delta = zoom - maxNativeZoom;
      const raw = Math.pow(1 / (1 + OVERLAY_ZOOM_SCALE_STEP), delta);
      return Math.max(OVERLAY_ZOOM_SCALE_MIN, Math.min(OVERLAY_ZOOM_SCALE_MAX, raw));
    }
    function applyZoomSizedOverlayBounds(rec){
      if (!rec?.overlay) return;
      const scale = getOverlayZoomScale();
      const halfW = (rec.baseWidth * scale) / 2;
      const halfH = (rec.baseHeight * scale) / 2;
      const topLeft = toLatLng(rec.centerX - halfW, rec.centerY + halfH);
      const bottomRight = toLatLng(rec.centerX + halfW, rec.centerY - halfH);
      rec.overlay.setBounds(L.latLngBounds(topLeft, bottomRight));
    }
    function registerZoomSizedImageOverlay(overlay, { centerX, centerY, width, height } = {}){
      if (!overlay) return overlay;
      const cX = Number(centerX), cY = Number(centerY);
      const w = Number(width), h = Number(height);
      if (!Number.isFinite(cX) || !Number.isFinite(cY) || !Number.isFinite(w) || !Number.isFinite(h) || w <= 0 || h <= 0) {
        return overlay;
      }
      const rec = { overlay, centerX: cX, centerY: cY, baseWidth: w, baseHeight: h };
      ZOOM_SIZED_IMAGE_OVERLAYS.push(rec);
      applyZoomSizedOverlayBounds(rec);
      if (MAP_POI_OVERLAYS_HIDDEN) {
        try { if (map.hasLayer(overlay)) map.removeLayer(overlay); } catch {}
      }
      return overlay;
    }
    function refreshZoomSizedImageOverlays(){
      ZOOM_SIZED_IMAGE_OVERLAYS.forEach(applyZoomSizedOverlayBounds);
    }
    function bringPoiOverlaysToFront(){
      ZOOM_SIZED_IMAGE_OVERLAYS.forEach(rec => {
        const overlay = rec?.overlay;
        if (!overlay || typeof overlay.bringToFront !== "function") return;
        try { overlay.bringToFront(); } catch {}
      });
    }
    map.on("zoomend", refreshZoomSizedImageOverlays);

    const transitScroll = document.querySelector("#linePreview .transit-scroll");
    const linePreviewStopsBox = document.querySelector("#linePreview .line-preview-stops");
    const linePreviewCueTop = document.querySelector("#linePreview .line-preview-scroll-cue.top");
    const linePreviewCueBottom = document.querySelector("#linePreview .line-preview-scroll-cue.bottom");
    function updateLinePreviewScrollCues(){
      if (!transitScroll || !linePreviewStopsBox) return;
      if (isLinePreviewHorizontal()) {
        linePreviewStopsBox.classList.remove("can-scroll-up", "can-scroll-down");
        return;
      }
      const maxScroll = Math.max(0, transitScroll.scrollHeight - transitScroll.clientHeight);
      const hasOverflow = maxScroll > 2;
      const canScrollUp = hasOverflow && transitScroll.scrollTop > 2;
      const canScrollDown = hasOverflow && transitScroll.scrollTop < (maxScroll - 2);
      linePreviewStopsBox.classList.toggle("can-scroll-up", canScrollUp);
      linePreviewStopsBox.classList.toggle("can-scroll-down", canScrollDown);
    }
    function scrollLinePreviewByStops(step){
      if (!transitScroll) return;
      const transit = document.getElementById("lpTransit");
      if (!transit) return;
      const stops = [...transit.querySelectorAll(".stop")];
      if (!stops.length) return;
      const dir = step < 0 ? -1 : 1;
      if (isLinePreviewHorizontal()) {
        const scrollLeft = transitScroll.scrollLeft;
        let currentIndex = stops.findIndex(stop => (stop.offsetLeft + stop.offsetWidth) > (scrollLeft + 2));
        if (currentIndex < 0) currentIndex = stops.length - 1;
        const targetIndex = Math.max(0, Math.min(stops.length - 1, currentIndex + dir));
        const targetLeft = Math.max(0, stops[targetIndex].offsetLeft - 8);
        transitScroll.scrollTo({ left: targetLeft, behavior: UI_ANIMATIONS ? "smooth" : "auto" });
        return;
      }
      const scrollTop = transitScroll.scrollTop;
      let currentIndex = stops.findIndex(stop => (stop.offsetTop + stop.offsetHeight) > (scrollTop + 2));
      if (currentIndex < 0) currentIndex = stops.length - 1;
      const targetIndex = Math.max(0, Math.min(stops.length - 1, currentIndex + dir));
      const targetTop = Math.max(0, stops[targetIndex].offsetTop - 2);
      transitScroll.scrollTo({ top: targetTop, behavior: UI_ANIMATIONS ? "smooth" : "auto" });
    }
    if (transitScroll) {
      transitScroll.addEventListener("wheel", function (e) {
        if (isLinePreviewHorizontal()) {
          const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
          if (Math.abs(delta) < 1) return;
          e.preventDefault();
          transitScroll.scrollLeft += delta;
          return;
        }
        if (Math.abs(e.deltaX) <= Math.abs(e.deltaY)) return;
        e.preventDefault();
        transitScroll.scrollTop += e.deltaX;
      }, { passive: false });
      transitScroll.addEventListener("scroll", updateLinePreviewScrollCues, { passive: true });
      window.addEventListener("resize", () => requestAnimationFrame(updateLinePreviewScrollCues));
      requestAnimationFrame(updateLinePreviewScrollCues);
    }
    linePreviewCueTop?.addEventListener("click", () => scrollLinePreviewByStops(-1));
    linePreviewCueBottom?.addEventListener("click", () => scrollLinePreviewByStops(1));
    linePreviewCueTop?.addEventListener("keydown", (event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        scrollLinePreviewByStops(-1);
      }
    });
    linePreviewCueBottom?.addEventListener("keydown", (event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        scrollLinePreviewByStops(1);
      }
    });

    const cityLayer=L.layerGroup().addTo(map);
    const cityMarkers=[],searchIndex=[];
    let selectedCityMarker = null;

    const $btnSaeivPanel = document.getElementById("btnSaeivPanel");
    const $btnAudioPanel = document.getElementById("btnAudioPanel");
    const $btnDbus = document.getElementById("btnDbus");
    const $panelDbus = document.getElementById("dbusPanel");
    const $dbusList = document.getElementById("dbusList");
    const $dbusLinesBox = document.querySelector("#dbusPanel .dbus-lines-box");
    const $dbusLinesContent = $dbusLinesBox ? $dbusLinesBox.querySelector(".dbus-content") : null;
    const $dbusRoutesBox = document.getElementById("dbusRoutesBox");
    const $dbusRoutesTitleLabel = document.getElementById("dbusRoutesTitleLabel");
    const $dbusRoutesClear = document.getElementById("dbusRoutesClear");
    const $dbusRoutesList = document.getElementById("dbusRoutesList");
    const $dbusDepartList = document.getElementById("dbusDepartList");
    const $dbusDepartActions = document.getElementById("dbusDepartActions");
    const $dbusDepartMapBtn = document.getElementById("dbusDepartMapBtn");
    const $selectedChip = document.getElementById("selectedChip");
    const $dbusStopPanel = document.getElementById("dbusStopPanel");
    const $dbusStopTitle = document.getElementById("dbusStopTitle");
    const $dbusStopList = document.getElementById("dbusStopList");
    const $dbusModeButtons = document.querySelectorAll(".dbus-sort-modes .dbus-mode-btn[data-mode]");
    const $dbusSchoolToggle = document.getElementById("dbusSchoolToggle");
    const $dbusFictiveToggle = document.getElementById("dbusFictiveToggle");
    const $settingsSchoolToggle = document.getElementById("settingsSchoolToggle");
    const $settingsFictiveToggle = document.getElementById("settingsFictiveToggle");
    const $dbusDepartIndicatorWrap = document.getElementById("dbusDepartIndicatorWrap");
    const $dbusDepartIndicatorLabel = document.getElementById("dbusDepartIndicatorLabel");
    const $dbusDepartIndicatorClose = document.getElementById("dbusDepartIndicatorClose");
    
    map.on('mousemove', (e) => {
      if (!$analysisHUD) return;
      try{
        const { X, Y } = fromLatLngToXY(e.latlng);
        $analysisHUD.textContent = `X: ${X.toFixed(2)}  Y: ${Y.toFixed(2)}`;
      }catch{}
    });

    function wikiTitleForCity(name){
      const m = /^Paris\s+(\d{1,2})(?:er|e|eme|ème|th|st|nd|rd)?$/i.exec(String(name||"").trim());
      if (m){
        const n = parseInt(m[1], 10);
        if (LANG === "en"){
          const suf = (n%10===1 && n%100!==11) ? "st" : (n%10===2 && n%100!==12) ? "nd" : (n%10===3 && n%100!==13) ? "rd" : "th";
          return `${n}${suf}_arrondissement_of_Paris`;
        } else {
          const suf = (n === 1) ? "er" : "e";
          return `${n}${suf}_arrondissement_de_Paris`;
        }
      }
      return String(name||"").replaceAll(" ", "_");
    }
    function normalizeParisArrondissement(title){
      const s0 = String(title || "");

      if (/\barrondissement_(de|of)_Paris\b/i.test(s0)) return s0;

      const s = s0
        .replace(/ /g, "_")
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");

      let m = /^(\d{1,2})(?:er|e|eme)?_arrondissement_(?:de|of)_paris$/.exec(s);
      if (m) {
        const n = parseInt(m[1], 10);
        if (LANG === "en") {
          const suf = (n%10===1 && n%100!==11) ? "st" : (n%10===2 && n%100!==12) ? "nd" : (n%10===3 && n%100!==13) ? "rd" : "th";
          return `${n}${suf}_arrondissement_of_Paris`;
        } else {
          const suf = (n === 1) ? "er" : "e";
          return `${n}${suf}_arrondissement_de_Paris`;
        }
      }

      m = /^paris_(\d{1,2})(?:er|e|eme)?$/.exec(s);
      if (m) {
        const n = parseInt(m[1], 10);
        if (LANG === "en") {
          const suf = (n%10===1 && n%100!==11) ? "st" : (n%10===2 && n%100!==12) ? "nd" : (n%10===3 && n%100!==13) ? "rd" : "th";
          return `${n}${suf}_arrondissement_of_Paris`;
        } else {
          const suf = (n === 1) ? "er" : "e";
          return `${n}${suf}_arrondissement_de_Paris`;
        }
      }

      m = /^paris_(\d{1,2})(?:er|e|eme)?_arrondissement$/.exec(s);
      if (m) {
        const n = parseInt(m[1], 10);
        if (LANG === "en") {
          const suf = (n%10===1 && n%100!==11) ? "st" : (n%10===2 && n%100!==12) ? "nd" : (n%10===3 && n%100!==13) ? "rd" : "th";
          return `${n}${suf}_arrondissement_of_Paris`;
        } else {
          const suf = (n === 1) ? "er" : "e";
          return `${n}${suf}_arrondissement_de_Paris`;
        }
      }

      return s0;
    }
    async function fetchWikiSummary(title){
      const url = (LANG==="en" ? "https://en.wikipedia.org/api/rest_v1/page/summary/" : "https://fr.wikipedia.org/api/rest_v1/page/summary/") + encodeURIComponent(title);
      const r = await fetch(url); if (!r.ok) throw new Error("wiki fetch"); return r.json();
    }

    function escapeHTML(s){
      return String(s)
        .replace(/&/g,"&amp;").replace(/</g,"&lt;")
        .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    async function copyTextToClipboard(text){
      const value = String(text || "");
      if (!value) return false;
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(value);
          return true;
        }
      } catch {}

      const ta = document.createElement("textarea");
      ta.value = value;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.top = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      let copied = false;
      try { copied = document.execCommand("copy"); } catch {}
      document.body.removeChild(ta);
      return copied;
    }

    const copyTooltipTimers = new WeakMap();
    function showCopyCommandTooltip(btn, copied){
      if (!btn) return;
      const successLabel = String(btn.dataset.copiedLabel || t("copy_command_copied"));
      const failureLabel = String(btn.dataset.copyFailedLabel || t("copy_command_failed"));
      btn.setAttribute("data-copied-label", copied ? successLabel : failureLabel);
      btn.classList.remove("show-copy-tooltip");
      void btn.offsetWidth;
      btn.classList.add("show-copy-tooltip");
      const prevTimer = copyTooltipTimers.get(btn);
      if (prevTimer) clearTimeout(prevTimer);
      const timer = setTimeout(() => {
        btn.classList.remove("show-copy-tooltip");
        copyTooltipTimers.delete(btn);
      }, 1300);
      copyTooltipTimers.set(btn, timer);
    }

    document.addEventListener("click", async (event) => {
      const btn = event.target.closest(".sp-copy-cmd");
      if (!btn) return;
      event.preventDefault();
      const cmd = String(btn.dataset.command || "").trim();
      if (!cmd) return;
      const copied = await copyTextToClipboard(cmd);
      showCopyCommandTooltip(btn, copied);
    });

    function trimAroundRER(s, mode ){
      const txt = String(s || "").trim();
      if (!/\bRER\b/i.test(txt)) return txt;
      if (mode === 'start'){
        const m = txt.match(/^(.*?)\s*[–—-]\s*RER\b/i);
        return (m && m[1]) ? m[1].trim() : txt;
      } else {
        const m = txt.match(/\bRER\b\s*[–—-]\s*(.+)$/i);
        return (m && m[1]) ? m[1].trim() : txt;
      }
    }

    function decodeHTML(s){
      const t = document.createElement('textarea');
      t.innerHTML = String(s ?? "");
      return t.value;
    }

    function withRERIcon(text, opts = {}){ const caseInsensitive = !!opts.caseInsensitive;
      const esc = escapeHTML(text ?? "");
      const flags = caseInsensitive ? "gi" : "g";
      return esc
        .replace(new RegExp("(?:\\s*[---]\\s*)?\\bRER\\b(?:\\s*[---]\\s*)?", flags),
                ' <span class="rer-ico" aria-label="RER"></span> ')
        .replace(new RegExp("(?:\\s*[---]\\s*)?\\bM[ée]tro\\b(?:\\s*[---]\\s*)?", flags),
                ' <span class="metro-ico" aria-label="Métro"></span> ')
        .replace(/\s{2,}/g, " ")
        .trim();
    }

    async function openCityPopup(cityObj, marker) {
      const latlng = marker.getLatLng();
      let rawTitle = normalizeParisArrondissement(wikiTitleForCity(cityObj.Name));
      const p = L.popup({ maxWidth: 380, autoPan: true })
        .setLatLng(latlng)
        .setContent(`<b>${cityObj.Name}</b><br><span class="spinner" aria-label="${t('loading')}"></span>`).openOn(map);
      try {
        const { title: finalTitle, data } = await (async function resolveWikiSummary(baseTitle){
          try {
            const d0 = await fetchWikiSummary(baseTitle);
            if (d0?.type !== "disambiguation") return { title: baseTitle, data: d0 };
          } catch {}
          const sufList = (LANG === "en")
            ? [",_Val-de-Marne", ",_Essonne", ",_Hauts-de-Seine", ",_Seine-Saint-Denis",
              ",_Val-d'Oise", ",_Seine-et-Marne", ",_Yvelines"]
            : ["_(Commune_franà§aise)", "_(Val-de-Marne)", "_(Essonne)", "_(Hauts-de-Seine)",
              "_(Seine-Saint-Denis)", "_(Val-d'Oise)", "_(Seine-et-Marne)", "_(Yvelines)"];

          for (const suf of sufList) {
            try {
              const d = await fetchWikiSummary(baseTitle + suf);
              if (d?.type !== "disambiguation") return { title: baseTitle + suf, data: d };
            } catch {}
          }
          return { title: baseTitle, data: null };
        })(rawTitle);

        const pageUrl = wikiBase() + finalTitle;
        const desc = data?.description || "";
        const img = data?.thumbnail?.source || "";
        const html = data ? `
          <div style="display:flex;gap:10px;align-items:flex-start">
            ${img ? `<img src="${img}" alt="" style="width:120px;height:90px;object-fit:cover;border-radius:8px;flex:0 0 auto">` : ``}
            <div style="min-width:0">
              <div style="font-weight:700;margin-bottom:4px">${cityObj.Name}</div>
              <div style="color:#8f8f8f;font-size:12px;margin-bottom:8px">${desc}</div>
              <a href="${pageUrl}" target="_blank" rel="noopener" style="color:#3aa0ff;text-decoration:underline">${t("see_wiki")}</a>
            </div>
          </div>` :
          `<div style="min-width:0">
            <div style="font-weight:700;margin-bottom:6px">${cityObj.Name}</div>
            <a href="${pageUrl}" target="_blank" rel="noopener" style="color:#3aa0ff;text-decoration:underline">${t("see_wiki")}</a>
          </div>`;
        p.setContent(html);
      } catch {}
    }

    tileInfoReady.then(()=> fetch(dataPath("Cities.json"))).then(r=>r.json()).then(cities=>{
      cities.forEach(city=>{
        const icon=L.divIcon({className:"",html:`<span class="city-label">${city.Name}</span>`,iconSize:[0,0]});
        const m=L.marker(toLatLng(city.X,city.Y),{icon,interactive:true,bubblingMouseEvents:true}).addTo(cityLayer);
        m.on("click", ()=> openCityPopup(city, m));
        cityMarkers.push(m);
        searchIndex.push({type:"Ville",name:city.Name||t("city"),city:"",center:m.getLatLng(),open:()=>openCityPopup(city, m)});
      });
      updateCityLabels();
    }).catch(err=>console.error("Erreur chargement Cities.json",err));

    function updateCityLabels(){
      const zMin=map.getMinZoom(),zMax=map.getMaxZoom(),z=map.getZoom(),SMALL=8,LARGE=20,t=(z-zMin)/Math.max(1,(zMax-zMin)),px=Math.round(SMALL+t*(LARGE-SMALL));
      cityMarkers.forEach(m=>{const el=m.getElement();if(!el)return;const span=el.querySelector(".city-label");if(!span)return;span.style.fontSize=px+"px";span.style.opacity=(t<0.05)?0.8:1;});
    }
    map.on("zoomend",updateCityLabels);

    const DEDUPE_MIN_PX_BASE = 100;
    const MAP_ICON_UNIFORM_SIZE = 25;
    const _placedByIcon = new Map();
    function _isTooClose(iconId, latlng, minPx){
      const pt = map.project(latlng, maxNativeZoom);
      const list = _placedByIcon.get(iconId) || [];
      for(const p of list){ const dx = pt.x - p.x, dy = pt.y - p.y; if (Math.hypot(dx, dy) < minPx) return true; }
      list.push({x: pt.x, y: pt.y}); _placedByIcon.set(iconId, list); return false;
    }

    function bindPopupWithImage(layer, html){
      layer.bindPopup(html);
      layer.on('popupopen', (e) => {
        const el = e.popup.getElement();
        const img = el && el.querySelector('img[data-autosize]');
        if (img && !img.complete) {
          img.addEventListener('load', () => {
            try { e.popup.update(); } catch {}
          }, { once: true });
        }
      });
    }
    function openLayerPopup(layer, latlng){
      if (!layer || typeof layer.openPopup !== "function") return;
      try { map.closePopup(); } catch {}
      layer.openPopup(latlng);
    }
    function setPopupContentWithImage(layer, html){
      if (layer.getPopup()) {
        layer.setPopupContent(html);
      } else {
        bindPopupWithImage(layer, html);
      }
    }

    function iconLabel(iconId){
      const map = {
        "gas_ico": t("icon_gas"),
        "bus_ico": t("icon_bus_station"),
        "service_ico": t("icon_repair_shop"),
        "garage_large_ico": t("icon_garage"),
        "recruitment_ico": t("icon_recruitment_agency"),
        "dealer_ico": t("icon_dealer"),
        "border_ico": t("icon_border_control"),
        "toll_ico": t("icon_toll"),
        "parking_ico": t("icon_parking")
      };
      return map[iconId];
    }

    tileInfoReady
      .then(() => fetch(dataPath("CentreCommerciaux.json")))
      .then(r => r.ok ? r.json() : Promise.reject("CentreCommerciaux.json"))
      .then(malls => {
        malls.forEach(ov => {
          const width = MAP_ICON_UNIFORM_SIZE;
          const height = MAP_ICON_UNIFORM_SIZE;

          const centerLL = toLatLng(ov.X, ov.Y);
          const topLeft = toLatLng(ov.X - (width/2), ov.Y + (height/2));
          const bottomRight = toLatLng(ov.X + (width/2), ov.Y - (height/2));
          const bounds = L.latLngBounds(topLeft, bottomRight);

          const key = "overlay_centrecom";
          const minPx = Math.max(DEDUPE_MIN_PX_BASE, Math.max(width, height) * 0.75);
          if (_isTooClose(key, centerLL, minPx)) return;

          const overlay = registerZoomSizedImageOverlay(
            L.imageOverlay(overlayPath("overlay_centrecom.png"), bounds, { interactive: true, bubblingMouseEvents: false }).addTo(map),
            { centerX: ov.X, centerY: ov.Y, width, height }
          );
          const popup = L.popup({ maxWidth: 420, autoPan: true });
          overlay.bindPopup(popup);

          overlay.on('popupopen', (e) => {
            const el = e.popup.getElement();
            const img = el && el.querySelector('img[data-autosize]');
            if (img && !img.complete) {
              img.addEventListener('load', () => { try { e.popup.update(); } catch {} }, { once:true });
            }
          });

          const rawName = String(ov.Name || "").trim();
          const city = String(ov.City || "").trim();
          const wikiKey = String(ov.wiki || "").trim();

          overlay.on("click", async () => {
            const displayName = `${t("mall")} ${rawName}`.trim();
            const p = overlay.getPopup();
            p.setLatLng(bounds.getCenter());

            if (!wikiKey) {
              p.setContent(`<div style="min-width:0"><b>${escapeHTML(displayName)}</b>${city?`<br><i>${escapeHTML(city)}</i>`:""}</div>`);
              openLayerPopup(overlay);
              return;
            }

            p.setContent(`<div style="min-width:0"><b>${escapeHTML(displayName)}</b><br><span class="spinner" aria-label="${t('loading')}"></span></div>`);
            openLayerPopup(overlay);

            try {
              const baseTitle = wikiTitleFrom(wikiKey);
              const { title: finalTitle, data } = await (async function resolveWikiSummary(title){
                try {
                  const d0 = await fetchWikiSummary(title);
                  if (d0?.type !== "disambiguation") return { title, data: d0 };
                } catch {}
                for (const suf of [
                  "_(Paris)", "_(Île-de-France)", "_(Hauts-de-Seine)", "_(Seine-Saint-Denis)",
                  "_(Val-de-Marne)", "_(Yvelines)", "_(Val-d'Oise)", "_(Essonne)", "_(Seine-et-Marne)",
                  "_(Centre_commercial)", "_(Centre_commercial_en_France)"
                ]) {
                  try {
                    const d = await fetchWikiSummary(title + suf);
                    if (d?.type !== "disambiguation") return { title: title + suf, data: d };
                  } catch {}
                }
                return { title, data: null };
              })(baseTitle);

              const pageUrlFromAPI = data?.content_urls?.desktop?.page || null;
              const hasPage = !!pageUrlFromAPI;
              const desc = data?.description || "";
              const img = data?.thumbnail?.source || "";

              const linkHTML = hasPage
                ? `<a href="${pageUrlFromAPI}" target="_blank" rel="noopener" style="color:#3aa0ff;text-decoration:underline">${t("see_wiki")}</a>`
                : "";

              const html = data ? `
                <div style="display:flex;gap:10px;align-items:flex-start">
                  ${img ? `<img data-autosize src="${img}" alt="" style="width:120px;height:90px;object-fit:cover;border-radius:8px;flex:0 0 auto">` : ``}
                  <div style="min-width:0">
                    <div style="font-weight:700;margin-bottom:4px">${escapeHTML(displayName)}</div>
                    ${city ? `<div style="color:#8f8f8f;font-size:12px;margin-bottom:6px">${escapeHTML(city)}</div>` : ``}
                    <div style="color:#8f8f8f;font-size:12px;margin-bottom:8px">${escapeHTML(desc)}</div>
                    ${linkHTML}
                  </div>
                </div>` :
                `<div style="min-width:0">
                  <div style="font-weight:700;margin-bottom:6px">${escapeHTML(displayName)}</div>
                  ${city ? `<div style="color:#8f8f8f;font-size:12px;margin-bottom:8px">${escapeHTML(city)}</div>` : ``}
                </div>`;


              p.setContent(html);
            } catch {
              p.setContent(`<div style="min-width:0"><b>${escapeHTML(displayName)}</b>${city?`<br><i>${escapeHTML(city)}</i>`:""}</div>`);
            }
          });

          searchIndex.push({
            type: "Centre commercial",
            name: rawName,
            city,
            center: bounds.getCenter(),
            open: () => { overlay.fire('click'); },
            logo: overlayPath("overlay_centrecom.png"),
            fallbackLogo: overlayPath("overlay_centrecom.png")
          });
        });
      })
      .catch(err => console.error("CentreCommerciaux.json error:", err));

    tileInfoReady.then(()=> fetch(dataPath("Overlays.json"))).then(r=>r.json()).then(overlays=>{
      overlays.forEach(ov=>{
        const width = MAP_ICON_UNIFORM_SIZE;
        const height = MAP_ICON_UNIFORM_SIZE;
        const centerLL = toLatLng(ov.X, ov.Y);

        if(!ov.IconId) return;
        if(
          ov.IconId.startsWith("bus_") && ov.IconId !== "bus_ico" ||
          ov.IconId.startsWith("uk_")  ||
          ov.IconId.startsWith("fr_")  ||
          ov.IconId.startsWith("b_")   ||
          ov.IconId.startsWith("bg_")  ||
          ov.IconId.startsWith("train_ico")  ||
          ov.IconId.startsWith("port_overlay")  ||
          ov.IconId.startsWith("d334p")  ||
          ov.IconId.startsWith("viewpoint")
        ){ return; }

        const isCompany = (ov.Type === "Company");

        if (!isCompany) {
          const key = ov.IconId || ov.Type || "__misc";
          const minPx = Math.max(DEDUPE_MIN_PX_BASE, Math.max(width||0, height||0) * 0.75);
          if (_isTooClose(key, centerLL, minPx)) return;
        }

        const topLeft = toLatLng(ov.X - (width/2), ov.Y + (height/2));
        const bottomRight = toLatLng(ov.X + (width/2), ov.Y - (height/2));
        const bounds = L.latLngBounds(topLeft, bottomRight);

       if (ov.Type==="Company"){
        const companyCenterX = ov.X + 10;
        const companyCenterY = ov.Y - 10;
        const compTopLeft = toLatLng(companyCenterX - (width / 2), companyCenterY + (height / 2));
        const compBottomRight = toLatLng(companyCenterX + (width / 2), companyCenterY - (height / 2));
        const compBounds=L.latLngBounds(compTopLeft,compBottomRight);
        const overlay = registerZoomSizedImageOverlay(
          L.imageOverlay(overlayPath("button.png"),compBounds,{interactive:true,bubblingMouseEvents:false}).addTo(map),
          { centerX: companyCenterX, centerY: companyCenterY, width, height }
        );

        const logoPath = overlayPath(`${ov.IconId}.png`);

        bindPopupWithImage(overlay, `
          <div style="text-align:center">
            <img data-autosize src="${logoPath}"
                style="width:168px;height:auto;display:block;margin:0 auto 10px;object-fit:contain"/>
            <b>${escapeHTML(ov.Name)}</b><br/><i>${escapeHTML(ov.City||"")}</i>
          </div>
        `);

        searchIndex.push({
          type:"Entreprise",
          name:ov.Name||t("company"),
          city:ov.City||"",
          center:compBounds.getCenter(),
          open:()=>{ openLayerPopup(overlay, compBounds.getCenter()); },
          logo:logoPath
        });
      } else if (ov.Type === "TruckDealer" || ov.IconId === "dealer_ico") {
            const overlay = registerZoomSizedImageOverlay(
              L.imageOverlay(overlayPath(`${ov.IconId}.png`), bounds, { interactive: true, bubblingMouseEvents: false }).addTo(map),
              { centerX: ov.X, centerY: ov.Y, width, height }
            );
            const btxt = brandsText(ov) || '—';

            const brandKey = dealerBrandKeyFrom(ov);
            const brandLogo = brandKey ? overlayPath(`dealer_${brandKey}.png`) : overlayPath("dealer_ico.png");

            const updateDealerPopup = () => {
              const html = `
                <div style="text-align:center">
                  <img data-autosize src="${brandLogo}"
                      style="width:168px;height:auto;display:block;margin:0 auto 10px;object-fit:contain"/>
                  <b>${escapeHTML(`${t("dealer")} ${btxt}`.trim())}</b><br/><i>${escapeHTML(ov.City || "")}</i>
                </div>
              `;
              setPopupContentWithImage(overlay, html);
            };

            const openDealerPopup = () => {
              updateDealerPopup();
              openLayerPopup(overlay, bounds.getCenter());
            };
            overlay.on("click", openDealerPopup);
            registerI18nLayer(overlay, updateDealerPopup);

            searchIndex.push({
              type: "Concessionnaire",
              name: `${btxt}`.trim(),         
              brand: btxt,                   
              city: ov.City || "",
              center: bounds.getCenter(),
              open: openDealerPopup,
              logo: brandLogo,
              fallbackLogo: overlayPath("dealer_ico.png")
            });
          
        } else {
          const overlay = registerZoomSizedImageOverlay(
            L.imageOverlay(overlayPath(`${ov.IconId}.png`), bounds, { interactive: true, bubblingMouseEvents: false }).addTo(map),
            { centerX: ov.X, centerY: ov.Y, width, height }
          );
          const updateIconPopup = () => {
            const label = iconLabel(ov.IconId) || ov.Name || ov.Type || t("place");
            if (overlay.getPopup()) {
              overlay.setPopupContent(`<b>${escapeHTML(label)}</b>`);
            } else {
              overlay.bindPopup(`<b>${escapeHTML(label)}</b>`);
            }
          };
          const openIconPopup = () => {
            updateIconPopup();
            openLayerPopup(overlay, bounds.getCenter());
          };
          overlay.on("click", openIconPopup);
          registerI18nLayer(overlay, updateIconPopup);

          const typeTag =
            ov.IconId === "service_ico"       ? "Atelier" :
            ov.IconId === "recruitment_ico"   ? "Agence"  :
            ov.IconId === "garage_large_ico"  ? "Garage"  :
            null;

          if (typeTag) {
            const logoPath =
              ov.IconId === "service_ico"      ? overlayPath("service_ico.png") :
              ov.IconId === "recruitment_ico"  ? overlayPath("recruitment_ico.png") :
              ov.IconId === "garage_large_ico" ? overlayPath("garage_large_ico.png") :
              overlayPath(`${ov.IconId}.png`);

            const keywordName =
              typeTag === "Atelier" ? `Atelier de réparation ${ov.City || ""}` :
              typeTag === "Agence"  ? `Agence de recrutement ${ov.City || ""}` :
                          `Garage ${ov.City || ""}`;

            searchIndex.push({
              type: typeTag,               
              name: keywordName.trim(),    
              city: ov.City || "",
              center: bounds.getCenter(),
              open: openIconPopup,
              logo: logoPath,
              fallbackLogo: logoPath
            });
          }
        }
      });
    });

    function wikiTitleFrom(urlOrTitle){
      const s = String(urlOrTitle||"").trim();
      try{
        const u = new URL(s);
        const m = /\/wiki\/(.+)$/.exec(u.pathname);
        return m ? decodeURIComponent(m[1]) : s.replaceAll(" ", "_");
      }catch{
        return s.replaceAll(" ", "_");
      }
    }


  tileInfoReady
  .then(() => fetch(dataPath("Monuments.json")))
  .then(r => r.ok ? r.json() : Promise.reject("Monuments.json"))
  .then(monuments => {
    monuments.forEach(ov => {
      const width = MAP_ICON_UNIFORM_SIZE;
      const height = MAP_ICON_UNIFORM_SIZE;

      const centerLL = toLatLng(ov.X, ov.Y);
      const topLeft = toLatLng(ov.X - (width/2), ov.Y + (height/2));
      const bottomRight = toLatLng(ov.X + (width/2), ov.Y - (height/2));
      const bounds = L.latLngBounds(topLeft, bottomRight);

      const key = "overlay_monument";
      const minPx = Math.max(DEDUPE_MIN_PX_BASE, Math.max(width, height) * 0.75);
      if (_isTooClose(key, centerLL, minPx)) return;

      const overlay = registerZoomSizedImageOverlay(
        L.imageOverlay(overlayPath("overlay_monument.png"), bounds, { interactive: true, bubblingMouseEvents: false }).addTo(map),
        { centerX: ov.X, centerY: ov.Y, width, height }
      );
      const popup = L.popup({ maxWidth: 420, autoPan: true });
      overlay.bindPopup(popup);

      overlay.on('popupopen', (e) => {
        const el = e.popup.getElement();
        const img = el && el.querySelector('img[data-autosize]');
        if (img && !img.complete) {
          img.addEventListener('load', () => { try { e.popup.update(); } catch {} }, { once:true });
        }
      });

      const name = String(ov.Name || "").trim();
      const city = String(ov.City || "").trim();
      const wikiTitle = wikiTitleFrom(ov.wiki || ov.IconId || name);

      overlay.on("click", async () => {
        const p = overlay.getPopup();
        p.setLatLng(bounds.getCenter());
        p.setContent(`<div style="min-width:0"><b>${escapeHTML(name)}</b><br><span class="spinner" aria-label="${t('loading')}"></span></div>`);
        openLayerPopup(overlay);

        try {
          const { title: finalTitle, data } = await (async function resolveWikiSummary(baseTitle){
            try {
              const d0 = await fetchWikiSummary(baseTitle);
              if (d0?.type !== "disambiguation") return { title: baseTitle, data: d0 };
            } catch {}
            for (const suf of [
              "_(Paris)", "_(Île-de-France)", "_(Hauts-de-Seine)", "_(Seine-Saint-Denis)",
              "_(Val-de-Marne)", "_(Yvelines)", "_(Val-d'Oise)", "_(Essonne)", "_(Seine-et-Marne)",
              "_(Monument)"
            ]) {
              try {
                const d = await fetchWikiSummary(baseTitle + suf);
                if (d?.type !== "disambiguation") return { title: baseTitle + suf, data: d };
              } catch {}
            }
            return { title: baseTitle, data: null };
          })(wikiTitle);

          const pageUrl = wikiBase() + finalTitle;
          const desc = data?.description || "";
          const img = data?.thumbnail?.source || "";

          const html = data ? `
            <div style="display:flex;gap:10px;align-items:flex-start">
              ${img ? `<img data-autosize src="${img}" alt="" style="width:120px;height:90px;object-fit:cover;border-radius:8px;flex:0 0 auto">` : ``}
              <div style="min-width:0">
                <div style="font-weight:700;margin-bottom:4px">${escapeHTML(name)}</div>
                ${city ? `<div style="color:#8f8f8f;font-size:12px;margin-bottom:6px">${escapeHTML(city)}</div>` : ``}
                <div style="color:#8f8f8f;font-size:12px;margin-bottom:8px">${escapeHTML(desc)}</div>
                <a href="${pageUrl}" target="_blank" rel="noopener" style="color:#3aa0ff;text-decoration:underline">${t("see_wiki")}</a>
              </div>
            </div>` :
            `<div style="min-width:0">
              <div style="font-weight:700;margin-bottom:6px">${escapeHTML(name)}</div>
              ${city ? `<div style="color:#8f8f8f;font-size:12px;margin-bottom:8px">${escapeHTML(city)}</div>` : ``}
              <a href="${pageUrl}" target="_blank" rel="noopener" style="color:#3aa0ff;text-decoration:underline">${t("see_wiki")}</a>
            </div>`;

          p.setContent(html);
        } catch {
          p.setContent(`<div style="min-width:0"><b>${escapeHTML(name)}</b>${city?`<br><i>${escapeHTML(city)}</i>`:""}</div>`);
        }
      });

      searchIndex.push({
        type: "Monument",
        name,
        city,
        center: bounds.getCenter(),
        open: () => { 
          const p = overlay.getPopup();
          if (p) { p.setLatLng(bounds.getCenter()); }
          overlay.fire('click');
        },
        logo: overlayPath("overlay_monument.png"),
        fallbackLogo: overlayPath("overlay_monument.png")
      });
    });
  })
  .catch(err => console.error("Monuments.json error:", err));


      
    function applyInitialView() {
      const qs = new URLSearchParams(location.search);
      const x = parseFloat(qs.get("x"));
      const y = parseFloat(qs.get("y"));
      const z = parseFloat(qs.get("z"));

      if (Number.isFinite(x) && Number.isFinite(y)) {
        const ll = toLatLng(x, y);

        const ib = innerBounds(MARGIN);
        const clamped = L.latLng(
          Math.max(Math.min(ll.lat, ib.getNorth()), ib.getSouth()),
          Math.max(Math.min(ll.lng, ib.getEast()),  ib.getWest())
        );

        const targetZoom = Number.isFinite(z)
          ? Math.max(map.getMinZoom(), Math.min(map.getMaxZoom(), z))
          : map.getZoom();

        map.setView(clamped, targetZoom, { animate: false });
      }
    }

    tileInfoReady.then(() => { applyInitialView(); });

    const routeAnimHandles = new Map();
    function animatePolyline(poly, { speed = 1.2, dash = "14 10", reverse = false } = {}) {
      const apply = (path) => {
        path.style.strokeDasharray = dash;
        let offset = 0, raf = 0;
        const tick = () => { offset = (offset + speed) % 10000; path.style.strokeDashoffset = reverse ? String(-offset) : String(offset); raf = requestAnimationFrame(tick); };
        tick();
        return () => { cancelAnimationFrame(raf); path.style.strokeDasharray = ""; path.style.strokeDashoffset = ""; };
      };
      let stopFn = null;
      if (poly._path) { stopFn = apply(poly._path); }
      else { poly.once("add", () => { if (poly._path) stopFn = apply(poly._path); }); }
      return { stop: () => { try { stopFn && stopFn(); } catch {} } };
    }
    function startLineAnim(key, poly) { stopLineAnim(key); const h = animatePolyline(poly, { speed: 0.1, dash: "30 10", reverse: true }); routeAnimHandles.set(key, h); }
    function stopLineAnim(key) { const h = routeAnimHandles.get(key); if (h) { h.stop(); routeAnimHandles.delete(key); } }

    const dbusRoot = `${DBUS_BASE}/IDF MAP`;
    const DBUS_FIS_ROOT = `${MAP_FILES_ROOT}/dbus_fis`;
    const DBUS_FIS_DOSSIERS_ROOT = `${DBUS_FIS_ROOT}/dossiers`;
    const DBUS_FIS_GLOBAL_ROOT = `${DBUS_FIS_ROOT}/global`;
    const dbusLayers = L.layerGroup().addTo(map);
    const dbusStopsLayer = L.layerGroup().addTo(map);
    const dbusDepartLayers = L.layerGroup();
    const dbusRouteLayers = new Map();
    const DBUS_NAV_MAX_SNAP_DISTANCE = 450;
    const DBUS_NAV_STOP_CANDIDATES = 6;
    let DBUS_NAV_GRAPH = null;
    let DBUS_NAV_BRIDGES = [];
    const dbusNavNodesByStopId = new Map();
    const dbusNavPathCache = new Map();
    const DEV_GRAPH_STATE = {
      enabled: false,
      edgeLayer: null,
      nodeLayer: null,
      nodePoints: [],
      incomingByNode: new Map(),
      clickBound: false
    };
    let linePreviewAudioCheckToken = 0;
    let dbusFisRootLineFolderTokensPromise = null;
    let DBUS_FIS_INDEX = null;
    const LINE_PREVIEW_AUDIO_STATE = { folderPath: "", stopNames: [], currentIndex: 0, enabled: false, volume: 1, voiceStyles: [], selectedVoiceIndex: 0, departureClipName: "Départ" };
    const LINE_PREVIEW_AUDIO_GLOBAL_STATE = { folders: [], selectedFolderPath: "", loadPromise: null, profile: "ratp", typeTokens: [] };
    const LINE_PREVIEW_AUDIO_PLAYBACK = {
      token: 0,
      audio: null,
      isPlaying: false,
      lockNavigation: false,
      volumeMultiplier: 1,
      audioCtx: null,
      sourceNode: null,
      sourceAudio: null,
      gainNode: null
    };
    const LINE_PREVIEW_AUDIO_EXTENSION = { nonce: "", checked: false, detected: false, version: "" };
    const LINE_PREVIEW_AUDIO_DRAG = { initialized: false };
    const LINE_PREVIEW_AUDIO_POPUP = { win: null, syncTimer: null, htmlCache: "", keepOnTop: true, lastFocusAt: 0, bounds: null, boundsLoaded: false };
    const LINE_PREVIEW_AUDIO_POPUP_BOUNDS_STORAGE_KEY = "idf_map_audio_popup_bounds_v1";
    const SAEIV_ASPECT_RATIO = 16 / 9;
    const SAEIV_QUERY_PARAMS = new URLSearchParams(location.search);
    const SAEIV_DEV_MODE = SAEIV_QUERY_PARAMS.has("dev");
    const SAEIV_FEATURE_ALLOWED = SAEIV_DEV_MODE;
    const SAEIV_CHANNEL_NAME = "idf_map_saeiv_v1";
    const SAEIV_PANEL_STATE = {
      sourceId: `map-${Math.random().toString(36).slice(2, 10)}-${Date.now().toString(36)}`,
      win: null,
      closeWatchTimer: null,
      pipCloseHandler: null,
      usingDocumentPiP: false,
      channel: null,
      channelBound: false,
      lastStateKey: "",
      lastAction: ""
    };
    const DBUS_MODES = { LINES: "lines", LENGTH: "length", DEPARTS: "departures" };
    let currentDbusMode = DBUS_MODES.LINES;
    let dbusDisplayMode = "normal";
    let showSchoolLines = false;
    let showFictiveLines = false;
    let renderDbusLinesList = null;
    const DBUS_DEPART_MERGE_PX = 100;
    let dbusDepartGroups = [];
    let dbusDepartMarkers = new Map();
    let dbusDepartNameIndex = new Map();
    let selectedDepartMarker = null;
    let dbusDepartFilterKey = `${showSchoolLines}-${showFictiveLines}`;
    let dbusDepartPreviewActive = false;

    async function fetchXml(path){
      const res = await fetch(path);
      if(!res.ok) throw new Error("XML load failed: "+path);
      const txt = await res.text();
      const parser = new DOMParser();
      return parser.parseFromString(txt, "text/xml");
    }
    function ensureTrailingSlash(path){
      return /\/$/.test(String(path || "")) ? String(path) : `${String(path || "")}/`;
    }
    function encodePathSegment(segment){
      const cleaned = String(segment || "").replace(/[\\/]+/g, " ").trim();
      if (!cleaned) return "";
      return encodeURIComponent(cleaned);
    }
    function joinEncodedPath(basePath, ...segments){
      let out = String(basePath || "").replace(/\/+$/g, "");
      segments.forEach((segment) => {
        const encoded = encodePathSegment(segment);
        if (!encoded) return;
        out += `/${encoded}`;
      });
      return out;
    }
    function parseDirEntryFromHref(rawHref, baseUrl){
      const href = String(rawHref || "").trim();
      if (!href || href.startsWith("#") || href.startsWith("?")) return null;
      let resolved;
      try {
        resolved = new URL(href, baseUrl);
      } catch {
        return null;
      }
      if (resolved.origin !== baseUrl.origin) return null;
      const basePath = String(baseUrl.pathname || "");
      const targetPath = String(resolved.pathname || "");
      if (!targetPath.startsWith(basePath)) return null;
      const isDirectory = /\/$/.test(href) || /\/$/.test(targetPath);
      const rawName = targetPath.replace(/\/+$/g, "").split("/").pop() || "";
      let name = rawName;
      try { name = decodeURIComponent(rawName); } catch {}
      name = String(name || "").trim();
      if (!name || name === "." || name === "..") return null;
      return { name, isDirectory };
    }
    function parseDirEntriesFromHtml(html, basePath){
      const text = String(html || "");
      const baseUrl = new URL(ensureTrailingSlash(basePath), location.href);
      const out = [];
      const seen = new Set();
      const push = (entry) => {
        if (!entry) return;
        const key = `${entry.isDirectory ? "d" : "f"}:${entry.name.toLowerCase()}`;
        if (seen.has(key)) return;
        seen.add(key);
        out.push(entry);
      };
      try {
        const doc = new DOMParser().parseFromString(text, "text/html");
        doc.querySelectorAll("a[href]").forEach((anchor) => {
          push(parseDirEntryFromHref(anchor.getAttribute("href"), baseUrl));
        });
      } catch {}
      if (!out.length) {
        const hrefMatches = text.matchAll(/href=["']([^"']+)["']/gi);
        for (const match of hrefMatches) {
          push(parseDirEntryFromHref(match[1], baseUrl));
        }
      }
      return out;
    }
    async function loadDbusFisIndex(){
      if (DBUS_FIS_INDEX) return DBUS_FIS_INDEX;

      try {
        const res = await fetch("./map_files/dbus_fis_index.json", {
          cache: "no-store"
        });
        if (!res.ok) {
          console.warn("FIS index missing");
          DBUS_FIS_INDEX = {};
          return DBUS_FIS_INDEX;
        }
        const data = await res.json();
        DBUS_FIS_INDEX = (data && typeof data === "object") ? data : {};
      } catch {
        DBUS_FIS_INDEX = {};
      }
      return DBUS_FIS_INDEX;
    }
    function decodePathSegmentSafe(value){
      const raw = String(value || "");
      try { return decodeURIComponent(raw); } catch { return raw; }
    }
    async function listDirectoryEntriesFromIndex(path){
      const index = await loadDbusFisIndex();

      // normalise le path
      const clean = String(path || "")
        .replace(/^\.?\//, "")
        .replace(/^map_files\/dbus_fis\/?/, "")
        .replace(/\/+$/, "");

      if (!clean) {
        // root dbus_fis
        return Object.keys(index).map(name => ({
          name,
          isDirectory:true
        }));
      }

      const parts = clean.split("/").map(decodePathSegmentSafe).filter(Boolean);
      let node = index;

      for (const p of parts){
        if (!node || typeof node !== "object" || !Object.prototype.hasOwnProperty.call(node, p)) return [];
        node = node[p];
      }

      if (!node || typeof node !== "object") return [];
      const out = [];

      for (const k in node){
        if (!Object.prototype.hasOwnProperty.call(node, k)) continue;
        if (k === "_files") continue;
        out.push({ name:k, isDirectory:true });
      }

      if (Array.isArray(node._files)){
        node._files.forEach(f=>{
          out.push({ name:f + ".mp3", isDirectory:false });
        });
      }

      return out;
    }
    function shouldUseJsonDirectoryManifests(){
      // Prod: idf-map.fr / github pages / tout hébergement statique sans listing
      const host = String(location.hostname || "").toLowerCase();
      if (host === "localhost" || host === "127.0.0.1") return false;

      // si tu utilises un serveur local sur LAN, adapte si besoin :
      // if (host.endsWith(".local")) return false;

      return true;
    }
    async function listDirectoryEntries(path){
      const dirPath = ensureTrailingSlash(String(path || ""));

      // En prod (GitHub Pages / hebergement statique), evite les fetch de dossiers
      // qui generent des 404 visibles dans la console reseau.
      if (shouldUseJsonDirectoryManifests()) {
        return listDirectoryEntriesFromIndex(path);
      }

      // Ancien systeme: listing dossier (local/dev)
      try {
        const res = await fetch(dirPath, { cache: "no-store" });
        if (res.ok) {
          const html = await res.text();
          const htmlEntries = parseDirEntriesFromHtml(html, dirPath);
          if (htmlEntries.length) return htmlEntries;
        }
      } catch {}

      // Fallback index JSON si le listing local ne retourne rien
      return listDirectoryEntriesFromIndex(path);
    }
    async function listDirectorySubfolders(path){
      const entries = await listDirectoryEntries(path);
      const out = [];
      const seen = new Set();
      const add = (name) => {
        const n = String(name || "").trim();
        if (!n) return;
        const key = n.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        out.push(n);
      };

      entries.forEach((entry) => {
        if (entry?.isDirectory) add(entry.name);
      });

      // En prod (manifests): on considere isDirectory fiable -> pas de probes
      if (shouldUseJsonDirectoryManifests()) return out;

      // En local/dev: on garde tes probes d'origine
      const ambiguous = entries.filter((entry) => {
        if (!entry || entry.isDirectory) return false;
        const name = String(entry.name || "").trim();
        if (!name) return false;
        return !/\.[a-z0-9]{1,8}$/i.test(name);
      });

      await Promise.all(ambiguous.map(async (entry) => {
        const probePath = joinEncodedPath(path, entry.name);
        const probeEntries = await listDirectoryEntries(probePath);
        if (probeEntries.length > 0) add(entry.name);
      }));

      return out;
    }
    async function listDirectoryMp3BaseNames(path){
      const entries = await listDirectoryEntries(path);
      return entries
        .filter((entry) => !entry.isDirectory && /\.mp3$/i.test(entry.name))
        .map((entry) => entry.name.replace(/\.mp3$/i, ""));
    }
    function normalizeAudioNameToken(value){
      return String(value || "")
        .replace(/\.mp3$/i, "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/&/g, " et ")
        .replace(/[’`´']/g, "")
        .replace(/[‐‑‒–—−-]/g, " ")
        .replace(/\u00A0/g, " ")
        .replace(/[^a-z0-9\s]/gi, " ")
        .replace(/\s+/g, " ")
        .trim()
        .toLowerCase();
    }
    function getDbusFisLineFolderName(line, route){
      const parsed = String(parseRouteName(route?.name || "").lineNumber || "").trim();
      const fallback = String(getLineNumber(line, route) || line?.number || "").trim();
      const raw = parsed || fallback;
      return raw
        .replace(/\s*\([^)]*\)\s*/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }
    function getDbusFisLineCode(line, route){
      const parsed = String(parseRouteName(route?.name || "").lineNumber || "").trim();
      const fallback = String(getLineNumber(line, route) || line?.number || "").trim();
      const raw = (parsed || fallback)
        .replace(/\s+/g, "")
        .replace(/[^0-9a-z_\-]/gi, "")
        .trim();
      return raw;
    }
    function getLinePreviewAudioDepartureClipCandidates(line, route){
      const rawLineLabel = String(getDbusFisLineFolderName(line, route) || "").replace(/\s+/g, " ").trim();
      const lineCode = getDbusFisLineCode(line, route);
      const routeName = String(route?.name || "").trim();
      const parsedLineNumber = String(parseRouteName(routeName || "").lineNumber || "").trim();
      const fallbackLineNumber = String(getLineNumber(line, route) || line?.number || "").trim();
      const compactToken = (value) => String(value || "").replace(/\s+/g, "").trim();
      const lineToken = parsedLineNumber || fallbackLineNumber;
      const candidates = [];
      const pushSpecial = (value, prefix = "") => {
        const suffix = compactToken(value);
        if (!suffix) return;
        candidates.push(`Départ_${prefix}${suffix}`);
        candidates.push(`Depart_${prefix}${suffix}`);
      };
      const expressLike =
        isExpress(line) ||
        isExpressNumber(parsedLineNumber) ||
        isExpressNumber(fallbackLineNumber) ||
        /^express\b/i.test(routeName);
      if (expressLike) {
        const expressMatch =
          String(lineToken || "").match(/^express\s*([0-9a-z]+)/i) ||
          routeName.match(/\bexpress\s*([0-9a-z]+)/i) ||
          String(fallbackLineNumber || "").match(/^express\s*([0-9a-z]+)/i);
        let expressSuffix = String(expressMatch?.[1] || "").trim();
        if (!expressSuffix && /^[0-9a-z]+$/i.test(compactToken(lineToken))) {
          expressSuffix = compactToken(lineToken);
        }
        if (expressSuffix) pushSpecial(expressSuffix, "Express");
      }
      const noctLike = isNoctilien2(lineToken) || isNoctilien2(fallbackLineNumber) || isNoctilien2(line);
      if (noctLike) {
        const rawNoct =
          (isNoctilien2(lineToken) ? lineToken : "") ||
          (isNoctilien2(fallbackLineNumber) ? fallbackLineNumber : "") ||
          String(line?.number || "");
        const noctMatch = String(rawNoct || "").trim().toUpperCase().match(/^N\s*([0-9A-Z]+)/);
        const noctSuffix = String(noctMatch?.[1] || "").trim();
        if (noctSuffix) pushSpecial(`N${noctSuffix}`);
      }
      const titusMatch =
        String(lineToken || "").match(/^titus\s*([0-9a-z]+)/i) ||
        String(fallbackLineNumber || "").match(/^titus\s*([0-9a-z]+)/i) ||
        routeName.match(/\btitus\s*([0-9a-z]+)/i) ||
        String(line?.number || "").match(/^titus\s*([0-9a-z]+)/i);
      if (titusMatch?.[1]) {
        pushSpecial(String(titusMatch[1] || "").trim(), "Titus");
      }
      if (rawLineLabel) {
        candidates.push(`Départ_${rawLineLabel}`);
        candidates.push(`Depart_${rawLineLabel}`);
      }
      if (lineCode) {
        candidates.push(`Départ_${lineCode}`);
        candidates.push(`Depart_${lineCode}`);
      }
      candidates.push("Départ");
      candidates.push("Depart");
      const out = [];
      const seen = new Set();
      candidates.forEach((name) => {
        const text = String(name || "").trim();
        if (!text) return;
        const key = normalizeAudioNameToken(text);
        if (!key || seen.has(key)) return;
        seen.add(key);
        out.push(text);
      });
      return out;
    }
    function resolveLinePreviewAudioDepartureClipName(files, line, route){
      const names = Array.isArray(files) ? files : [];
      const byToken = new Map();
      names.forEach((name) => {
        const token = normalizeAudioNameToken(name);
        if (!token || byToken.has(token)) return;
        byToken.set(token, String(name || "").trim());
      });
      const candidates = getLinePreviewAudioDepartureClipCandidates(line, route);
      for (const candidate of candidates) {
        const token = normalizeAudioNameToken(candidate);
        if (!token) continue;
        const exact = byToken.get(token);
        if (exact) return exact;
      }
      return "";
    }
    function escapeRegExp(value){
      return String(value || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function getDbusFisFallbackStyleName(folderName, lineFolder){
      const raw = String(folderName || "").trim();
      if (!raw) return ".";
      const line = String(lineFolder || "").trim();
      if (!line) return raw;
      const lineEscaped = escapeRegExp(line);
      const trimmed = raw
        .replace(new RegExp(`^${lineEscaped}\\s*(?:[/\\\\>|:_-]+\\s*|\\s+)`, "i"), "")
        .trim();
      return trimmed || raw;
    }
    function isDbusFisFlattenedLineFolderMatch(folderName, lineFolder){
      const folderToken = normalizeAudioNameToken(folderName);
      const lineToken = normalizeAudioNameToken(lineFolder);
      if (!folderToken || !lineToken) return false;
      if (folderToken === lineToken) return false;
      return folderToken.startsWith(`${lineToken} `);
    }
    async function listDbusFisFallbackLineFolders(lineFolder){
      const entries = await listDirectoryEntries(DBUS_FIS_ROOT);
      const out = [];
      const seen = new Set();
      entries.forEach((entry) => {
        const name = String(entry?.name || "").trim();
        if (!name) return;
        const isLikelyFolder = !!entry?.isDirectory || !/\.[a-z0-9]{1,8}$/i.test(name);
        if (!isLikelyFolder) return;
        if (!isDbusFisFlattenedLineFolderMatch(name, lineFolder)) return;
        const path = ensureTrailingSlash(joinEncodedPath(DBUS_FIS_ROOT, name));
        const key = path.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        out.push({
          name,
          path,
          styleName: getDbusFisFallbackStyleName(name, lineFolder)
        });
      });
      return out;
    }
    async function listDbusFisRouteStyleFoldersFromDossiers(){
      const rootPath = ensureTrailingSlash(DBUS_FIS_DOSSIERS_ROOT);
      const folders = [];
      const rootClips = await listDirectoryMp3BaseNames(rootPath);
      if (rootClips.length) {
        folders.push({ name: ".", path: rootPath, files: rootClips });
      }
      const subfolders = await listDirectorySubfolders(rootPath);
      for (const subfolderName of subfolders) {
        const folderPath = ensureTrailingSlash(joinEncodedPath(rootPath, subfolderName));
        const files = await listDirectoryMp3BaseNames(folderPath);
        if (!files.length) continue;
        folders.push({ name: subfolderName, path: folderPath, files });
      }
      if (folders.length > 1) {
        const rootFirst = folders[0]?.name === "." ? folders.shift() : null;
        folders.sort((a, b) => String(a?.name || "").localeCompare(String(b?.name || ""), "fr", { sensitivity: "base" }));
        if (rootFirst) folders.unshift(rootFirst);
      }
      return folders;
    }
    async function getDbusFisRootLineFolderTokens(){
      if (dbusFisRootLineFolderTokensPromise) return dbusFisRootLineFolderTokensPromise;
      dbusFisRootLineFolderTokensPromise = (async () => {
        const entries = await listDirectoryEntries(DBUS_FIS_ROOT);
        const tokens = new Set();
        entries.forEach((entry) => {
          const name = String(entry?.name || "").trim();
          if (!name) return;
          const isLikelyFolder = !!entry?.isDirectory || !/\.[a-z0-9]{1,8}$/i.test(name);
          if (!isLikelyFolder) return;
          const token = normalizeAudioNameToken(name);
          if (token) tokens.add(token);
        });
        return tokens;
      })();
      return dbusFisRootLineFolderTokensPromise;
    }
    async function hasDbusFisLineFolder(lineFolderName){
      const token = normalizeAudioNameToken(lineFolderName);
      if (!token) return false;
      const known = await getDbusFisRootLineFolderTokens();
      // If root listing is unavailable/empty, do not block downstream checks.
      if (!known.size) return true;
      return known.has(token);
    }
    function collectRequiredAudioTokensForRoute(route, { includeDeparture = true, departureLabel = "Départ" } = {}){
      const required = new Set([
        normalizeAudioNameToken("Terminus")
      ]);
      if (includeDeparture) {
        const departureToken = normalizeAudioNameToken(departureLabel);
        if (departureToken) required.add(departureToken);
      }
      (route?.stops || []).forEach((stopRef) => {
        const stopName = String(DBUS_STOPS.get(stopRef?.uid)?.name || "").trim();
        if (!stopName) return;
        const cleanStopName = stripProvisoire(stopName);
        const token = normalizeAudioNameToken(cleanStopName || stopName);
        if (token) required.add(token);
      });
      return required;
    }
    function collectRequiredAudioTokenLabelsForRoute(route, { includeDeparture = true, departureLabel = "Départ" } = {}){
      const labelsByToken = new Map();
      const pushLabel = (label) => {
        const text = String(label || "").trim();
        if (!text) return;
        const token = normalizeAudioNameToken(text);
        if (!token || labelsByToken.has(token)) return;
        labelsByToken.set(token, text);
      };
      if (includeDeparture) pushLabel(departureLabel);
      pushLabel("Terminus");
      (route?.stops || []).forEach((stopRef) => {
        const stopName = String(DBUS_STOPS.get(stopRef?.uid)?.name || "").trim();
        if (!stopName) return;
        const cleanStopName = stripProvisoire(stopName);
        pushLabel(cleanStopName || stopName);
      });
      return labelsByToken;
    }
    function collectRouteAudioStopNames(route){
      const out = [];
      const seen = new Set();
      (route?.stops || []).forEach((stopRef) => {
        const raw = String(DBUS_STOPS.get(stopRef?.uid)?.name || "").trim();
        if (!raw) return;
        const label = stripProvisoire(raw) || raw;
        const key = normalizeAudioNameToken(label);
        if (!key || seen.has(key)) return;
        seen.add(key);
        out.push(label);
      });
      return out;
    }
    function linePreviewAudioClipUrl(folderPath, clipName){
      return joinEncodedPath(folderPath, `${String(clipName || "").trim()}.mp3`);
    }
    function getLinePreviewAudioPanel(){
      return document.getElementById("lpAudioPanel");
    }
    function getLinePreviewAudioPopupWindow(){
      const win = LINE_PREVIEW_AUDIO_POPUP.win;
      if (!win || win.closed) return null;
      return win;
    }
    function bringLinePreviewAudioPopupToFront({ force = false } = {}){
      if (!LINE_PREVIEW_AUDIO_POPUP.keepOnTop) return false;
      const win = getLinePreviewAudioPopupWindow();
      if (!win) return false;
      if (!isLinePreviewAudioPanelOpen()) return false;
      const now = Date.now();
      const lastFocusAt = Number(LINE_PREVIEW_AUDIO_POPUP.lastFocusAt) || 0;
      if (!force && (now - lastFocusAt) < 700) return false;
      LINE_PREVIEW_AUDIO_POPUP.lastFocusAt = now;
      try {
        win.focus();
        return true;
      } catch {}
      return false;
    }
    function normalizeLinePreviewAudioPopupBounds(bounds){
      const width = Math.round(Number(bounds?.width) || 0);
      const height = Math.round(Number(bounds?.height) || 0);
      const left = Math.round(Number(bounds?.left) || 0);
      const top = Math.round(Number(bounds?.top) || 0);
      if (!Number.isFinite(width) || !Number.isFinite(height) || !Number.isFinite(left) || !Number.isFinite(top)) return null;
      if (width < 200 || height < 200) return null;
      const screenLeft = Math.round(Number(bounds?.screenLeft) || 0);
      const screenTop = Math.round(Number(bounds?.screenTop) || 0);
      const screenWidth = Math.round(Number(bounds?.screenWidth) || 0);
      const screenHeight = Math.round(Number(bounds?.screenHeight) || 0);
      return {
        width,
        height,
        left,
        top,
        screenLeft: Number.isFinite(screenLeft) ? screenLeft : 0,
        screenTop: Number.isFinite(screenTop) ? screenTop : 0,
        screenWidth: Number.isFinite(screenWidth) && screenWidth > 0 ? screenWidth : 0,
        screenHeight: Number.isFinite(screenHeight) && screenHeight > 0 ? screenHeight : 0
      };
    }
    function loadLinePreviewAudioPopupBounds(){
      if (LINE_PREVIEW_AUDIO_POPUP.boundsLoaded) return LINE_PREVIEW_AUDIO_POPUP.bounds;
      LINE_PREVIEW_AUDIO_POPUP.boundsLoaded = true;
      LINE_PREVIEW_AUDIO_POPUP.bounds = null;
      try {
        const raw = localStorage.getItem(LINE_PREVIEW_AUDIO_POPUP_BOUNDS_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        const normalized = normalizeLinePreviewAudioPopupBounds(parsed);
        if (!normalized) return null;
        LINE_PREVIEW_AUDIO_POPUP.bounds = normalized;
      } catch {}
      return LINE_PREVIEW_AUDIO_POPUP.bounds;
    }
    function saveLinePreviewAudioPopupBounds(bounds){
      const normalized = normalizeLinePreviewAudioPopupBounds(bounds);
      if (!normalized) return;
      LINE_PREVIEW_AUDIO_POPUP.boundsLoaded = true;
      LINE_PREVIEW_AUDIO_POPUP.bounds = normalized;
      try {
        localStorage.setItem(LINE_PREVIEW_AUDIO_POPUP_BOUNDS_STORAGE_KEY, JSON.stringify(normalized));
      } catch {}
    }
    function captureLinePreviewAudioPopupWindowBounds(win){
      if (!win || win.closed) return null;
      const width = Math.round(Number(win.outerWidth) || Number(win.innerWidth) || 0);
      const height = Math.round(Number(win.outerHeight) || Number(win.innerHeight) || 0);
      const left = Math.round(Number(win.screenX) || Number(win.screenLeft) || 0);
      const top = Math.round(Number(win.screenY) || Number(win.screenTop) || 0);
      const popupScreen = win.screen || {};
      const screenLeft = Math.round(Number(popupScreen.availLeft) || Number(popupScreen.left) || 0);
      const screenTop = Math.round(Number(popupScreen.availTop) || Number(popupScreen.top) || 0);
      const screenWidth = Math.round(Number(popupScreen.availWidth) || Number(popupScreen.width) || 0);
      const screenHeight = Math.round(Number(popupScreen.availHeight) || Number(popupScreen.height) || 0);
      return normalizeLinePreviewAudioPopupBounds({
        width,
        height,
        left,
        top,
        screenLeft,
        screenTop,
        screenWidth,
        screenHeight
      });
    }
    function persistLinePreviewAudioPopupWindowBounds(win){
      const bounds = captureLinePreviewAudioPopupWindowBounds(win);
      if (!bounds) return;
      saveLinePreviewAudioPopupBounds(bounds);
    }
    function stopLinePreviewAudioPopupSync(){
      if (!LINE_PREVIEW_AUDIO_POPUP.syncTimer) return;
      clearInterval(LINE_PREVIEW_AUDIO_POPUP.syncTimer);
      LINE_PREVIEW_AUDIO_POPUP.syncTimer = null;
    }
    function setLinePreviewAudioMainPanelHidden(hidden){
      const panel = getLinePreviewAudioPanel();
      if (!panel) return;
      if (hidden) {
        if (panel.dataset.popupHostHidden === "1") return;
        panel.dataset.popupHostHidden = "1";
        panel.dataset.popupPrevVisibility = panel.style.visibility || "";
        panel.dataset.popupPrevPointerEvents = panel.style.pointerEvents || "";
        panel.dataset.popupPrevLeft = panel.style.left || "";
        panel.dataset.popupPrevTop = panel.style.top || "";
        panel.style.visibility = "hidden";
        panel.style.pointerEvents = "none";
        panel.style.left = "-10000px";
        panel.style.top = "-10000px";
        return;
      }
      if (panel.dataset.popupHostHidden !== "1") return;
      panel.style.visibility = panel.dataset.popupPrevVisibility || "";
      panel.style.pointerEvents = panel.dataset.popupPrevPointerEvents || "";
      panel.style.left = panel.dataset.popupPrevLeft || "";
      panel.style.top = panel.dataset.popupPrevTop || "";
      delete panel.dataset.popupHostHidden;
      delete panel.dataset.popupPrevVisibility;
      delete panel.dataset.popupPrevPointerEvents;
      delete panel.dataset.popupPrevLeft;
      delete panel.dataset.popupPrevTop;
    }
    function buildLinePreviewAudioPopupShell(win){
      const doc = win.document;
      doc.open();
      doc.write('<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"></head><body><div id="lpAudioPopupRoot"></div>');
      doc.close();
      doc.title = "Systeme annonces sonores";
      doc.documentElement.setAttribute("lang", String(document.documentElement.getAttribute("lang") || "fr"));

      const base = doc.createElement("base");
      base.href = String(location.href || "");
      doc.head.appendChild(base);

      const sourceStyles = Array.from(document.querySelectorAll('link[rel="stylesheet"], style'));
      sourceStyles.forEach((node) => {
        try {
          doc.head.appendChild(node.cloneNode(true));
        } catch {}
      });

      const localStyle = doc.createElement("style");
      localStyle.textContent = [
        "html, body { margin: 0; padding: 0; min-height: 100%; background: #0b0b0b; }",
        "#lpAudioPopupRoot { padding: 8px; box-sizing: border-box; }",
        "#lpAudioPopupRoot #lpAudioPanel {",
        "  position: static !important;",
        "  left: auto !important;",
        "  top: auto !important;",
        "  right: auto !important;",
        "  bottom: auto !important;",
        "  width: min(720px, calc(100vw - 16px)) !important;",
        "  max-width: calc(100vw - 16px) !important;",
        "  margin: 0 auto !important;",
        "  display: block !important;",
        "  z-index: 1 !important;",
        "}"
      ].join("\n");
      doc.head.appendChild(localStyle);
    }
    function dispatchInputEvent(target, type){
      if (!target) return;
      target.dispatchEvent(new Event(type, { bubbles: true }));
    }
    function forwardLinePreviewAudioPopupClick(control){
      if (!control) return;
      if (control.closest("#lpAudioGlobalButtons")) {
        const parent = control.parentElement;
        const popupButtons = parent ? Array.from(parent.querySelectorAll(".line-preview-audio-btn")) : [];
        const idx = popupButtons.indexOf(control);
        if (idx < 0) return;
        const mainButtons = Array.from(document.querySelectorAll("#lpAudioGlobalButtons .line-preview-audio-btn"));
        const mainBtn = mainButtons[idx];
        if (mainBtn) mainBtn.click();
        return;
      }
      const id = String(control.id || "").trim();
      if (!id) return;
      const mainControl = document.getElementById(id);
      if (!mainControl) return;
      if (typeof mainControl.click === "function") mainControl.click();
    }
    function forwardLinePreviewAudioPopupInput(control, type){
      if (!control) return;
      const id = String(control.id || "").trim();
      if (!id) return;
      if (!["lpAudioStyleSelect", "lpAudioGlobalFolderSelect", "lpAudioVolumeRange"].includes(id)) return;
      const mainControl = document.getElementById(id);
      if (!mainControl) return;
      mainControl.value = String(control.value || "");
      dispatchInputEvent(mainControl, type);
    }
    function bindLinePreviewAudioPopupEvents(win){
      const doc = win.document;
      if (!doc || !doc.documentElement) return;
      if (doc.documentElement.dataset.audioPopupBound === "1") return;
      doc.documentElement.dataset.audioPopupBound = "1";

      doc.addEventListener("click", (event) => {
        const target = event.target;
        const control = target && typeof target.closest === "function" ? target.closest("button, a") : null;
        if (!control) return;
        event.preventDefault();
        forwardLinePreviewAudioPopupClick(control);
      });

      doc.addEventListener("change", (event) => {
        const control = event.target;
        if (!(control instanceof win.HTMLElement)) return;
        forwardLinePreviewAudioPopupInput(control, "change");
      });

      doc.addEventListener("input", (event) => {
        const control = event.target;
        if (!(control instanceof win.HTMLElement)) return;
        forwardLinePreviewAudioPopupInput(control, "input");
      });
      if (!win.__lpAudioBoundsBound) {
        win.__lpAudioBoundsBound = true;
        win.addEventListener("beforeunload", () => {
          persistLinePreviewAudioPopupWindowBounds(win);
        });
        win.addEventListener("pagehide", () => {
          persistLinePreviewAudioPopupWindowBounds(win);
        });
      }
      if (!win.__lpAudioKeepOnTopBound) {
        win.__lpAudioKeepOnTopBound = true;
        win.addEventListener("blur", () => {
          if (!LINE_PREVIEW_AUDIO_POPUP.keepOnTop) return;
          setTimeout(() => {
            bringLinePreviewAudioPopupToFront({ force: true });
          }, 40);
        });
      }
    }
    function syncLinePreviewAudioPopupFromMain(){
      const win = getLinePreviewAudioPopupWindow();
      if (!win) return;
      const panel = getLinePreviewAudioPanel();
      if (!panel) return;

      let popupDoc = null;
      try { popupDoc = win.document; } catch { return; }
      if (!popupDoc || !popupDoc.body) return;

      const root = popupDoc.getElementById("lpAudioPopupRoot");
      if (!root) return;
      let popupPanel = popupDoc.getElementById("lpAudioPanel");
      if (!popupPanel) {
        popupPanel = panel.cloneNode(true);
        root.innerHTML = "";
        root.appendChild(popupPanel);
        LINE_PREVIEW_AUDIO_POPUP.htmlCache = "";
      }

      const nextHtml = String(panel.innerHTML || "");
      if (LINE_PREVIEW_AUDIO_POPUP.htmlCache !== nextHtml) {
        popupPanel.innerHTML = nextHtml;
        LINE_PREVIEW_AUDIO_POPUP.htmlCache = nextHtml;
      }
      popupPanel.className = panel.className;
      popupPanel.classList.add("is-open");
      popupPanel.setAttribute("aria-hidden", "false");
      popupPanel.style.display = "block";
      popupPanel.style.visibility = "visible";
      popupPanel.style.pointerEvents = "auto";

      ["lpAudioStyleSelect", "lpAudioGlobalFolderSelect", "lpAudioVolumeRange"].forEach((id) => {
        const source = document.getElementById(id);
        const target = popupDoc.getElementById(id);
        if (!source || !target) return;
        const value = String(source.value || "");
        if (String(target.value || "") !== value) target.value = value;
      });
    }
    function teardownLinePreviewAudioPopup(options = {}){
      const closeWindow = !!options.closeWindow;
      stopLinePreviewAudioPopupSync();
      const win = getLinePreviewAudioPopupWindow();
      persistLinePreviewAudioPopupWindowBounds(win);
      LINE_PREVIEW_AUDIO_POPUP.htmlCache = "";
      LINE_PREVIEW_AUDIO_POPUP.lastFocusAt = 0;
      LINE_PREVIEW_AUDIO_POPUP.win = null;
      setLinePreviewAudioMainPanelHidden(false);
      if (closeWindow && win) {
        try { win.close(); } catch {}
      }
    }
    function closeLinePreviewAudioPopupForHostShutdown(){
      stopLinePreviewAudioPopupSync();
      const win = getLinePreviewAudioPopupWindow();
      persistLinePreviewAudioPopupWindowBounds(win);
      LINE_PREVIEW_AUDIO_POPUP.win = null;
      LINE_PREVIEW_AUDIO_POPUP.htmlCache = "";
      LINE_PREVIEW_AUDIO_POPUP.lastFocusAt = 0;
      if (win) {
        try { win.close(); } catch {}
      }
    }
    function startLinePreviewAudioPopupSync(){
      stopLinePreviewAudioPopupSync();
      LINE_PREVIEW_AUDIO_POPUP.syncTimer = setInterval(() => {
        const win = getLinePreviewAudioPopupWindow();
        if (!win) {
          closeLinePreviewAudioPanel({ stopPlayback: false });
          return;
        }
        if (!isLinePreviewAudioPanelOpen()) {
          teardownLinePreviewAudioPopup({ closeWindow: true });
          return;
        }
        syncLinePreviewAudioPopupFromMain();
        bringLinePreviewAudioPopupToFront();
      }, 160);
    }
    function getLinePreviewAudioPopupWindowMetrics(){
      const screenObj = window.screen || {};
      const availableWidth = Math.max(320, Number(screenObj.availWidth) || Number(window.innerWidth) || 1280);
      const availableHeight = Math.max(320, Number(screenObj.availHeight) || Number(window.innerHeight) || 900);
      const widthCap = Math.max(280, availableWidth - 24);
      const heightCap = Math.max(280, availableHeight - 24);
      const stored = loadLinePreviewAudioPopupBounds();
      const defaultWidth = Math.min(widthCap, Math.max(320, Math.min(980, Math.round(availableWidth * 0.45))));
      const defaultHeight = Math.min(heightCap, Math.max(420, Math.min(1040, Math.round(availableHeight * 0.88))));
      const width = stored
        ? Math.min(widthCap, Math.max(320, Math.round(Number(stored.width) || defaultWidth)))
        : defaultWidth;
      const height = stored
        ? Math.min(heightCap, Math.max(420, Math.round(Number(stored.height) || defaultHeight)))
        : defaultHeight;
      const storedLeft = Math.round(Number(stored?.left));
      const storedTop = Math.round(Number(stored?.top));
      const left = Number.isFinite(storedLeft)
        ? Math.max(-100000, Math.min(100000, storedLeft))
        : Math.round((availableWidth - width) / 2);
      const top = Number.isFinite(storedTop)
        ? Math.max(-100000, Math.min(100000, storedTop))
        : Math.round((availableHeight - height) / 2);
      return { width, height, left, top };
    }
    function applyLinePreviewAudioPopupWindowMetrics(win, { recenter = false } = {}){
      if (!win || win.closed) return;
      const metrics = getLinePreviewAudioPopupWindowMetrics();
      try { win.resizeTo(metrics.width, metrics.height); } catch {}
      if (recenter) {
        try { win.moveTo(metrics.left, metrics.top); } catch {}
      }
    }
    function openLinePreviewAudioPopup(){
      const existing = getLinePreviewAudioPopupWindow();
      if (existing) {
        applyLinePreviewAudioPopupWindowMetrics(existing);
        setLinePreviewAudioMainPanelHidden(true);
        syncLinePreviewAudioPopupFromMain();
        startLinePreviewAudioPopupSync();
        bringLinePreviewAudioPopupToFront({ force: true });
        return true;
      }
      const metrics = getLinePreviewAudioPopupWindowMetrics();
      const features = [
        "popup=yes",
        "resizable=yes",
        "scrollbars=yes",
        `width=${metrics.width}`,
        `height=${metrics.height}`,
        `left=${metrics.left}`,
        `top=${metrics.top}`
      ].join(",");
      const win = window.open("", "idfMapAudioPanelPopup", features);
      if (!win) return false;
      LINE_PREVIEW_AUDIO_POPUP.win = win;
      buildLinePreviewAudioPopupShell(win);
      bindLinePreviewAudioPopupEvents(win);
      applyLinePreviewAudioPopupWindowMetrics(win, { recenter: true });
      setLinePreviewAudioMainPanelHidden(true);
      syncLinePreviewAudioPopupFromMain();
      startLinePreviewAudioPopupSync();
      bringLinePreviewAudioPopupToFront({ force: true });
      return true;
    }
    window.addEventListener("resize", () => {
      const win = getLinePreviewAudioPopupWindow();
      if (!win) return;
      applyLinePreviewAudioPopupWindowMetrics(win);
    });
    window.addEventListener("focus", () => {
      bringLinePreviewAudioPopupToFront({ force: true });
    });
    window.addEventListener("pointerdown", () => {
      bringLinePreviewAudioPopupToFront();
    });
    window.addEventListener("keydown", () => {
      bringLinePreviewAudioPopupToFront();
    });
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState !== "visible") return;
      bringLinePreviewAudioPopupToFront({ force: true });
    });
    window.addEventListener("beforeunload", closeLinePreviewAudioPopupForHostShutdown);
    window.addEventListener("pagehide", closeLinePreviewAudioPopupForHostShutdown);
    function parseLinePreviewAudioStyleMeta(rawName){
      const name = String(rawName || "").trim();
      if (!name || name === ".") {
        return { displayName: t("audio_voice_style_default"), voiceBy: "" };
      }
      const byParts = [];
      name.replace(/\[([^\]]+)\]/g, (_match, group) => {
        const text = String(group || "").trim();
        if (text) byParts.push(text);
        return _match;
      });
      const displayName = name
        .replace(/\[[^\]]*\]/g, " ")
        .replace(/\s+/g, " ")
        .trim() || t("audio_voice_style_default");
      return { displayName, voiceBy: byParts.join(" / ") };
    }
    function getLinePreviewAudioExtensionLink(key){
      const offsite = window.SITE_OFFSITE_LINKS && typeof window.SITE_OFFSITE_LINKS === "object"
        ? window.SITE_OFFSITE_LINKS
        : {};
      const href = String(offsite[key] || "").trim();
      return href || "#";
    }
    function isLinePreviewAudioExtensionBrowserSupported(){
      const ua = String(navigator.userAgent || "");
      if (!ua) return false;
      const isMobile = /Android|iPhone|iPad|iPod|Windows Phone|Mobile/i.test(ua);
      if (isMobile) return false;
      const hasChromeOrChromium = /\b(Chrome|Chromium)\//i.test(ua);
      const hasUnsupportedChromiumFork = /\b(Edg|OPR|Vivaldi|Brave|YaBrowser|SamsungBrowser|DuckDuckGo|Whale|QQBrowser|UCBrowser)\b/i.test(ua);
      const isCriOS = /\bCriOS\b/i.test(ua);
      const isFirefox = /\b(Firefox|FxiOS)\b/i.test(ua);
      const isSafariOnly = /\bSafari\b/i.test(ua) && !hasChromeOrChromium && !isCriOS;
      const brands = Array.isArray(navigator.userAgentData?.brands)
        ? navigator.userAgentData.brands.map((b) => String(b?.brand || "").toLowerCase())
        : [];
      const hasChromeBrand = brands.some((b) => b.includes("google chrome") || b.includes("chromium"));
      return (hasChromeBrand || (hasChromeOrChromium && !hasUnsupportedChromiumFork))
        && !isCriOS
        && !isFirefox
        && !isSafariOnly;
    }
    const LINE_PREVIEW_AUDIO_EXTENSION_BROWSER_SUPPORTED = isLinePreviewAudioExtensionBrowserSupported();
    function updateLinePreviewAudioExtensionLinks(){
      const installLink = document.getElementById("lpAudioExtInstallLink");
      if (installLink) installLink.href = getLinePreviewAudioExtensionLink("extension_install");
      const keysLink = document.getElementById("lpAudioExtKeysLink");
      if (keysLink) keysLink.href = getLinePreviewAudioExtensionLink("extension_keys");
    }
    function closeLinePreviewAudioExtensionGuideDialog(){
      const dialog = document.getElementById("lpAudioExtGuideDialog");
      if (!dialog || !dialog.open) return;
      if (typeof dialog.close === "function") {
        dialog.close();
        return;
      }
      dialog.removeAttribute("open");
    }
    function openLinePreviewAudioExtensionGuideDialog(){
      const dialog = document.getElementById("lpAudioExtGuideDialog");
      if (!dialog) return;
      if (typeof dialog.showModal === "function") {
        if (!dialog.open) dialog.showModal();
        return;
      }
      dialog.setAttribute("open", "open");
    }
    function bindLinePreviewAudioExtensionGuideDialog(){
      const howToBtn = document.getElementById("lpAudioExtHowToBtn");
      if (howToBtn && !howToBtn.dataset.boundClick) {
        howToBtn.dataset.boundClick = "1";
        howToBtn.addEventListener("click", () => {
          if (!LINE_PREVIEW_AUDIO_EXTENSION_BROWSER_SUPPORTED) return;
          openLinePreviewAudioExtensionGuideDialog();
        });
      }
      const closeBtn = document.getElementById("lpAudioExtGuideClose");
      if (closeBtn && !closeBtn.dataset.boundClick) {
        closeBtn.dataset.boundClick = "1";
        closeBtn.addEventListener("click", closeLinePreviewAudioExtensionGuideDialog);
      }
      const dialog = document.getElementById("lpAudioExtGuideDialog");
      if (dialog && !dialog.dataset.boundEvents) {
        dialog.dataset.boundEvents = "1";
        dialog.addEventListener("cancel", (event) => {
          event.preventDefault();
          closeLinePreviewAudioExtensionGuideDialog();
        });
        dialog.addEventListener("click", (event) => {
          if (event.target === dialog) closeLinePreviewAudioExtensionGuideDialog();
        });
      }
    }
    function updateLinePreviewAudioExtensionState(){
      bindLinePreviewAudioExtensionGuideDialog();
      updateLinePreviewAudioExtensionLinks();
      const head = document.getElementById("lpAudioPanelHead");
      const main = document.getElementById("lpAudioMainContent");
      const missing = document.getElementById("lpAudioExtensionMissing");
      const howToBtn = document.getElementById("lpAudioExtHowToBtn");
      const unsupportedHint = document.getElementById("lpAudioExtUnsupportedHint");
      if (!main || !missing) return;
      const extensionMissing = !LINE_PREVIEW_AUDIO_EXTENSION.detected;
      const showUnsupportedHint = extensionMissing && !LINE_PREVIEW_AUDIO_EXTENSION_BROWSER_SUPPORTED;
      const showHowToBtn = extensionMissing && !showUnsupportedHint;
      if (head) head.style.display = "";
      main.style.display = "";
      missing.style.display = extensionMissing ? "flex" : "none";
      if (unsupportedHint) unsupportedHint.hidden = !showUnsupportedHint;
      if (howToBtn) {
        howToBtn.hidden = !showHowToBtn;
        howToBtn.style.display = showHowToBtn ? "inline-flex" : "none";
      }
      if (showUnsupportedHint) closeLinePreviewAudioExtensionGuideDialog();
      if (!extensionMissing) closeLinePreviewAudioExtensionGuideDialog();
    }
    function updateLinePreviewAudioRouteSectionVisibility(){
      const routeBlock = document.getElementById("lpAudioRouteBlock");
      const noLineHint = document.getElementById("lpAudioNoLineHint");
      if (!routeBlock) return;
      const hasRouteAudio = !!LINE_PREVIEW_AUDIO_STATE.enabled;
      routeBlock.style.display = hasRouteAudio ? "" : "none";
      if (noLineHint) {
        const noLineSelected = !String(currentSelectedKey || "").trim();
        noLineHint.textContent = noLineSelected ? t("audio_no_line_selected") : t("audio_line_unavailable");
        noLineHint.hidden = hasRouteAudio;
        noLineHint.style.display = hasRouteAudio ? "none" : "";
      }
    }
    function linePreviewAudioStyleDisplayName(rawName){
      return parseLinePreviewAudioStyleMeta(rawName).displayName;
    }
    function updateLinePreviewAudioStyleByline(style){
      const byline = document.getElementById("lpAudioStyleByline");
      if (!byline) return;
      const voiceBy = parseLinePreviewAudioStyleMeta(style?.name || "").voiceBy;
      if (!voiceBy) {
        byline.textContent = "";
        byline.hidden = true;
        return;
      }
      byline.textContent = `Voix par ${voiceBy}`;
      byline.hidden = false;
    }
    function updateLinePreviewAudioStyleSelect(){
      const select = document.getElementById("lpAudioStyleSelect");
      if (!select) return;
      const styles = Array.isArray(LINE_PREVIEW_AUDIO_STATE.voiceStyles) ? LINE_PREVIEW_AUDIO_STATE.voiceStyles : [];
      const prevPath = styles[LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex]?.path || "";
      select.innerHTML = "";
      if (!styles.length) {
        select.disabled = true;
        updateLinePreviewAudioStyleByline(null);
        return;
      }
      styles.forEach((style, idx) => {
        const option = document.createElement("option");
        option.value = String(style?.path || "");
        option.textContent = linePreviewAudioStyleDisplayName(style?.name);
        option.dataset.styleIndex = String(idx);
        select.appendChild(option);
      });
      let idx = LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex;
      if (!Number.isFinite(idx) || idx < 0 || idx >= styles.length) idx = 0;
      const targetPath = styles[idx]?.path || prevPath || styles[0]?.path || "";
      const found = styles.findIndex(s => String(s?.path || "") === String(targetPath));
      LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex = found >= 0 ? found : 0;
      select.value = String(styles[LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex]?.path || "");
      updateLinePreviewAudioStyleByline(styles[LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex] || null);
      const isPlaying = !!LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying;
      select.disabled = isPlaying || styles.length <= 1;
    }
    function setLinePreviewAudioStyleByPath(path, { stopPlayback = true } = {}){
      const styles = Array.isArray(LINE_PREVIEW_AUDIO_STATE.voiceStyles) ? LINE_PREVIEW_AUDIO_STATE.voiceStyles : [];
      if (!styles.length) return;
      const idx = styles.findIndex((style) => String(style?.path || "") === String(path || ""));
      if (idx < 0) return;
      LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex = idx;
      LINE_PREVIEW_AUDIO_STATE.folderPath = ensureTrailingSlash(String(styles[idx]?.path || ""));
      LINE_PREVIEW_AUDIO_STATE.departureClipName = String(styles[idx]?.departureClipName || "Départ").trim() || "Départ";
      if (stopPlayback) stopLinePreviewAudioPlayback();
      updateLinePreviewAudioStyleSelect();
      updateLinePreviewAudioButtonsState();
    }
    function linePreviewAudioGlobalFolderDisplayName(rawName){
      const name = String(rawName || "").trim();
      if (!name || name === ".") return "Global";
      const withoutTypePrefix = name.replace(/^\s*\d+\s*_\s*/i, "");
      return withoutTypePrefix
        .replace(/\{[^}]*\}/g, " ")
        .replace(/\[[^\]]*\]/g, " ")
        .replace(/\s+/g, " ")
        .trim() || withoutTypePrefix || name;
    }
    function linePreviewAudioGlobalFolderHasTag(folder, tag){
      const wanted = normalizeAudioNameToken(tag);
      if (!wanted) return false;
      const rawName = String(folder?.name || "").trim();
      const displayName = linePreviewAudioGlobalFolderDisplayName(rawName);
      const rawToken = normalizeAudioNameToken(rawName);
      const displayToken = normalizeAudioNameToken(displayName);
      return rawToken.includes(wanted) || displayToken.includes(wanted);
    }
    function getLinePreviewAudioProfileForLine(line, route){
      const lineNumber = String(getLineNumber(line, route) || line?.number || "").trim();
      const routeName = String(route?.name || "").trim();
      const parsedLineNumber = String(parseRouteName(routeName || "").lineNumber || "").trim();
      const isExpressLike = isExpress(line) || isExpressNumber(lineNumber) || /^express\b/i.test(routeName);
      const isAutocarLike =
        isAutocar(line) ||
        /^autocar\b/i.test(routeName) ||
        /^fict/i.test(routeName) ||
        /^autocar\b/i.test(parsedLineNumber) ||
        /^fict/i.test(parsedLineNumber);
      const isScolaireLike =
        getCategory(line) === "Scolaire" ||
        /^scolaire\b/i.test(String(line?.number || "")) ||
        /^scolaire\b/i.test(routeName) ||
        /^scolaire\b/i.test(parsedLineNumber);
      if (isAutocarLike) return "flixbus";
      if (isExpressLike) return "ratp";
      if (isScolaireLike) return "ratp";
      if (isFlix(line)) return "flixbus";
      return "ratp";
    }
    function isLinePreviewAudioAllowedForLine(line, route){
      return true;
    }
    function getLinePreviewAudioGlobalProfileForLine(line, route){
      return getLinePreviewAudioProfileForLine(line, route);
    }
    function parseLinePreviewAudioTypeTokens(raw){
      return String(raw ?? "")
        .split(",")
        .map((part) => String(part || "").trim())
        .filter((part) => /^[0-9]+$/.test(part));
    }
    function getLinePreviewAudioStyleEntryForLine(line, route){
      const routeName = String(route?.name || "").trim();
      const parsedLineNumber = String(parseRouteName(routeName || "").lineNumber || "").trim();
      const lineNumber = String(getLineNumber(line, route) || line?.number || "").trim();
      const category = String(getCategory(line) || "").trim();
      const isExpressLike =
        isExpress(line) ||
        isExpressNumber(lineNumber) ||
        /^express\b/i.test(routeName) ||
        /^express\b/i.test(parsedLineNumber);
      const isAutocarLike =
        isAutocar(line) ||
        /^autocar\b/i.test(routeName) ||
        /^fict/i.test(routeName) ||
        /^autocar\b/i.test(parsedLineNumber) ||
        /^fict/i.test(parsedLineNumber);
      const isScolaireLike =
        category === "Scolaire" ||
        /^scolaire\b/i.test(String(line?.number || "")) ||
        /^scolaire\b/i.test(routeName) ||
        /^scolaire\b/i.test(parsedLineNumber);
      const candidates = [];
      const addExpressCandidates = () => {
        if (!isExpressLike) return;
        const addFrom = (raw) => {
          const text = String(raw || "").trim();
          if (!text) return;
          const match = /^express\b\s*([0-9a-z]+)/i.exec(text);
          if (match && match[1]) {
            candidates.push(`Express ${String(match[1]).trim()}`);
          }
        };
        addFrom(parsedLineNumber);
        addFrom(lineNumber);
        addFrom(line?.number);
        addFrom(routeName);
        candidates.push("Express");
      };
      addExpressCandidates();
      if (parsedLineNumber) candidates.push(parsedLineNumber);
      if (lineNumber) candidates.push(lineNumber);
      if (line?.number) candidates.push(line.number);
      if (category) candidates.push(category);
      if (category === "FlixBus") candidates.push("FLIXBUS");
      if (isAutocarLike) candidates.push("Autocar");
      if (isScolaireLike) candidates.push("Scolaire");
      const seen = new Set();
      for (const candidateRaw of candidates) {
        const candidate = String(candidateRaw || "").trim();
        if (!candidate) continue;
        const key = candidate.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        const entry = getLineStyleEntry(candidate);
        if (entry) return entry;
      }
      return null;
    }
    function setLinePreviewAudioGlobalTypeTokensForLine(line, route){
      const entry = getLinePreviewAudioStyleEntryForLine(line, route);
      const rawTypes = entry?.[3];
      LINE_PREVIEW_AUDIO_GLOBAL_STATE.typeTokens = parseLinePreviewAudioTypeTokens(rawTypes);
      updateLinePreviewAudioGlobalFolderSelect();
    }
    function parseLinePreviewAudioGlobalClipMeta(rawClipName){
      const raw = String(rawClipName || "").trim();
      if (!raw) return { typeToken: "", label: "" };
      const split = raw.match(/^([^_]+)_(.+)$/);
      if (!split) return { typeToken: "", label: raw };
      const prefix = String(split[1] || "").trim();
      const label = String(split[2] || "").trim() || raw;
      const tokenMatch = prefix.match(/^[0-9]+$/);
      return {
        typeToken: tokenMatch ? prefix : "",
        label
      };
    }
    function parseLinePreviewAudioGlobalFolderMeta(rawFolderName){
      const raw = String(rawFolderName || "").trim();
      if (!raw) return { typeToken: "", label: "" };
      const parseVolumeMultiplier = (text) => {
        const m = String(text || "").match(/\{([^}]+)\}/);
        if (!m) return 1;
        const normalized = String(m[1] || "").trim().replace(",", ".");
        const parsed = Number.parseFloat(normalized);
        if (!Number.isFinite(parsed)) return 1;
        return Math.max(0, parsed);
      };
      const volumeMultiplier = parseVolumeMultiplier(raw);
      const match = raw.match(/^\s*([0-9]+)\s*_\s*(.+)$/);
      if (!match) {
        return { typeToken: "", label: linePreviewAudioGlobalFolderDisplayName(raw), volumeMultiplier };
      }
      return {
        typeToken: String(match[1] || "").trim(),
        label: linePreviewAudioGlobalFolderDisplayName(String(match[2] || "").trim()),
        volumeMultiplier
      };
    }
    function setLinePreviewAudioGlobalProfileForLine(line, route){
      const nextProfile = getLinePreviewAudioGlobalProfileForLine(line, route);
      LINE_PREVIEW_AUDIO_GLOBAL_STATE.profile = nextProfile;
      LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = "";
      if (Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) && LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders.length) {
        updateLinePreviewAudioGlobalFolderSelect();
      }
    }
    function getPreferredGlobalFolderIndex(folders){
      const list = Array.isArray(folders) ? folders : [];
      if (!list.length) return -1;
      const profile = String(LINE_PREVIEW_AUDIO_GLOBAL_STATE.profile || "ratp");
      const findBy = (predicate) => list.findIndex((folder) => predicate(folder));
      const findRatp = () => findBy((folder) => linePreviewAudioGlobalFolderHasTag(folder, "ratp"));
      const findFlix = () => findBy((folder) =>
        linePreviewAudioGlobalFolderHasTag(folder, "flixbus") ||
        linePreviewAudioGlobalFolderHasTag(folder, "flix bus")
      );
      const findNeutral = () => findBy((folder) =>
        !linePreviewAudioGlobalFolderHasTag(folder, "ratp") &&
        !linePreviewAudioGlobalFolderHasTag(folder, "flixbus") &&
        !linePreviewAudioGlobalFolderHasTag(folder, "flix bus")
      );
      if (profile === "flixbus") {
        const flixIdx = findFlix();
        if (flixIdx >= 0) return flixIdx;
      } else if (profile === "neutral") {
        const neutralIdx = findNeutral();
        if (neutralIdx >= 0) return neutralIdx;
      } else {
        const ratpIdx = findRatp();
        if (ratpIdx >= 0) return ratpIdx;
      }
      return 0;
    }
    function linePreviewAudioGlobalFolderMatchesProfile(folder, profileInput = ""){
      const profile = String(profileInput || LINE_PREVIEW_AUDIO_GLOBAL_STATE.profile || "ratp");
      const isRatp = linePreviewAudioGlobalFolderHasTag(folder, "ratp");
      const isFlix = linePreviewAudioGlobalFolderHasTag(folder, "flixbus") || linePreviewAudioGlobalFolderHasTag(folder, "flix bus");
      if (profile === "disabled") return false;
      if (profile === "flixbus") return isFlix;
      if (profile === "neutral") return !isRatp && !isFlix;
      return isRatp;
    }
    function shouldFilterLinePreviewAudioGlobalsBySelectedLine(){
      return !!String(currentSelectedKey || "").trim();
    }
    function getLinePreviewAudioGlobalAvailableFolders(folders){
      const list = Array.isArray(folders) ? folders : [];
      if (!shouldFilterLinePreviewAudioGlobalsBySelectedLine()) return list;
      const allowedTypes = new Set(
        (Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.typeTokens) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.typeTokens : [])
          .map((t) => String(t || "").trim())
          .filter(Boolean)
      );
      return list.filter((folder) => {
        if (!linePreviewAudioGlobalFolderMatchesProfile(folder)) return false;
        if (!allowedTypes.size) return true;
        const meta = parseLinePreviewAudioGlobalFolderMeta(folder?.name);
        if (!meta.typeToken) return true;
        return allowedTypes.has(meta.typeToken);
      });
    }
    function getLinePreviewAudioGlobalPlayableClips(folder){
      const clipsRaw = Array.isArray(folder?.clips) ? folder.clips : [];
      if (!shouldFilterLinePreviewAudioGlobalsBySelectedLine()) return clipsRaw;
      const allowedTypes = new Set(
        (Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.typeTokens) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.typeTokens : [])
          .map((t) => String(t || "").trim())
          .filter(Boolean)
      );
      const folderType = parseLinePreviewAudioGlobalFolderMeta(folder?.name || "").typeToken;
      return clipsRaw.filter((clipName) => {
        if (!allowedTypes.size) return true;
        if (folderType) return allowedTypes.has(folderType);
        const meta = parseLinePreviewAudioGlobalClipMeta(clipName);
        if (!meta.typeToken) return true;
        return allowedTypes.has(meta.typeToken);
      });
    }
    function hasLinePreviewAudioGlobalPlayableClip(){
      const allFolders = Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders : [];
      const folders = getLinePreviewAudioGlobalAvailableFolders(allFolders);
      return folders.some((folder) => getLinePreviewAudioGlobalPlayableClips(folder).length > 0);
    }
    function updateLinePreviewAudioGlobalButtons(){
      const wrap = document.getElementById("lpAudioGlobalButtons");
      if (!wrap) return;
      wrap.innerHTML = "";
      const allFolders = Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders : [];
      const folders = getLinePreviewAudioGlobalAvailableFolders(allFolders);
      const selectedPath = String(LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath || "");
      const selected = folders.find((folder) => String(folder?.path || "") === selectedPath) || null;
      const clips = getLinePreviewAudioGlobalPlayableClips(selected);
      if (!clips.length) {
        const empty = document.createElement("span");
        empty.className = "line-preview-audio-stop-empty";
        empty.textContent = "Aucun audio";
        wrap.appendChild(empty);
        return;
      }
      const isPlaying = !!LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying;
      const folderMeta = parseLinePreviewAudioGlobalFolderMeta(selected?.name || "");
      const folderVolumeMultiplier = Number.isFinite(Number(folderMeta?.volumeMultiplier))
        ? Number(folderMeta.volumeMultiplier)
        : 1;
      clips.forEach((clipName) => {
        const meta = parseLinePreviewAudioGlobalClipMeta(clipName);
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "line-preview-audio-btn";
        btn.textContent = meta.label || String(clipName || "").trim();
        btn.disabled = isPlaying || !selectedPath;
        btn.addEventListener("click", () => {
          if (!selectedPath) return;
          playLinePreviewAudioSequenceFromFolder(selectedPath, [clipName], {
            advanceOnFinish: false,
            lockNavigation: false,
            volumeMultiplier: folderVolumeMultiplier
          });
        });
        wrap.appendChild(btn);
      });
    }
    function updateLinePreviewAudioGlobalByline(folder){
      const byline = document.getElementById("lpAudioGlobalByline");
      if (!byline) return;
      const voiceBy = parseLinePreviewAudioStyleMeta(folder?.name || "").voiceBy;
      if (!voiceBy) {
        byline.textContent = "";
        byline.hidden = true;
        return;
      }
      byline.textContent = `Voix par ${voiceBy}`;
      byline.hidden = false;
    }
    function updateLinePreviewAudioGlobalFolderSelect(){
      const select = document.getElementById("lpAudioGlobalFolderSelect");
      if (!select) return;
      const allFolders = Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders : [];
      const folders = getLinePreviewAudioGlobalAvailableFolders(allFolders);
      const previousPath = String(LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath || "");
      select.innerHTML = "";
      if (!folders.length) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "Aucun dossier";
        select.appendChild(option);
        select.disabled = true;
        LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = "";
        updateLinePreviewAudioGlobalByline(null);
        updateLinePreviewAudioGlobalButtons();
        return;
      }
      folders.forEach((folder) => {
        const option = document.createElement("option");
        option.value = String(folder?.path || "");
        option.textContent = linePreviewAudioGlobalFolderDisplayName(folder?.name);
        select.appendChild(option);
      });
      const foundIndex = folders.findIndex((folder) => String(folder?.path || "") === previousPath);
      const preferredIndex = getPreferredGlobalFolderIndex(folders);
      const selectedIndex = foundIndex >= 0 ? foundIndex : (preferredIndex >= 0 ? preferredIndex : 0);
      LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = String(folders[selectedIndex]?.path || "");
      select.value = LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath;
      select.disabled = !!LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying || folders.length <= 1;
      updateLinePreviewAudioGlobalByline(folders[selectedIndex] || null);
      updateLinePreviewAudioGlobalButtons();
    }
    function setLinePreviewAudioGlobalFolderByPath(path){
      const allFolders = Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders : [];
      const folders = getLinePreviewAudioGlobalAvailableFolders(allFolders);
      const found = folders.find((folder) => String(folder?.path || "") === String(path || ""));
      LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = String(found?.path || "");
      updateLinePreviewAudioGlobalFolderSelect();
      updateLinePreviewAudioButtonsState();
    }
    async function loadLinePreviewAudioGlobalFolders(){
      const folders = [];
      const rootPath = ensureTrailingSlash(DBUS_FIS_GLOBAL_ROOT);
      const rootClips = (await listDirectoryMp3BaseNames(rootPath))
        .map((clip) => String(clip || "").trim())
        .filter(Boolean);
      if (rootClips.length) {
        folders.push({ name: ".", path: rootPath, clips: rootClips });
      }
      const subfolders = await listDirectorySubfolders(rootPath);
      for (const subName of subfolders) {
        const folderPath = ensureTrailingSlash(joinEncodedPath(rootPath, subName));
        const clips = (await listDirectoryMp3BaseNames(folderPath))
          .map((clip) => String(clip || "").trim())
          .filter(Boolean);
        if (!clips.length) continue;
        folders.push({ name: subName, path: folderPath, clips });
      }
      if (folders.length > 1) {
        const first = folders[0]?.name === "." ? folders.shift() : null;
        folders.sort((a, b) =>
          linePreviewAudioGlobalFolderDisplayName(a?.name).localeCompare(
            linePreviewAudioGlobalFolderDisplayName(b?.name),
            LANG === "en" ? "en" : "fr",
            { sensitivity: "base", numeric: true }
          )
        );
        if (first) folders.unshift(first);
      }
      LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders = folders;
      const currentPath = String(LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath || "");
      const availableFolders = getLinePreviewAudioGlobalAvailableFolders(folders);
      if (!availableFolders.some((folder) => String(folder?.path || "") === currentPath)) {
        const preferredIndex = getPreferredGlobalFolderIndex(availableFolders);
        const fallbackIndex = preferredIndex >= 0 ? preferredIndex : 0;
        LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = String(availableFolders[fallbackIndex]?.path || "");
      }
      updateLinePreviewAudioGlobalFolderSelect();
    }
    function ensureLinePreviewAudioGlobalFoldersLoaded(){
      if (LINE_PREVIEW_AUDIO_GLOBAL_STATE.loadPromise) return LINE_PREVIEW_AUDIO_GLOBAL_STATE.loadPromise;
      LINE_PREVIEW_AUDIO_GLOBAL_STATE.loadPromise = loadLinePreviewAudioGlobalFolders()
        .catch(() => {
          LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders = [];
          LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = "";
          updateLinePreviewAudioGlobalFolderSelect();
        })
        .finally(() => {
          LINE_PREVIEW_AUDIO_GLOBAL_STATE.loadPromise = null;
        });
      return LINE_PREVIEW_AUDIO_GLOBAL_STATE.loadPromise;
    }
    function isLinePreviewAudioPanelOpen(){
      const panel = getLinePreviewAudioPanel();
      if (!panel) return false;
      return panel.classList.contains("is-open") && panel.style.display !== "none";
    }
    function getLinePreviewAudioVolume(){
      const raw = Number(LINE_PREVIEW_AUDIO_STATE.volume);
      if (!Number.isFinite(raw)) return 1;
      return Math.max(0, Math.min(2, raw));
    }
    function ensureLinePreviewAudioContext(){
      const Ctx = globalThis.AudioContext || globalThis.webkitAudioContext;
      if (!Ctx) return null;
      let ctx = LINE_PREVIEW_AUDIO_PLAYBACK.audioCtx;
      if (!ctx) {
        try { ctx = new Ctx(); } catch { return null; }
        LINE_PREVIEW_AUDIO_PLAYBACK.audioCtx = ctx;
      }
      try {
        if (ctx.state === "suspended" && typeof ctx.resume === "function") {
          ctx.resume().catch(() => {});
        }
      } catch {}
      return ctx;
    }
    function clearLinePreviewAudioGainRouting(){
      try { LINE_PREVIEW_AUDIO_PLAYBACK.sourceNode?.disconnect(); } catch {}
      try { LINE_PREVIEW_AUDIO_PLAYBACK.gainNode?.disconnect(); } catch {}
      LINE_PREVIEW_AUDIO_PLAYBACK.sourceNode = null;
      LINE_PREVIEW_AUDIO_PLAYBACK.sourceAudio = null;
      LINE_PREVIEW_AUDIO_PLAYBACK.gainNode = null;
    }
    function ensureLinePreviewAudioGainRouting(audio){
      if (!audio) return false;
      if (
        LINE_PREVIEW_AUDIO_PLAYBACK.sourceAudio === audio
        && LINE_PREVIEW_AUDIO_PLAYBACK.sourceNode
        && LINE_PREVIEW_AUDIO_PLAYBACK.gainNode
      ) {
        return true;
      }
      const ctx = ensureLinePreviewAudioContext();
      if (!ctx) return false;
      clearLinePreviewAudioGainRouting();
      let source = null;
      let gainNode = null;
      try {
        source = ctx.createMediaElementSource(audio);
        gainNode = ctx.createGain();
        source.connect(gainNode);
        gainNode.connect(ctx.destination);
      } catch {
        try { source?.disconnect(); } catch {}
        try { gainNode?.disconnect(); } catch {}
        clearLinePreviewAudioGainRouting();
        return false;
      }
      LINE_PREVIEW_AUDIO_PLAYBACK.sourceNode = source;
      LINE_PREVIEW_AUDIO_PLAYBACK.sourceAudio = audio;
      LINE_PREVIEW_AUDIO_PLAYBACK.gainNode = gainNode;
      return true;
    }
    function applyLinePreviewAudioVolumeToActivePlayback(){
      const active = LINE_PREVIEW_AUDIO_PLAYBACK.audio;
      if (!active) return;
      const baseVolume = getLinePreviewAudioVolume();
      const mul = Number.isFinite(Number(LINE_PREVIEW_AUDIO_PLAYBACK.volumeMultiplier))
        ? Number(LINE_PREVIEW_AUDIO_PLAYBACK.volumeMultiplier)
        : 1;
      const gainValue = Math.max(0, baseVolume * Math.max(0, Math.min(1, mul)));
      if (gainValue > 1 && ensureLinePreviewAudioGainRouting(active)) {
        active.volume = 1;
        if (LINE_PREVIEW_AUDIO_PLAYBACK.gainNode) {
          LINE_PREVIEW_AUDIO_PLAYBACK.gainNode.gain.value = gainValue;
        }
        return;
      }
      clearLinePreviewAudioGainRouting();
      active.volume = Math.max(0, Math.min(1, gainValue));
    }
    function setLinePreviewAudioVolume(volume){
      const parsed = Number(volume);
      const safe = Number.isFinite(parsed) ? parsed : 1;
      const clamped = Math.max(0, Math.min(2, safe));
      LINE_PREVIEW_AUDIO_STATE.volume = clamped;
      const slider = document.getElementById("lpAudioVolumeRange");
      if (slider) {
        const sliderValue = String(Math.round(clamped * 100));
        if (slider.value !== sliderValue) slider.value = sliderValue;
      }
      applyLinePreviewAudioVolumeToActivePlayback();
    }
    function stopLinePreviewAudioPlayback(){
      LINE_PREVIEW_AUDIO_PLAYBACK.token += 1;
      const active = LINE_PREVIEW_AUDIO_PLAYBACK.audio;
      if (active) {
        try { active.pause(); } catch {}
        try { active.src = ""; } catch {}
      }
      clearLinePreviewAudioGainRouting();
      LINE_PREVIEW_AUDIO_PLAYBACK.audio = null;
      LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying = false;
      LINE_PREVIEW_AUDIO_PLAYBACK.lockNavigation = false;
      LINE_PREVIEW_AUDIO_PLAYBACK.volumeMultiplier = 1;
      updateLinePreviewAudioButtonsState();
      if (typeof syncSaeivExternalState === "function") {
        try { syncSaeivExternalState({ force: false }); } catch {}
      }
    }
    function updateLinePreviewAudioNowLabel(){
      const now = document.getElementById("lpAudioNowStop");
      if (!now) return;
      if (!LINE_PREVIEW_AUDIO_STATE.enabled || !LINE_PREVIEW_AUDIO_STATE.stopNames.length) {
        now.innerHTML = `<span class="line-preview-audio-stop-empty">-</span>`;
        return;
      }
      const idx = Math.max(0, Math.min(LINE_PREVIEW_AUDIO_STATE.stopNames.length - 1, LINE_PREVIEW_AUDIO_STATE.currentIndex || 0));
      LINE_PREVIEW_AUDIO_STATE.currentIndex = idx;
      const label = escapeHTML(translateStopName(LINE_PREVIEW_AUDIO_STATE.stopNames[idx]));
      now.innerHTML = `
        <div class="line-preview-audio-stop-sign">
          <div class="line-preview-audio-stop-sign-text">${label}</div>
        </div>
      `;
      fitLinePreviewAudioStopSignText();
    }
    function fitLinePreviewAudioStopSignText(){
      const textEl = document.querySelector("#lpAudioNowStop .line-preview-audio-stop-sign-text");
      const signEl = document.querySelector("#lpAudioNowStop .line-preview-audio-stop-sign");
      if (!textEl || !signEl) return;
      const maxSize = 31;
      const minSize = 10;
      const available = Math.max(40, signEl.clientWidth - 24);
      textEl.style.fontSize = `${maxSize}px`;
      if (textEl.scrollWidth <= available) return;
      let size = maxSize;
      while (size > minSize && textEl.scrollWidth > available) {
        size -= 0.5;
        textEl.style.fontSize = `${size}px`;
      }
    }
    function updateLinePreviewAudioButtonsState(){
      const panelCloseBtn = document.getElementById("lpAudioPanelClose");
      const styleSelect = document.getElementById("lpAudioStyleSelect");
      const globalFolderSelect = document.getElementById("lpAudioGlobalFolderSelect");
      const globalButtons = document.querySelectorAll("#lpAudioGlobalButtons .line-preview-audio-btn");
      const stopBtn = document.getElementById("lpAudioStopBtn");
      const prevBtn = document.getElementById("lpAudioPrevBtn");
      const currentBtn = document.getElementById("lpAudioCurrentBtn");
      const nextBtn = document.getElementById("lpAudioNextBtn");
      const terminusBtn = document.getElementById("lpAudioTerminusBtn");
      const isPlaying = !!LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying;
      const lockNavigation = !!LINE_PREVIEW_AUDIO_PLAYBACK.lockNavigation;
      const hasStops = LINE_PREVIEW_AUDIO_STATE.enabled && LINE_PREVIEW_AUDIO_STATE.stopNames.length > 0;
      const idx = Math.max(0, Math.min((LINE_PREVIEW_AUDIO_STATE.stopNames.length || 1) - 1, LINE_PREVIEW_AUDIO_STATE.currentIndex || 0));
      const lastIndex = Math.max(0, (LINE_PREVIEW_AUDIO_STATE.stopNames.length || 1) - 1);
      const isLastStop = hasStops && idx >= lastIndex;
      if (panelCloseBtn) panelCloseBtn.disabled = false;
      if (styleSelect) {
        const styles = Array.isArray(LINE_PREVIEW_AUDIO_STATE.voiceStyles) ? LINE_PREVIEW_AUDIO_STATE.voiceStyles : [];
        styleSelect.disabled = isPlaying || styles.length <= 1;
      }
      if (globalFolderSelect) {
        const foldersAll = Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders : [];
        const folders = getLinePreviewAudioGlobalAvailableFolders(foldersAll);
        globalFolderSelect.disabled = isPlaying || folders.length <= 1;
      }
      globalButtons.forEach((btn) => {
        btn.disabled = isPlaying || !LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath;
      });
      if (stopBtn) stopBtn.disabled = !isPlaying;
      if (prevBtn) prevBtn.disabled = !hasStops || idx <= 0 || (isPlaying && lockNavigation);
      if (nextBtn) nextBtn.disabled = !hasStops || isLastStop || (isPlaying && lockNavigation);
      if (isPlaying) {
        if (currentBtn) currentBtn.disabled = true;
        if (terminusBtn) terminusBtn.disabled = true;
        return;
      }
      if (currentBtn) currentBtn.disabled = !hasStops || idx <= 0;
      if (terminusBtn) terminusBtn.disabled = !hasStops || isLastStop;
    }
    function normalizeLinePreviewAudioPanelPosition(){
      const panel = getLinePreviewAudioPanel();
      if (!panel) return;
      const margin = 8;
      const rect = panel.getBoundingClientRect();
      const width = Math.max(460, Math.min(window.innerWidth - margin * 2, rect.width || panel.offsetWidth || 560));
      panel.style.width = `${Math.round(width)}px`;
      const boundedRect = panel.getBoundingClientRect();
      const maxLeft = Math.max(margin, window.innerWidth - boundedRect.width - margin);
      const maxTop = Math.max(margin, window.innerHeight - boundedRect.height - margin);
      const fallbackTop = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--header-stack-h")) || 0) + 10;
      const currentLeft = Number.parseFloat(panel.style.left || "");
      const currentTop = Number.parseFloat(panel.style.top || "");
      const left = Number.isFinite(currentLeft) ? Math.max(margin, Math.min(maxLeft, currentLeft)) : margin;
      const top = Number.isFinite(currentTop) ? Math.max(margin, Math.min(maxTop, currentTop)) : Math.max(margin, Math.min(maxTop, fallbackTop));
      panel.style.left = `${Math.round(left)}px`;
      panel.style.top = `${Math.round(top)}px`;
      fitLinePreviewAudioStopSignText();
    }
    function closeLinePreviewAudioPanel({ stopPlayback = true } = {}){
      teardownLinePreviewAudioPopup({ closeWindow: true });
      const panel = getLinePreviewAudioPanel();
      if (panel) {
        panel.classList.remove("is-open");
        panel.style.display = "none";
        panel.setAttribute("aria-hidden", "true");
      }
      if (stopPlayback) stopLinePreviewAudioPlayback();
      if (typeof updateUiOverlays === "function") {
        try { updateUiOverlays(); } catch {}
      }
    }
    function bindLinePreviewAudioPanelDrag(){
      if (LINE_PREVIEW_AUDIO_DRAG.initialized) return;
      const panel = getLinePreviewAudioPanel();
      const head = document.getElementById("lpAudioPanelHead");
      if (!panel || !head) return;
      const onStart = (event) => {
        const panelRect = panel.getBoundingClientRect();
        const offsetX = event.clientX - panelRect.left;
        const offsetY = event.clientY - panelRect.top;
        try { head.setPointerCapture(event.pointerId); } catch {}
        const onMove = (e) => {
          const margin = 8;
          const maxLeft = Math.max(margin, window.innerWidth - panelRect.width - margin);
          const maxTop = Math.max(margin, window.innerHeight - panelRect.height - margin);
          const nextLeft = Math.max(margin, Math.min(maxLeft, e.clientX - offsetX));
          const nextTop = Math.max(margin, Math.min(maxTop, e.clientY - offsetY));
          panel.style.left = `${Math.round(nextLeft)}px`;
          panel.style.top = `${Math.round(nextTop)}px`;
        };
        const onStop = () => {
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onStop);
          window.removeEventListener("pointercancel", onStop);
        };
        window.addEventListener("pointermove", onMove);
        window.addEventListener("pointerup", onStop);
        window.addEventListener("pointercancel", onStop);
      };
      head.addEventListener("pointerdown", onStart);
      window.addEventListener("resize", normalizeLinePreviewAudioPanelPosition);
      LINE_PREVIEW_AUDIO_DRAG.initialized = true;
    }
    function openLinePreviewAudioPanel(){
      const panel = getLinePreviewAudioPanel();
      if (!panel) return;
      teardownLinePreviewAudioPopup({ closeWindow: true });
      setLinePreviewAudioMainPanelHidden(false);
      updateLinePreviewAudioExtensionState();
      panel.style.display = "block";
      panel.classList.add("is-open");
      panel.setAttribute("aria-hidden", "false");
      normalizeLinePreviewAudioPanelPosition();
      {
        const margin = 8;
        const rect = panel.getBoundingClientRect();
        const centeredLeft = Math.max(margin, Math.round((window.innerWidth - rect.width) / 2));
        const centeredTop = Math.max(margin, Math.round((window.innerHeight - rect.height) / 2));
        panel.style.left = `${centeredLeft}px`;
        panel.style.top = `${centeredTop}px`;
      }
      updateLinePreviewAudioRouteSectionVisibility();
      updateLinePreviewAudioNowLabel();
      updateLinePreviewAudioButtonsState();
      bindLinePreviewAudioPanelDrag();
      ensureLinePreviewAudioGlobalFoldersLoaded();
      if (typeof updateUiOverlays === "function") {
        try { updateUiOverlays(); } catch {}
      }
    }
    function setLinePreviewAudioRouteState(route, audioStatus){
      stopLinePreviewAudioPlayback();
      const stylesRaw = Array.isArray(audioStatus?.styles) ? audioStatus.styles : [];
      const normalizedStyles = stylesRaw.map((style) => {
        const name = String(style?.name || "").trim();
        const path = ensureTrailingSlash(String(style?.path || ""));
        const departureClipName = String(style?.departureClipName || "").trim();
        return { name, path, departureClipName };
      }).filter((style) => !!style.path);
      if (!normalizedStyles.length) {
        const fallbackPath = ensureTrailingSlash(String(audioStatus?.href || ""));
        if (fallbackPath) {
          normalizedStyles.push({
            name: ".",
            path: fallbackPath,
            departureClipName: String(audioStatus?.departureClipName || "").trim()
          });
        }
      }
      LINE_PREVIEW_AUDIO_STATE.voiceStyles = normalizedStyles;
      LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex = 0;
      LINE_PREVIEW_AUDIO_STATE.folderPath = String(normalizedStyles[0]?.path || "");
      LINE_PREVIEW_AUDIO_STATE.departureClipName = String(
        normalizedStyles[0]?.departureClipName || audioStatus?.departureClipName || "Départ"
      ).trim() || "Départ";
      LINE_PREVIEW_AUDIO_STATE.stopNames = collectRouteAudioStopNames(route);
      LINE_PREVIEW_AUDIO_STATE.currentIndex = 0;
      LINE_PREVIEW_AUDIO_STATE.enabled = !!LINE_PREVIEW_AUDIO_STATE.folderPath && LINE_PREVIEW_AUDIO_STATE.stopNames.length > 0;
      updateLinePreviewAudioRouteSectionVisibility();
      updateLinePreviewAudioStyleSelect();
      updateLinePreviewAudioNowLabel();
      updateLinePreviewAudioButtonsState();
      if (typeof syncSaeivExternalState === "function") {
        try { syncSaeivExternalState({ force: false }); } catch {}
      }
    }
    function clearLinePreviewAudioRouteState({ closePanel = false, stopPlayback = true } = {}){
      if (stopPlayback) stopLinePreviewAudioPlayback();
      LINE_PREVIEW_AUDIO_STATE.folderPath = "";
      LINE_PREVIEW_AUDIO_STATE.stopNames = [];
      LINE_PREVIEW_AUDIO_STATE.currentIndex = 0;
      LINE_PREVIEW_AUDIO_STATE.enabled = false;
      LINE_PREVIEW_AUDIO_STATE.voiceStyles = [];
      LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex = 0;
      LINE_PREVIEW_AUDIO_STATE.departureClipName = "Départ";
      updateLinePreviewAudioRouteSectionVisibility();
      updateLinePreviewAudioStyleSelect();
      updateLinePreviewAudioNowLabel();
      updateLinePreviewAudioButtonsState();
      if (typeof syncSaeivExternalState === "function") {
        try { syncSaeivExternalState({ force: false }); } catch {}
      }
      if (closePanel) closeLinePreviewAudioPanel({ stopPlayback: false });
    }
    function playLinePreviewAudioClip(folderPath, clipName, token, volumeMultiplier = 1){
      const url = linePreviewAudioClipUrl(folderPath, clipName);
      return new Promise((resolve) => {
        const audio = new Audio(url);
        const mul = Number.isFinite(Number(volumeMultiplier)) ? Number(volumeMultiplier) : 1;
        LINE_PREVIEW_AUDIO_PLAYBACK.audio = audio;
        LINE_PREVIEW_AUDIO_PLAYBACK.volumeMultiplier = Math.max(0, Math.min(1, mul));
        applyLinePreviewAudioVolumeToActivePlayback();
        let done = false;
        const finish = () => {
          if (done) return;
          done = true;
          audio.onended = null;
          audio.onerror = null;
          audio.onpause = null;
          if (LINE_PREVIEW_AUDIO_PLAYBACK.audio === audio) {
            clearLinePreviewAudioGainRouting();
            LINE_PREVIEW_AUDIO_PLAYBACK.audio = null;
          }
          resolve();
        };
        audio.onended = finish;
        audio.onerror = finish;
        audio.onpause = () => {
          if (LINE_PREVIEW_AUDIO_PLAYBACK.token !== token) finish();
        };
        audio.play().then(() => {
          if (LINE_PREVIEW_AUDIO_PLAYBACK.token !== token) {
            try { audio.pause(); } catch {}
            finish();
          }
        }).catch(finish);
      });
    }
    async function playLinePreviewAudioSequenceFromFolder(folderPathInput, clips, { advanceOnFinish = false, lockNavigation = false, volumeMultiplier = 1 } = {}){
      const folderPath = ensureTrailingSlash(String(folderPathInput || ""));
      const sequence = (Array.isArray(clips) ? clips : [])
        .map(item => String(item || "").trim())
        .filter(Boolean);
      if (!folderPath || !sequence.length) return;
      stopLinePreviewAudioPlayback();
      const token = LINE_PREVIEW_AUDIO_PLAYBACK.token;
      const safeMul = Number.isFinite(Number(volumeMultiplier)) ? Number(volumeMultiplier) : 1;
      LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying = true;
      LINE_PREVIEW_AUDIO_PLAYBACK.lockNavigation = !!lockNavigation;
      LINE_PREVIEW_AUDIO_PLAYBACK.volumeMultiplier = Math.max(0, Math.min(1, safeMul));
      updateLinePreviewAudioButtonsState();
      if (typeof syncSaeivExternalState === "function") {
        try { syncSaeivExternalState({ force: false }); } catch {}
      }
      for (const clip of sequence) {
        if (token !== LINE_PREVIEW_AUDIO_PLAYBACK.token) {
          LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying = false;
          LINE_PREVIEW_AUDIO_PLAYBACK.lockNavigation = false;
          updateLinePreviewAudioButtonsState();
          if (typeof syncSaeivExternalState === "function") {
            try { syncSaeivExternalState({ force: false }); } catch {}
          }
          return;
        }
        await playLinePreviewAudioClip(folderPath, clip, token, LINE_PREVIEW_AUDIO_PLAYBACK.volumeMultiplier);
      }
      if (token === LINE_PREVIEW_AUDIO_PLAYBACK.token) {
        LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying = false;
        LINE_PREVIEW_AUDIO_PLAYBACK.lockNavigation = false;
        updateLinePreviewAudioButtonsState();
        if (typeof syncSaeivExternalState === "function") {
          try { syncSaeivExternalState({ force: false }); } catch {}
        }
        if (advanceOnFinish) {
          const lastIndex = Math.max(0, (LINE_PREVIEW_AUDIO_STATE.stopNames.length || 1) - 1);
          const currentIndex = Math.max(0, Math.min(lastIndex, LINE_PREVIEW_AUDIO_STATE.currentIndex || 0));
          if (currentIndex < lastIndex) {
            setLinePreviewAudioCurrentIndex(currentIndex + 1);
          }
        }
      }
    }
    async function playLinePreviewAudioSequence(clips, options = {}){
      return playLinePreviewAudioSequenceFromFolder(LINE_PREVIEW_AUDIO_STATE.folderPath, clips, options);
    }
    function setLinePreviewAudioCurrentIndex(index){
      if (!LINE_PREVIEW_AUDIO_STATE.enabled || !LINE_PREVIEW_AUDIO_STATE.stopNames.length) return;
      const lastIndex = LINE_PREVIEW_AUDIO_STATE.stopNames.length - 1;
      LINE_PREVIEW_AUDIO_STATE.currentIndex = Math.max(0, Math.min(lastIndex, Number(index)));
      updateLinePreviewAudioNowLabel();
      updateLinePreviewAudioButtonsState();
      if (typeof syncSaeivExternalState === "function") {
        try { syncSaeivExternalState({ force: false }); } catch {}
      }
    }
    function playLinePreviewCurrentStop(index, { advanceOnFinish = false } = {}){
      if (!LINE_PREVIEW_AUDIO_STATE.enabled || !LINE_PREVIEW_AUDIO_STATE.stopNames.length) return;
      setLinePreviewAudioCurrentIndex(index);
      const nextIndex = LINE_PREVIEW_AUDIO_STATE.currentIndex;
      const clips = [LINE_PREVIEW_AUDIO_STATE.stopNames[nextIndex]];
      const lastIndex = LINE_PREVIEW_AUDIO_STATE.stopNames.length - 1;
      if (nextIndex === lastIndex) clips.push("Terminus");
      const shouldAdvance = !!advanceOnFinish && nextIndex < lastIndex;
      playLinePreviewAudioSequence(clips, { advanceOnFinish: shouldAdvance, lockNavigation: true });
    }
    function playLinePreviewTerminusSequence(){
      if (!LINE_PREVIEW_AUDIO_STATE.enabled || !LINE_PREVIEW_AUDIO_STATE.stopNames.length) return;
      const lastIndex = LINE_PREVIEW_AUDIO_STATE.stopNames.length - 1;
      if ((LINE_PREVIEW_AUDIO_STATE.currentIndex || 0) >= lastIndex) return;
      const currentIndex = Math.max(0, Math.min(lastIndex, LINE_PREVIEW_AUDIO_STATE.currentIndex || 0));
      const shouldAdvance = currentIndex === 0 && lastIndex > 0;
      const shouldLockNavigation = currentIndex === 0;
      const departureClip = String(LINE_PREVIEW_AUDIO_STATE.departureClipName || "Départ").trim() || "Départ";
      const clips = [departureClip, LINE_PREVIEW_AUDIO_STATE.stopNames[lastIndex]];
      playLinePreviewAudioSequence(clips, { advanceOnFinish: shouldAdvance, lockNavigation: shouldLockNavigation });
    }
    async function evaluateRouteAudioCoverage(line, route){
      const lineFolder = getDbusFisLineFolderName(line, route);
      const routeName = String(route?.name || "").trim();
      const departureCandidates = getLinePreviewAudioDepartureClipCandidates(line, route);
      const preferredDepartureLabel = String(departureCandidates[0] || "Départ").trim() || "Départ";
      const requiredLabelsByToken = collectRequiredAudioTokenLabelsForRoute(route, { includeDeparture: false });
      const allRequiredStops = [preferredDepartureLabel, ...requiredLabelsByToken.values()];
      const requiredTokens = collectRequiredAudioTokensForRoute(route, { includeDeparture: false });
      const evaluateScanTargets = (scanTargets) => {
        const completeStyles = [];
        const missingByFolder = [];
        (Array.isArray(scanTargets) ? scanTargets : []).forEach((target) => {
          const folderPath = ensureTrailingSlash(String(target?.folderPath || ""));
          const subfolderName = String(target?.folderName || "").trim() || ".";
          const files = Array.isArray(target?.files) ? target.files : [];
          const availableTokens = new Set(files.map(normalizeAudioNameToken).filter(Boolean));
          const departureClipName = resolveLinePreviewAudioDepartureClipName(files, line, route);
          const missingTokens = [...requiredTokens].filter((token) => !availableTokens.has(token));
          const missingStops = missingTokens.map((token) => requiredLabelsByToken.get(token) || token);
          if (!departureClipName) missingStops.unshift(preferredDepartureLabel);
          if (missingStops.length) {
            missingByFolder.push({
              line: lineFolder,
              route: routeName,
              folder: subfolderName,
              missingStops
            });
            return;
          }
          completeStyles.push({
            name: subfolderName,
            path: folderPath,
            departureClipName
          });
        });
        return { completeStyles, missingByFolder };
      };

      const dossiersScanTargets = await listDbusFisRouteStyleFoldersFromDossiers();
      if (dossiersScanTargets.length) {
        const { completeStyles, missingByFolder } = evaluateScanTargets(
          dossiersScanTargets.map((target) => ({
            folderName: target?.name || ".",
            folderPath: ensureTrailingSlash(String(target?.path || "")),
            files: Array.isArray(target?.files) ? target.files : []
          }))
        );
        if (completeStyles.length) {
          const targetFolder = completeStyles[0]?.path || "";
          return {
            ok: true,
            href: ensureTrailingSlash(targetFolder),
            styles: completeStyles,
            departureClipName: String(completeStyles[0]?.departureClipName || preferredDepartureLabel),
            reason: "complete",
            line: lineFolder,
            route: routeName
          };
        }
        return {
          ok: false,
          href: "",
          reason: "missing_stops_mp3",
          line: lineFolder,
          route: routeName,
          missingByFolder: missingByFolder.length
            ? missingByFolder
            : [{ folder: DBUS_FIS_DOSSIERS_ROOT, missingStops: allRequiredStops }]
        };
      }

      const linePath = ensureTrailingSlash(joinEncodedPath(DBUS_FIS_ROOT, lineFolder));
      if (!lineFolder) {
        return {
          ok: false,
          href: "",
          reason: "line_folder_name_empty",
          line: lineFolder,
          route: routeName,
          missingByFolder: [
            { folder: "", missingStops: allRequiredStops }
          ]
        };
      }
      const scanTargets = [];
      const seenScanTarget = new Set();
      const addScanTarget = (folderName, folderPath, files) => {
        const normalizedFolderPath = ensureTrailingSlash(String(folderPath || ""));
        const key = normalizedFolderPath.toLowerCase();
        if (!folderPath || seenScanTarget.has(key)) return;
        seenScanTarget.add(key);
        scanTargets.push({
          folderName,
          folderPath: normalizedFolderPath,
          files: Array.isArray(files) ? files : []
        });
      };
      const scanLineRoot = async (rootPath, rootLabel = ".") => {
        const rootFiles = await listDirectoryMp3BaseNames(rootPath);
        if (rootFiles.length) addScanTarget(rootLabel, rootPath, rootFiles);
        const subfolders = await listDirectorySubfolders(rootPath);
        for (const subfolderName of subfolders) {
          const folderPath = ensureTrailingSlash(joinEncodedPath(rootPath, subfolderName));
          const files = await listDirectoryMp3BaseNames(folderPath);
          if (files.length) addScanTarget(subfolderName, folderPath, files);
        }
      };
      const missingCandidates = new Set([linePath]);

      await scanLineRoot(linePath, ".");
      if (!scanTargets.length) {
        const fallbackRoots = await listDbusFisFallbackLineFolders(lineFolder);
        for (const fallbackRoot of fallbackRoots) {
          const fallbackPath = ensureTrailingSlash(String(fallbackRoot?.path || ""));
          if (fallbackPath) missingCandidates.add(fallbackPath);
          await scanLineRoot(fallbackPath, String(fallbackRoot?.styleName || "."));
        }
      }

      if (!scanTargets.length) {
        return {
          ok: false,
          href: "",
          reason: "line_folder_missing_or_empty",
          line: lineFolder,
          route: routeName,
          linePath,
          missingByFolder: [...missingCandidates].map((folder) => ({
            folder,
            missingStops: allRequiredStops
          }))
        };
      }
      const { completeStyles, missingByFolder } = evaluateScanTargets(scanTargets);
      if (!completeStyles.length) {
        return {
          ok: false,
          href: "",
          reason: "missing_stops_mp3",
          line: lineFolder,
          route: routeName,
          missingByFolder
        };
      }
      const targetFolder = completeStyles[0]?.path || linePath;
      return {
        ok: true,
        href: ensureTrailingSlash(targetFolder),
        styles: completeStyles,
        departureClipName: String(completeStyles[0]?.departureClipName || preferredDepartureLabel),
        reason: "complete",
        line: lineFolder,
        route: routeName
      };
    }
    function getRouteAudioCoverage(line, route){
      return evaluateRouteAudioCoverage(line, route).catch(() => ({ ok: false, href: "" }));
    }
    function isLinePreviewAudioLanguageAllowed(){
      return String(LANG || "").toLowerCase() === "fr";
    }
    function ensureSaeivChannel(){
      if (SAEIV_PANEL_STATE.channel) return SAEIV_PANEL_STATE.channel;
      if (typeof BroadcastChannel !== "function") return null;
      const channel = new BroadcastChannel(SAEIV_CHANNEL_NAME);
      SAEIV_PANEL_STATE.channel = channel;
      if (!SAEIV_PANEL_STATE.channelBound) {
        channel.addEventListener("message", (event) => {
          const data = event?.data || {};
          if (!data || data.sourceId !== SAEIV_PANEL_STATE.sourceId) return;
          const type = String(data.type || "");
          if (type === "saeiv:request_state" || type === "saeiv:ready") {
            syncSaeivExternalState({ force: true });
            return;
          }
          if (type === "saeiv:action") {
            const action = String(data.action || "").trim();
            if (!action) return;
            if (action.startsWith("diffusion-")) {
              const actionMatch = /(\d+)$/.exec(action);
              const slotFromAction = actionMatch ? Number(actionMatch[1]) : 0;
              const slotRaw = Number(data.diffusionSlot || slotFromAction || 0);
              const slotIndex = Number.isInteger(slotRaw) && slotRaw > 0 ? slotRaw - 1 : -1;
              if (slotIndex >= 0) {
                triggerSaeivGlobalAudioByIndex(slotIndex).catch(() => {});
              }
            }
            SAEIV_PANEL_STATE.lastAction = action;
            console.log("[SAEIV][TEST]", action);
            syncSaeivExternalState({ force: true });
            return;
          }
          if (type === "saeiv:closed") {
            handleSaeivWindowClosed({ update: true });
          }
        });
        SAEIV_PANEL_STATE.channelBound = true;
      }
      return channel;
    }
    function getSaeivSelectedInfo(){
      const key = String(currentSelectedKey || "").trim();
      if (key) {
        const [lineUidRaw, routeUidRaw] = key.split(":");
        const lineUid = String(lineUidRaw || "").trim();
        const routeUid = String(routeUidRaw || "").trim();
        const line = DBUS_LINES.find((item) => String(item?.uid || "") === lineUid) || null;
        const route = line ? (line.routes || []).find((item) => String(item?.uid || "") === routeUid) || null : null;
        const lineNumber = line ? String(getLineNumber(line, route) || line?.number || "").trim() : "";
        const routeName = String(route?.name || "").trim();
        return {
          selected: true,
          lineUid,
          routeUid,
          lineNumber,
          routeName,
          key
        };
      }
      const lineUid = String(currentSelectedLineUid || "").trim();
      if (lineUid) {
        const line = DBUS_LINES.find((item) => String(item?.uid || "") === lineUid) || null;
        const lineNumber = line ? String(line?.number || "").trim() : "";
        return {
          selected: false,
          lineUid,
          routeUid: "",
          lineNumber,
          routeName: "",
          key: ""
        };
      }
      return {
        selected: false,
        lineUid: "",
        routeUid: "",
        lineNumber: "",
        routeName: "",
        key: ""
      };
    }
    function getSaeivSelectedLineRoute(info){
      const lineUid = String(info?.lineUid || "").trim();
      const routeUid = String(info?.routeUid || "").trim();
      if (!lineUid) return { line: null, route: null };
      const line = DBUS_LINES.find((item) => String(item?.uid || "") === lineUid) || null;
      const route = line && routeUid
        ? (line.routes || []).find((item) => String(item?.uid || "") === routeUid) || null
        : null;
      return { line, route };
    }
    function getSaeivClockText(){
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, "0");
      const mm = String(now.getMinutes()).padStart(2, "0");
      return `${hh}:${mm}`;
    }
    function buildSaeivAudioLinkedState(info){
      const { line, route } = getSaeivSelectedLineRoute(info);
      const routeStopNames = Array.isArray(route?.stops) ? collectRouteAudioStopNames(route) : [];
      const audioStopNames = Array.isArray(LINE_PREVIEW_AUDIO_STATE.stopNames)
        ? LINE_PREVIEW_AUDIO_STATE.stopNames.map((name) => String(name || "").trim()).filter(Boolean)
        : [];
      const canUseAudioStops = !!LINE_PREVIEW_AUDIO_STATE.enabled && audioStopNames.length > 0;
      const linkedStopNames = canUseAudioStops ? audioStopNames : routeStopNames;
      const linkedLastIndex = Math.max(0, linkedStopNames.length - 1);
      const linkedIndex = linkedStopNames.length
        ? Math.max(0, Math.min(linkedLastIndex, Number(LINE_PREVIEW_AUDIO_STATE.currentIndex || 0)))
        : 0;
      const currentStopName = String(linkedStopNames[linkedIndex] || "").trim();
      const nextStopName = linkedIndex < linkedLastIndex
        ? String(linkedStopNames[linkedIndex + 1] || "").trim()
        : "";
      const thirdStopName = (linkedIndex + 2) <= linkedLastIndex
        ? String(linkedStopNames[linkedIndex + 2] || "").trim()
        : "";
      const minutesByToken = new Map();
      (Array.isArray(route?.stops) ? route.stops : []).forEach((stopRef) => {
        const rawName = String(DBUS_STOPS.get(stopRef?.uid)?.name || "").trim();
        if (!rawName) return;
        const label = stripProvisoire(rawName) || rawName;
        const token = normalizeAudioNameToken(label);
        if (!token || minutesByToken.has(token)) return;
        const minutes = Math.max(0, Number(stopRef?.nextStopTime) || 0);
        minutesByToken.set(token, minutes);
      });
      const currentToken = normalizeAudioNameToken(currentStopName);
      const departMinutesRaw = currentToken ? Number(minutesByToken.get(currentToken) || 0) : 0;
      const departMinutes = departMinutesRaw > 0 ? String(departMinutesRaw).padStart(2, "0") : "";
      return {
        hasLinkedAudio: canUseAudioStops,
        audioCurrentIndex: linkedIndex,
        audioStopNames: linkedStopNames,
        stopName: currentStopName,
        nextStopName,
        thirdStopName,
        departMinutes,
        refTime: getSaeivClockText(),
        routeStopCount: routeStopNames.length,
        audioFolderPath: String(LINE_PREVIEW_AUDIO_STATE.folderPath || ""),
        audioVoiceStyle: String((LINE_PREVIEW_AUDIO_STATE.voiceStyles || [])[LINE_PREVIEW_AUDIO_STATE.selectedVoiceIndex]?.name || "")
      };
    }
    function getSaeivGlobalFolderPlayableClips(folder, { includeRawFallback = true } = {}){
      const filtered = getLinePreviewAudioGlobalPlayableClips(folder);
      if (filtered.length || !includeRawFallback) return filtered;
      return (Array.isArray(folder?.clips) ? folder.clips : [])
        .map((clip) => String(clip || "").trim())
        .filter(Boolean);
    }
    function findSaeivRatpGlobalFolder(folders, { requirePlayable = false } = {}){
      const list = Array.isArray(folders) ? folders : [];
      if (!list.length) return null;
      const tagged = list.filter((folder) => linePreviewAudioGlobalFolderHasTag(folder, "ratp"));
      if (!tagged.length) return null;
      if (!requirePlayable) return tagged[0] || null;
      return tagged.find((folder) => getSaeivGlobalFolderPlayableClips(folder).length > 0) || null;
    }
    function buildSaeivGlobalAudioState({ forceRatpDefault = false } = {}){
      const allFolders = Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders : [];
      if (!allFolders.length && !LINE_PREVIEW_AUDIO_GLOBAL_STATE.loadPromise) {
        ensureLinePreviewAudioGlobalFoldersLoaded()
          .then(() => {
            try { syncSaeivExternalState({ force: true }); } catch {}
          })
          .catch(() => {});
      }
      const filteredFolders = getLinePreviewAudioGlobalAvailableFolders(allFolders);
      const folders = filteredFolders.length ? filteredFolders : allFolders;
      let selectedPath = String(LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath || "");
      let selectedFolder = folders.find((folder) => String(folder?.path || "") === selectedPath) || null;
      if (forceRatpDefault) {
        selectedFolder = findSaeivRatpGlobalFolder(folders, { requirePlayable: true })
          || findSaeivRatpGlobalFolder(folders)
          || findSaeivRatpGlobalFolder(allFolders, { requirePlayable: true })
          || findSaeivRatpGlobalFolder(allFolders)
          || selectedFolder;
        selectedPath = String(selectedFolder?.path || selectedPath || "");
        if (selectedPath) LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = selectedPath;
      }
      if (!selectedFolder && folders.length) {
        const preferredIndex = getPreferredGlobalFolderIndex(folders);
        const fallbackIndex = preferredIndex >= 0 ? preferredIndex : 0;
        selectedFolder = folders[fallbackIndex] || null;
        selectedPath = String(selectedFolder?.path || "");
        if (selectedPath) LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = selectedPath;
      }
      let playableClips = getSaeivGlobalFolderPlayableClips(selectedFolder);
      if (!playableClips.length) {
        const ratpFallback = findSaeivRatpGlobalFolder(folders, { requirePlayable: true })
          || findSaeivRatpGlobalFolder(allFolders, { requirePlayable: true });
        if (ratpFallback) {
          selectedFolder = ratpFallback;
          selectedPath = String(ratpFallback?.path || "");
          if (selectedPath) LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = selectedPath;
          playableClips = getSaeivGlobalFolderPlayableClips(ratpFallback);
        }
      }
      if (!playableClips.length && folders.length) {
        const fallbackFolder = folders.find((folder) => {
          return getSaeivGlobalFolderPlayableClips(folder).length > 0;
        }) || null;
        if (fallbackFolder) {
          selectedFolder = fallbackFolder;
          selectedPath = String(fallbackFolder?.path || "");
          if (selectedPath) LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = selectedPath;
          playableClips = getSaeivGlobalFolderPlayableClips(fallbackFolder);
        }
      }
      const labels = playableClips
        .map((clipName) => {
          const meta = parseLinePreviewAudioGlobalClipMeta(clipName);
          return String(meta?.label || clipName || "").trim();
        })
        .filter(Boolean);
      const urls = selectedPath
        ? playableClips.map((clipName) => linePreviewAudioClipUrl(selectedPath, clipName))
        : [];
      const folderMeta = parseLinePreviewAudioGlobalFolderMeta(selectedFolder?.name || "");
      const volumeMultiplier = Number.isFinite(Number(folderMeta?.volumeMultiplier))
        ? Number(folderMeta.volumeMultiplier)
        : 1;
      return {
        globalAudioFolderPath: selectedPath,
        globalAudioLabels: labels,
        globalAudioUrls: urls,
        globalAudioCount: labels.length,
        globalAudioVolumeMultiplier: volumeMultiplier
      };
    }
    function buildSaeivStatePayload(){
      const info = getSaeivSelectedInfo();
      const audioLinkedState = buildSaeivAudioLinkedState(info);
      const hasLineSelected = !!String(currentSelectedLineUid || "").trim() || !!String(currentSelectedKey || "").trim();
      const hasRouteSelected = !!String(currentSelectedKey || "").trim();
      const globalAudioState = buildSaeivGlobalAudioState({ forceRatpDefault: !hasRouteSelected });
      return {
        lang: String(LANG || "fr"),
        canUseFeature: SAEIV_FEATURE_ALLOWED && isLinePreviewAudioLanguageAllowed() && !!SAEIV_PANEL_BUTTON_ENABLED,
        selected: info.selected,
        lineSelected: hasLineSelected,
        routeSelected: hasRouteSelected,
        selectedKey: info.key,
        selectedLineUid: info.lineUid,
        selectedRouteUid: info.routeUid,
        lineNumber: info.lineNumber,
        routeName: info.routeName,
        ...audioLinkedState,
        ...globalAudioState,
        audioPlaybackBusy: !!LINE_PREVIEW_AUDIO_PLAYBACK.isPlaying,
        lastAction: SAEIV_PANEL_STATE.lastAction || ""
      };
    }
    function postSaeivMessage(message){
      const channel = ensureSaeivChannel();
      if (!channel) return false;
      try {
        channel.postMessage({ ...message, sourceId: SAEIV_PANEL_STATE.sourceId });
        return true;
      } catch {
        return false;
      }
    }
    function syncSaeivExternalState({ force = false } = {}){
      if (!isSaeivPanelOpen()) return;
      const payload = buildSaeivStatePayload();
      const key = JSON.stringify(payload);
      if (!force && key === SAEIV_PANEL_STATE.lastStateKey) return;
      SAEIV_PANEL_STATE.lastStateKey = key;
      postSaeivMessage({ type: "saeiv:state", payload });
    }
    function handleSaeivWindowClosed({ update = true } = {}){
      const win = SAEIV_PANEL_STATE.win;
      const pipCloseHandler = SAEIV_PANEL_STATE.pipCloseHandler;
      if (win && pipCloseHandler) {
        try { win.removeEventListener("pagehide", pipCloseHandler); } catch {}
      }
      if (SAEIV_PANEL_STATE.closeWatchTimer) {
        clearInterval(SAEIV_PANEL_STATE.closeWatchTimer);
        SAEIV_PANEL_STATE.closeWatchTimer = null;
      }
      SAEIV_PANEL_STATE.win = null;
      SAEIV_PANEL_STATE.pipCloseHandler = null;
      SAEIV_PANEL_STATE.usingDocumentPiP = false;
      SAEIV_PANEL_STATE.lastStateKey = "";
      if (update && typeof updateUiOverlays === "function") {
        try { updateUiOverlays(); } catch {}
      }
    }
    function isSaeivPanelOpen(){
      const win = SAEIV_PANEL_STATE.win;
      return !!(win && !win.closed);
    }
    function startSaeivCloseWatcher(){
      if (SAEIV_PANEL_STATE.closeWatchTimer) return;
      SAEIV_PANEL_STATE.closeWatchTimer = setInterval(() => {
        const win = SAEIV_PANEL_STATE.win;
        if (win && !win.closed) return;
        handleSaeivWindowClosed({ update: true });
      }, 400);
    }
    function isSaeivDocumentPiPSupported(){
      return !!(window.documentPictureInPicture && typeof window.documentPictureInPicture.requestWindow === "function");
    }
    async function openSaeivPanelInDocumentPiP(width, height, url){
      if (!isSaeivDocumentPiPSupported()) return null;
      let pipWindow = null;
      try {
        pipWindow = await window.documentPictureInPicture.requestWindow({ width, height });
      } catch {
        return null;
      }
      if (!pipWindow) return null;
      const doc = pipWindow.document;
      try {
        doc.title = "Ecran SAEIV";
        doc.body.innerHTML = "";
        const style = doc.createElement("style");
        style.textContent = `
          html, body { margin: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
          iframe { display: block; width: 100%; height: 100%; border: 0; background: #000; }
        `;
        doc.head.appendChild(style);
        const frame = doc.createElement("iframe");
        frame.src = url.toString();
        frame.title = "Ecran SAEIV";
        doc.body.appendChild(frame);
      } catch {}
      return pipWindow;
    }
    async function openSaeivPanel(){
      if (!SAEIV_FEATURE_ALLOWED) return false;
      const currentWin = SAEIV_PANEL_STATE.win;
      if (currentWin && !currentWin.closed) {
        try { currentWin.focus(); } catch {}
        syncSaeivExternalState({ force: true });
        return true;
      }
      const ratio = Number.isFinite(SAEIV_ASPECT_RATIO) && SAEIV_ASPECT_RATIO > 0 ? SAEIV_ASPECT_RATIO : (16 / 9);
      const screenAvailW = Math.max(140, Math.round(Number(window.screen?.availWidth) || window.innerWidth || 140));
      const screenAvailH = Math.max(120, Math.round(Number(window.screen?.availHeight) || window.innerHeight || 120));
      const maxWindowWidth = Math.max(120, screenAvailW - 12);
      const maxWindowHeight = Math.max(100, screenAvailH - 12);
      const widthByHeight = Math.max(120, Math.min(maxWindowWidth, Math.round(maxWindowHeight * ratio)));
      let width = Math.max(120, Math.min(widthByHeight, Math.round(window.innerWidth * 0.62)));
      let height = Math.max(100, Math.round(width / ratio));
      if (height > maxWindowHeight) {
        height = maxWindowHeight;
        width = Math.max(120, Math.min(maxWindowWidth, Math.round(height * ratio)));
      }
      if (width > maxWindowWidth) {
        width = maxWindowWidth;
        height = Math.max(100, Math.min(maxWindowHeight, Math.round(width / ratio)));
      }
      const availLeft = Number(window.screen?.availLeft);
      const availTop = Number(window.screen?.availTop);
      const minLeft = Number.isFinite(availLeft) ? Math.round(availLeft) : 0;
      const minTop = Number.isFinite(availTop) ? Math.round(availTop) : 0;
      const maxLeft = Math.max(minLeft, minLeft + screenAvailW - width);
      const maxTop = Math.max(minTop, minTop + screenAvailH - height);
      const centeredLeft = Math.round(window.screenX + ((window.outerWidth - width) / 2));
      const centeredTop = Math.round(window.screenY + ((window.outerHeight - height) / 2));
      const left = Math.max(minLeft, Math.min(maxLeft, centeredLeft));
      const top = Math.max(minTop, Math.min(maxTop, centeredTop));
      const url = new URL("saeiv.html", location.href);
      url.searchParams.set("source", SAEIV_PANEL_STATE.sourceId);
      if (SAEIV_DEV_MODE) {
        const win = window.open(url.toString(), "_blank");
        if (!win) return false;
        SAEIV_PANEL_STATE.win = win;
        SAEIV_PANEL_STATE.usingDocumentPiP = false;
        SAEIV_PANEL_STATE.pipCloseHandler = null;
        SAEIV_PANEL_STATE.lastStateKey = "";
        ensureSaeivChannel();
        startSaeivCloseWatcher();
        syncSaeivExternalState({ force: true });
        return true;
      }
      const pipWindow = await openSaeivPanelInDocumentPiP(width, height, url);
      if (pipWindow) {
        SAEIV_PANEL_STATE.win = pipWindow;
        SAEIV_PANEL_STATE.usingDocumentPiP = true;
        SAEIV_PANEL_STATE.lastStateKey = "";
        ensureSaeivChannel();
        const onClose = () => handleSaeivWindowClosed({ update: true });
        SAEIV_PANEL_STATE.pipCloseHandler = onClose;
        try { pipWindow.addEventListener("pagehide", onClose, { once: true }); } catch {}
        try { pipWindow.focus(); } catch {}
        syncSaeivExternalState({ force: true });
        return true;
      }
      const features = [
        "popup=yes",
        "resizable=yes",
        "scrollbars=no",
        "toolbar=no",
        "location=no",
        "menubar=no",
        "status=no",
        `width=${width}`,
        `height=${height}`,
        `left=${left}`,
        `top=${top}`
      ].join(",");
      const win = window.open(url.toString(), `idf_map_saeiv_${SAEIV_PANEL_STATE.sourceId}`, features);
      if (!win) return false;
      SAEIV_PANEL_STATE.win = win;
      SAEIV_PANEL_STATE.usingDocumentPiP = false;
      SAEIV_PANEL_STATE.pipCloseHandler = null;
      SAEIV_PANEL_STATE.lastStateKey = "";
      ensureSaeivChannel();
      startSaeivCloseWatcher();
      syncSaeivExternalState({ force: true });
      return true;
    }
    function closeSaeivPanel({ update = true } = {}){
      const win = SAEIV_PANEL_STATE.win;
      const pipCloseHandler = SAEIV_PANEL_STATE.pipCloseHandler;
      if (win && pipCloseHandler) {
        try { win.removeEventListener("pagehide", pipCloseHandler); } catch {}
      }
      if (win && !win.closed) {
        try { win.close(); } catch {}
      }
      handleSaeivWindowClosed({ update });
    }
    function refreshSaeivTopButtonVisibility(){
      const btn = document.getElementById("btnSaeivPanel");
      if (!btn) return;
      const canOpen = SAEIV_FEATURE_ALLOWED && isLinePreviewAudioLanguageAllowed() && !!SAEIV_PANEL_BUTTON_ENABLED;
      if (!canOpen) {
        closeSaeivPanel({ update: false });
      }
      btn.hidden = !canOpen;
      btn.style.display = canOpen ? "" : "none";
      setButtonDisabled(btn, false);
      const opened = isSaeivPanelOpen();
      btn.classList.toggle("is-open", opened);
      btn.setAttribute("aria-expanded", opened ? "true" : "false");
    }
    function refreshLinePreviewAudioTopButtonVisibility({ closePanelOnHide = false } = {}){
      const btn = document.getElementById("btnAudioPanel");
      if (!btn) return;
      const canShow = isLinePreviewAudioLanguageAllowed() && !!AUDIO_PANEL_BUTTON_ENABLED;
      btn.hidden = !canShow;
      btn.style.display = canShow ? "" : "none";
      if (!canShow) {
        btn.classList.remove("is-open");
        btn.setAttribute("aria-expanded", "false");
        if (closePanelOnHide && isLinePreviewAudioPanelOpen()) {
          closeLinePreviewAudioPanel({ stopPlayback: true });
        }
      }
    }
    function refreshLinePreviewAudioButtonVisibility({ closePanelOnHide = false } = {}){
      const audioLink = document.getElementById("lpAudioLink");
      if (!audioLink) return;
      const hasAudioFeature = String(audioLink.dataset.audioAvailable || "") === "1";
      const canShow = hasAudioFeature && isLinePreviewAudioLanguageAllowed();
      audioLink.hidden = !canShow;
      audioLink.style.display = canShow ? "" : "none";
      if (canShow) audioLink.href = "#";
      else audioLink.removeAttribute("href");
      if (!canShow && closePanelOnHide) closeLinePreviewAudioPanel({ stopPlayback: true });
    }
    function setLinePreviewAudioButtonState({ visible = false, href = "", routeAudioReady = false } = {}){
      const audioLink = document.getElementById("lpAudioLink");
      if (!audioLink) return;
      if (visible) {
        audioLink.dataset.audioAvailable = "1";
        audioLink.dataset.routeAudioReady = routeAudioReady ? "1" : "0";
        audioLink.classList.toggle("is-route-missing", !routeAudioReady);
        if (href) audioLink.dataset.audioFolder = String(href || "");
        else delete audioLink.dataset.audioFolder;
        refreshLinePreviewAudioButtonVisibility({ closePanelOnHide: false });
        return;
      }
      delete audioLink.dataset.audioAvailable;
      delete audioLink.dataset.routeAudioReady;
      delete audioLink.dataset.audioFolder;
      audioLink.classList.remove("is-route-missing");
      refreshLinePreviewAudioButtonVisibility();
    }
    function updateLinePreviewAudioButton(line, route){
      const token = ++linePreviewAudioCheckToken;
      setLinePreviewAudioGlobalProfileForLine(line, route);
      setLinePreviewAudioGlobalTypeTokensForLine(line, route);
      setLinePreviewAudioButtonState({ visible: false, routeAudioReady: false });
      clearLinePreviewAudioRouteState({ closePanel: false, stopPlayback: true });
      const globalReadyPromise = Promise.resolve(ensureLinePreviewAudioGlobalFoldersLoaded())
        .catch(() => {})
        .then(() => hasLinePreviewAudioGlobalPlayableClip());
      const routeCoveragePromise = isLinePreviewAudioAllowedForLine(line, route)
        ? getRouteAudioCoverage(line, route)
        : Promise.resolve({ ok: false, href: "", missingByFolder: [] });
      Promise.all([globalReadyPromise, routeCoveragePromise]).then(([hasGlobalPlayable, status]) => {
        if (token !== linePreviewAudioCheckToken) return;
        const routeReady = !!(status?.ok && status?.href);
        if (!routeReady) {
          const groups = Array.isArray(status?.missingByFolder) ? status.missingByFolder : [];
          if (groups.length) {
            groups.forEach((group) => {
              const lineLabel = String(group?.line || getLineNumber(line, route) || line?.number || "?").trim();
              const routeLabel = String(group?.route || route?.name || "").trim();
              const folderLabel = String(group?.folder || "").trim() || "(racine)";
              const missingStops = Array.isArray(group?.missingStops)
                ? group.missingStops.map((s) => String(s || "").trim()).filter(Boolean)
                : [];
              if (!missingStops.length) return;
              console.warn(
                `[Audio][Stops manquants] ligne=${lineLabel} route="${routeLabel}" dossier="${folderLabel}"`,
                missingStops
              );
            });
          } else if (status?.reason) {
            const lineLabel = String(getLineNumber(line, route) || line?.number || "?").trim();
            const routeLabel = String(route?.name || "").trim();
            console.warn(
              `[Audio][Stops manquants] ligne=${lineLabel} route="${routeLabel}" reason=${String(status.reason)}`
            );
          }
          clearLinePreviewAudioRouteState({ closePanel: false, stopPlayback: true });
        } else {
          setLinePreviewAudioRouteState(route, status);
        }
        const visible = !!hasGlobalPlayable || routeReady;
        if (!visible) {
          setLinePreviewAudioButtonState({ visible: false, routeAudioReady: false });
          return;
        }
        setLinePreviewAudioButtonState({
          visible: true,
          href: routeReady ? status.href : "",
          routeAudioReady: routeReady
        });
      }).catch(() => {
        if (token !== linePreviewAudioCheckToken) return;
        clearLinePreviewAudioRouteState({ closePanel: false, stopPlayback: true });
        const hasGlobalPlayable = hasLinePreviewAudioGlobalPlayableClip();
        setLinePreviewAudioButtonState({ visible: !!hasGlobalPlayable, routeAudioReady: false });
      });
    }

    let DBUS_STOPS = new Map();
    let dbusStopLineEntries = new Map();
    let dbusStopMarkers = new Map();
    const DBUS_STOP_ICON_CACHE = new Map();
    const DBUS_STOP_NON_MAX_RATIO = 0.75;
    const DBUS_STOP_MERGE_FACTOR = 1.05;
    let dbusStopIconSizePx = 0;
    function getOverlayIconPixelSize(baseWidth = MAP_ICON_UNIFORM_SIZE, zoom = map.getZoom()){
      if (!TileMapInfo) return Math.max(4, Math.round(baseWidth));
      const cx = (TileMapInfo.x1 + TileMapInfo.x2) / 2;
      const cy = (TileMapInfo.y1 + TileMapInfo.y2) / 2;
      const worldW = baseWidth * getOverlayZoomScale(zoom);
      const left = toLatLng(cx - (worldW / 2), cy);
      const right = toLatLng(cx + (worldW / 2), cy);
      const p1 = map.project(left, zoom);
      const p2 = map.project(right, zoom);
      return Math.max(2, Math.round(Math.abs(p2.x - p1.x)));
    }
    function getDbusStopIconSize(zoom = map.getZoom()){
      const basePx = getOverlayIconPixelSize(MAP_ICON_UNIFORM_SIZE, zoom);
      return Math.max(2, Math.round(basePx * DBUS_STOP_NON_MAX_RATIO));
    }
    function shouldShowStopClusterCount(zoom = map.getZoom()){
      return zoom >= (map.getMaxZoom() - 2);
    }
    function getDbusStopIcon(sizePx, count = 1, { showCount = true } = {}){
      const size = Math.max(4, Math.round(Number(sizePx) || 0));
      const safeCount = Math.max(1, Math.round(Number(count) || 1));
      const key = `${size}:${safeCount}:${showCount ? 1 : 0}`;
      if (DBUS_STOP_ICON_CACHE.has(key)) return DBUS_STOP_ICON_CACHE.get(key);
      const countHtml = (showCount && safeCount > 1) ? `<span class="dbus-stop-marker-count">${safeCount}</span>` : "";
      const icon = L.divIcon({
        className: "dbus-stop-marker-host",
        html: `
          <div class="dbus-stop-marker-wrap" style="width:${size}px;height:${size}px;">
            <img class="dbus-stop-marker" src="${overlayPath("bus_logo_idfm.png")}" alt="" aria-hidden="true"/>
            ${countHtml}
          </div>
        `,
        iconSize: [size, size],
        iconAnchor: [Math.round(size / 2), Math.round(size / 2)]
      });
      DBUS_STOP_ICON_CACHE.set(key, icon);
      return icon;
    }
    function isDbusLineVisibleForStopMarkers(line){
      const cat = getCategory(line);
      if (!showSchoolLines && cat === "Scolaire") return false;
      if (!showFictiveLines && cat === "Autres") return false;
      return true;
    }
    function collectVisibleStopLineEntries(stopIds){
      const ids = Array.isArray(stopIds) ? stopIds : [stopIds];
      const byLineUid = new Map();
      ids.forEach(stopId => {
        const entries = dbusStopLineEntries.get(stopId) || [];
        entries.forEach(entry => {
          if (!entry?.line || !entry?.route) return;
          if (!isDbusLineVisibleForStopMarkers(entry.line)) return;
          const uid = String(entry.line.uid || "");
          if (!uid || byLineUid.has(uid)) return;
          byLineUid.set(uid, entry);
        });
      });
      return [...byLineUid.values()].sort((a, b) => {
        const aNum = String(getLineNumber(a.line, a.route) || "").trim();
        const bNum = String(getLineNumber(b.line, b.route) || "").trim();
        const aIsNum = /^\d+$/.test(aNum);
        const bIsNum = /^\d+$/.test(bNum);
        if (aIsNum && bIsNum) return (parseInt(aNum, 10) || 0) - (parseInt(bNum, 10) || 0);
        if (aIsNum !== bIsNum) return aIsNum ? -1 : 1;
        const cmp = aNum.localeCompare(bNum, "fr", { numeric: true, sensitivity: "base" });
        if (cmp !== 0) return cmp;
        return String(a.line.uid || "").localeCompare(String(b.line.uid || ""), "fr", { numeric: true, sensitivity: "base" });
      });
    }
    function getVisibleStopLineEntries(stopId){
      return collectVisibleStopLineEntries(stopId);
    }
    function buildDbusStopLineEntries(){
      const next = new Map();
      DBUS_LINES.forEach(line => {
        (line.routes || []).forEach(route => {
          (route.stops || []).forEach(stopRef => {
            const stopId = Number(stopRef?.uid);
            if (!Number.isFinite(stopId) || !DBUS_STOPS.has(stopId)) return;
            if (!next.has(stopId)) next.set(stopId, []);
            next.get(stopId).push({ line, route });
          });
        });
      });
      dbusStopLineEntries = next;
    }
    function isTitusEntry(entry){
      if (!entry?.line) return false;
      const lineNum = String(getLineNumber(entry.line, entry.route) || "").trim();
      return isTitusLine(entry.line) || /^titus\s*\d+/i.test(lineNum);
    }
    function getStopBadgeSize(label){
      const raw = String(label || "").trim();
      if (/^express\b/i.test(raw)) return "128x26";
      return "62x26";
    }
    function getStopEntryLineLabel(entry){
      const routeName = String(entry?.route?.name || "").trim();
      const lineLabel = String(getLineNumber(entry?.line, entry?.route) || "?").trim();
      const parsed = parseRouteName(routeName || "");
      const parsedNumber = String(parsed?.lineNumber || "").trim();
      if (/^express\b/i.test(parsedNumber) && /\d/.test(parsedNumber)) {
        return parsedNumber.replace(/\s+/g, " ").trim();
      }
      const routeExpressMatch = routeName.match(/\bexpress\s*(\d+)/i);
      if (routeExpressMatch && routeExpressMatch[1]) {
        return `Express ${routeExpressMatch[1]}`.replace(/\s+/g, " ").trim();
      }
      if (/^express\b/i.test(lineLabel)) {
        const n = (parsedNumber.match(/\d+/) || routeExpressMatch || routeName.match(/\d+/) || [])[0];
        if (n) return `Express ${n}`;
      }
      return lineLabel;
    }
    function getFictiveBadgeLabel(entry){
      const routeName = String(entry?.route?.name || "").trim();
      const lineRaw = String(entry?.line?.number || "").trim();
      const parsed = parseRouteName(routeName || lineRaw || "");
      const parsedNumber = String(parsed?.lineNumber || "").trim();
      const merged = `${routeName} ${lineRaw} ${parsedNumber}`;
      if (/express/i.test(merged)) {
        let label = [parsedNumber, lineRaw].find(v => /^express\b/i.test(String(v || "").trim())) || "";
        const routeMatch = routeName.match(/\bexpress\s*(\d+)/i);
        if (label && /^express\b$/i.test(label) && routeMatch && routeMatch[1]) {
          label = `Express ${routeMatch[1]}`;
        }
        if (!label) {
          const n = (parsedNumber.match(/\d+/) || lineRaw.match(/\d+/) || routeName.match(/\d+/) || [])[0];
          label = n ? `Express ${n}` : "Express";
        }
        return label.replace(/\s+/g, " ").trim();
      }
      if (/autocar/i.test(merged)) return "Autocar";
      if (parsedNumber && !/fict/i.test(parsedNumber)) return parsedNumber;
      if (lineRaw && lineRaw !== "?" && !/fict/i.test(lineRaw)) return lineRaw;
      return "Fictive";
    }
    function getStopEntryVisual(entry){
      if (isTitusEntry(entry)) return { kind: "none" };
      const cat = getCategory(entry?.line);
      if (cat === "Scolaire") return { kind: "school" };

      let label = getStopEntryLineLabel(entry);
      if (cat === "Autres") label = getFictiveBadgeLabel(entry);
      const colorKey = (cat === "Autres")
        ? label
        : routeColorKey(entry.line, entry.route, label);
      const [bg, text] = getLineColorsSync(colorKey || label);
      const stripe = isNoctilien2(label) ? noctilienStripeColor(label) : null;
      return { kind: "badge", label, bg, text, stripe };
    }
    function getStopMergeDistancePx(){
      return Math.max(10, Math.round(getDbusStopIconSize() * DBUS_STOP_MERGE_FACTOR));
    }
    function clusterVisibleStops(stops){
      const zoom = map.getZoom();
      const mergePx = getStopMergeDistancePx();
      const clusters = [];
      stops.forEach(stop => {
        const pt = map.project(stop.latlng, zoom);
        let target = null;
        let bestDist = Number.POSITIVE_INFINITY;
        clusters.forEach(cluster => {
          const dx = pt.x - cluster.px.x;
          const dy = pt.y - cluster.px.y;
          const dist = Math.hypot(dx, dy);
          if (dist < mergePx && dist < bestDist) {
            bestDist = dist;
            target = cluster;
          }
        });
        if (!target) {
          clusters.push({
            stops: [stop],
            stopIds: [stop.id],
            sumLat: stop.latlng.lat,
            sumLng: stop.latlng.lng,
            px: { x: pt.x, y: pt.y }
          });
          return;
        }
        target.stops.push(stop);
        target.stopIds.push(stop.id);
        const n = target.stops.length;
        target.sumLat += stop.latlng.lat;
        target.sumLng += stop.latlng.lng;
        target.px.x = ((target.px.x * (n - 1)) + pt.x) / n;
        target.px.y = ((target.px.y * (n - 1)) + pt.y) / n;
      });
      return clusters.map(cluster => ({
        ...cluster,
        latlng: L.latLng(cluster.sumLat / cluster.stops.length, cluster.sumLng / cluster.stops.length)
      }));
    }
    function stopClusterTitle(cluster){
      if (!cluster?.stops?.length) return "";
      if (cluster.stops.length === 1) {
        const stop = cluster.stops[0];
        return withRERIcon(translateStopName(stripProvisoire(stop?.name || "")));
      }
      const names = [];
      const seen = new Set();
      cluster.stops.forEach(stop => {
        const raw = String(stop?.name || "").trim();
        if (!raw) return;
        const translated = translateStopName(stripProvisoire(raw)).trim();
        if (!translated) return;
        const key = translated.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        names.push(withRERIcon(translated));
      });
      if (names.length) return names.join(" / ");
      return `${formatStopCount(cluster.stops.length)} (${t("dbus_mode_stops")})`;
    }
    function stopClusterUniqueNameCount(cluster){
      if (!cluster?.stops?.length) return 0;
      const seen = new Set();
      cluster.stops.forEach(stop => {
        const raw = stripProvisoire(String(stop?.name || "")).trim();
        if (!raw) {
          seen.add(`id:${String(stop?.id ?? "")}`);
          return;
        }
        seen.add(raw.toLocaleLowerCase("fr"));
      });
      return Math.max(1, seen.size);
    }
    function openDbusStopLinesPopup(marker, cluster){
      if (!marker || !cluster) return;
      const entries = collectVisibleStopLineEntries(cluster.stopIds || []);
      if (!entries.length) {
        marker.closePopup();
        return;
      }
      const content = document.createElement("div");
      content.className = "dbus-stop-lines-popup";

      const title = document.createElement("div");
      title.className = "dbus-stop-lines-title";
      title.innerHTML = stopClusterTitle(cluster);
      content.appendChild(title);

      const badges = document.createElement("div");
      badges.className = "dbus-stop-lines-badges";
      entries.forEach(entry => {
        const activate = (opts = {}) => selectDbusLineRouteFromStopEntry(entry, opts);
        const visual = getStopEntryVisual(entry);
        if (visual.kind === "school") {
          const schoolLogo = document.createElement("img");
          schoolLogo.className = "dbus-stop-line-school-logo";
          schoolLogo.src = overlayPath("bus_school.png");
          schoolLogo.alt = "Scolaire";
          schoolLogo.style.cursor = "pointer";
          schoolLogo.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            activate();
          });
          badges.appendChild(schoolLogo);
          return;
        }
        if (visual.kind === "none") {
          const titusLogo = document.createElement("img");
          titusLogo.className = "dbus-stop-lines-logo";
          titusLogo.src = overlayPath("reseau_titus.png");
          titusLogo.alt = "Reseau Titus";
          titusLogo.style.cursor = "pointer";
          titusLogo.addEventListener("click", (event) => {
            event.preventDefault();
            event.stopPropagation();
            activate();
          });
          badges.appendChild(titusLogo);
          return;
        }
        if (visual.kind !== "badge") return;
        const badge = makeLineBadge(visual.label, visual.bg, visual.text, getStopBadgeSize(visual.label), visual.stripe);
        badge.classList.add("dbus-stop-line-badge");
        badge.style.cursor = "pointer";
        badge.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          const rawLabel = String(visual.label || "").trim();
          let forcedGroupUid = "";
          if (/^express\b/i.test(rawLabel)) {
            const expressPart = rawLabel.replace(/^express\b/i, "").trim() || "express";
            forcedGroupUid = `group:express:${normalizeBadgeToken(expressPart)}`;
          } else if (/^autocar\b/i.test(rawLabel)) {
            forcedGroupUid = "group:autocar";
          }
          activate({ groupUid: forcedGroupUid });
        });
        badges.appendChild(badge);
      });
      if (!badges.childNodes.length) {
        marker.closePopup();
        return;
      }
      content.appendChild(badges);

      map.closePopup();
      if (marker.getPopup()) marker.unbindPopup();
      marker.bindPopup(content, { maxWidth: 420, autoPan: false, className: "dbus-stop-lines-popup-wrap" });
      marker.openPopup();
    }
    function refreshDbusStopMarkerScale(){
      renderDbusStopsLayer();
    }
    function renderDbusStopsLayer(){
      if (!dbusStopsLayer) return;
      dbusStopsLayer.clearLayers();
      dbusStopMarkers = new Map();
      if (!DBUS_STOP_ICONS_ENABLED) return;
      dbusStopIconSizePx = getDbusStopIconSize();
      const visibleStops = [];
      DBUS_STOPS.forEach(stop => {
        if (!stop?.latlng) return;
        if (!Number.isFinite(stop.latlng.lat) || !Number.isFinite(stop.latlng.lng)) return;
        const visibleLines = getVisibleStopLineEntries(stop.id);
        if (!visibleLines.length) return;
        visibleStops.push(stop);
      });
      const clusters = clusterVisibleStops(visibleStops);
      const showClusterCount = shouldShowStopClusterCount();
      clusters.forEach(cluster => {
        const iconCount = stopClusterUniqueNameCount(cluster);
        const icon = getDbusStopIcon(dbusStopIconSizePx, iconCount, { showCount: showClusterCount });
        const marker = L.marker(cluster.latlng, {
          icon,
          interactive: true,
          keyboard: false,
          bubblingMouseEvents: false,
          riseOnHover: true
        });
        marker.on("click", (event) => {
          if (event) L.DomEvent.stopPropagation(event);
          openDbusStopLinesPopup(marker, cluster);
        });
        dbusStopsLayer.addLayer(marker);
        const key = cluster.stops.length === 1
          ? `s:${cluster.stops[0].id}`
          : `c:${cluster.stopIds.join(",")}`;
        dbusStopMarkers.set(key, marker);
      });
    }
    map.on("zoomend", refreshDbusStopMarkerScale);
    async function loadStops(){
      await tileInfoReady;
      const xml = await fetchXml(`${dbusRoot}/stops.xml`);
      const nodes = [...xml.querySelectorAll("busstops > busstop")];
      DBUS_STOPS = new Map(nodes.map(node=>{
        const id = parseInt(node.querySelector("id")?.textContent.trim()||"0",10);
        const name = (node.querySelector("name")?.textContent||"").trim();
        const locRaw = (node.querySelector("location")?.textContent||"").trim();
        const parts = locRaw.split(";").map(x=>parseFloat(x));

        const X = parts[0] ?? 0;
        const Y = parts[1] ?? 0;
        const Z = parts[2] ?? 0;
        const rotX = parts[3] ?? 0;
        const rotY = parts[4] ?? 0;

        const latlng = toLatLng(X, Z);
        return [id, {id, name, X, Y, Z, rotX, rotY, latlng}];
      }));
    }

    let DBUS_LINES = [];
    async function loadLines(){
      const xml = await fetchXml(`${dbusRoot}/lines.xml`);
      const seenLineUids = new Map();
      DBUS_LINES = [...xml.querySelectorAll("lines > line")].map((line, lineIndex) => {
        const rawUid = String(line.getAttribute("uid") || "").trim();
        const number  = line.getAttribute("number") || "?";
        const uidBase = rawUid || `line_${lineIndex}`;
        const seenCount = (seenLineUids.get(uidBase) || 0) + 1;
        seenLineUids.set(uidBase, seenCount);
        const safeNumber = String(number || "")
          .toLowerCase()
          .replace(/[^a-z0-9_-]+/g, "_")
          .replace(/^_+|_+$/g, "") || "line";
        // lines.xml can contain duplicated line uid values (e.g. 210/221), so build a collision-safe uid.
        const lineUid = seenCount === 1 ? uidBase : `${uidBase}__${safeNumber}__${lineIndex}`;

        const routes = [...line.querySelectorAll(":scope > route")].map(rt=>{
          const rUid  = rt.getAttribute("uid");
          const rName = rt.getAttribute("name") || "";
          const stops = [...rt.querySelectorAll(":scope > busstop")].map(b => {
            return {
              uid: parseInt(b.getAttribute("uid"), 10),
              nextStopTime: parseInt(b.getAttribute("nextStopTime") || "0", 10)
            };
          });

          const totalMinutes = stops.reduce((sum, s) => sum + (s.nextStopTime || 0), 0);

          return { uid: rUid, name: rName, stops, totalMinutes };
        });

        return { uid: lineUid, uidRaw: rawUid, number, routes };
      });
    }

    function resetDbusNavGraphState(){
      DBUS_NAV_GRAPH = null;
      dbusNavNodesByStopId.clear();
      dbusNavPathCache.clear();
    }
    function resetDbusNavBridgeState(){
      DBUS_NAV_BRIDGES = [];
    }
    function createDbusMinHeap(){
      const arr = [];
      const swap = (a, b) => {
        const tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
      };
      const bubbleUp = (index) => {
        let i = index;
        while (i > 0) {
          const parent = Math.floor((i - 1) / 2);
          if (arr[parent].f <= arr[i].f) break;
          swap(parent, i);
          i = parent;
        }
      };
      const bubbleDown = (index) => {
        let i = index;
        for (;;) {
          const left = (i * 2) + 1;
          const right = left + 1;
          let smallest = i;
          if (left < arr.length && arr[left].f < arr[smallest].f) smallest = left;
          if (right < arr.length && arr[right].f < arr[smallest].f) smallest = right;
          if (smallest === i) break;
          swap(i, smallest);
          i = smallest;
        }
      };
      return {
        push(item){
          arr.push(item);
          bubbleUp(arr.length - 1);
        },
        pop(){
          if (!arr.length) return null;
          const first = arr[0];
          const last = arr.pop();
          if (arr.length && last) {
            arr[0] = last;
            bubbleDown(0);
          }
          return first;
        },
        get size(){
          return arr.length;
        }
      };
    }
    function appendUniqueWorldPoint(target, point){
      if (!point) return;
      const x = Number(point.x);
      const y = Number(point.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return;
      const last = target[target.length - 1];
      if (last && Math.abs(last.x - x) < 0.001 && Math.abs(last.y - y) < 0.001) return;
      target.push({ x, y });
    }
    function buildDbusNavGraph(raw){
      const nodes = Array.isArray(raw?.nodes) ? raw.nodes : [];
      const edges = Array.isArray(raw?.edges) ? raw.edges : [];
      if (!nodes.length || !edges.length) return null;
      const nodesById = new Map();
      const nodeList = [];
      nodes.forEach((node) => {
        const id = Number(node?.id);
        const x = Number(node?.x);
        const y = Number(node?.y);
        if (!Number.isFinite(id) || !Number.isFinite(x) || !Number.isFinite(y)) return;
        const rec = {
          id,
          x,
          y,
          kind: String(node?.kind || ""),
          prefabId: node?.prefab_id ?? null,
          connectorId: node?.connector_id ?? null
        };
        nodesById.set(id, rec);
        nodeList.push(rec);
      });
      if (!nodeList.length) return null;
      const adjacency = new Map();
      const edgeList = [];
      const edgesById = new Map();
      const addTransition = (from, to, weight, points, reverse = false, edgeId = null) => {
        if (!adjacency.has(from)) adjacency.set(from, []);
        adjacency.get(from).push({ from, to, weight, points, reverse, edgeId });
      };
      edges.forEach((edge) => {
        const edgeId = Number(edge?.id);
        const from = Number(edge?.from);
        const to = Number(edge?.to);
        const fromNode = nodesById.get(from);
        const toNode = nodesById.get(to);
        if (!fromNode || !toNode) return;
        let weight = Number(edge?.length);
        if (!Number.isFinite(weight) || weight <= 0) {
          weight = Math.hypot(fromNode.x - toNode.x, fromNode.y - toNode.y);
        }
        const points = Array.isArray(edge?.polyline)
          ? edge.polyline
              .map((pt) => ({ x: Number(pt?.x), y: Number(pt?.y) }))
              .filter((pt) => Number.isFinite(pt.x) && Number.isFinite(pt.y))
          : [];
        const safePoints = points.length
          ? points
          : [{ x: fromNode.x, y: fromNode.y }, { x: toNode.x, y: toNode.y }];
        const edgeRec = {
          id: edgeId,
          from,
          to,
          oneWay: !!edge?.one_way,
          length: weight,
          look: String(edge?.look || ""),
          flags: edge?.flags && typeof edge.flags === "object" ? edge.flags : null,
          polyline: safePoints
        };
        edgeList.push(edgeRec);
        if (Number.isFinite(edgeId)) edgesById.set(edgeId, edgeRec);
        addTransition(from, to, weight, points, false, edgeId);
        if (!edge?.one_way) addTransition(to, from, weight, points, true, edgeId);
      });
      return { nodesById, nodeList, adjacency, edgeList, edgesById };
    }
    async function loadDbusNavGraph(){
      resetDbusNavGraphState();
      let res;
      try {
        res = await fetch(dataPath("nav_graph.json"), { cache: "no-store" });
      } catch {
        return;
      }
      if (!res.ok) return;
      try {
        const raw = await res.json();
        DBUS_NAV_GRAPH = buildDbusNavGraph(raw);
      } catch (err) {
        console.warn("DBus nav_graph.json invalide", err);
      }
    }
    function normalizeNavBridgeText(value){
      return String(value || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/\s+/g, " ")
        .trim()
        .toLowerCase();
    }
    function debugNavBridgeLog(...args){
      if (!DEV_NAV_BRIDGES_DEBUG) return;
      try { console.log("[nav_bridges]", ...args); } catch {}
    }
    async function loadDbusNavBridges(){
      resetDbusNavBridgeState();
      let res;
      try {
        res = await fetch(dataPath("nav_bridges.json"), { cache: "no-store" });
      } catch {
        return;
      }
      if (!res.ok) return;
      try {
        const raw = await res.json();
        const rules = Array.isArray(raw?.rules) ? raw.rules : [];
        DBUS_NAV_BRIDGES = rules.filter((rule) => rule && rule.enabled !== false);
        debugNavBridgeLog("loaded", DBUS_NAV_BRIDGES.length, "rule(s)");
      } catch (err) {
        console.warn("DBus nav_bridges.json invalide", err);
      }
    }
    function matchDbusNavBridgeRule(rule, line, route){
      if (!rule || !line || !route) return false;
      const scope = rule.scope && typeof rule.scope === "object" ? rule.scope : {};
      const routeName = String(route?.name || "").trim();
      const parsed = parseRouteName(routeName);
      const lineNumber = String(line?.number || "").trim();
      const parsedLineNumber = String(parsed?.lineNumber || "").trim();
      const routeTitle = String(parsed?.routeTitle || "").trim();
      const routeUid = String(route?.uid || "").trim();
      const lineUid = String(line?.uid || "").trim();

      if (scope.line != null) {
        const wanted = normalizeNavBridgeText(scope.line);
        const lineNorm = normalizeNavBridgeText(lineNumber);
        const parsedLineNorm = normalizeNavBridgeText(parsedLineNumber);
        const hasLineMatch = wanted && (
          lineNorm === wanted ||
          parsedLineNorm === wanted ||
          lineNorm.includes(wanted) ||
          parsedLineNorm.includes(wanted)
        );
        if (!hasLineMatch) return false;
      }
      if (scope.direction != null) {
        const wanted = normalizeNavBridgeText(scope.direction);
        const routeTitleNorm = normalizeNavBridgeText(routeTitle);
        const routeNameNorm = normalizeNavBridgeText(routeName);
        const hasDirectionMatch = wanted && (
          routeTitleNorm === wanted ||
          routeNameNorm === wanted ||
          routeTitleNorm.includes(wanted) ||
          routeNameNorm.includes(wanted)
        );
        if (!hasDirectionMatch) return false;
      }
      if (scope.route_uid != null) {
        if (normalizeNavBridgeText(scope.route_uid) !== normalizeNavBridgeText(routeUid)) return false;
      }
      if (scope.line_uid != null) {
        if (normalizeNavBridgeText(scope.line_uid) !== normalizeNavBridgeText(lineUid)) return false;
      }
      return true;
    }
    function getDbusNavBridgeRuleForRoute(line, route){
      if (!line || !route || !Array.isArray(DBUS_NAV_BRIDGES) || !DBUS_NAV_BRIDGES.length) return null;
      const parsed = parseRouteName(String(route?.name || ""));
      const matched = DBUS_NAV_BRIDGES.find((rule) => matchDbusNavBridgeRule(rule, line, route)) || null;
      debugNavBridgeLog("route check", {
        lineUid: String(line?.uid || ""),
        lineNumber: String(line?.number || ""),
        routeUid: String(route?.uid || ""),
        routeName: String(route?.name || ""),
        routeTitle: String(parsed?.routeTitle || ""),
        matchedRuleId: matched?.id || null
      });
      return matched;
    }
    function escapeDevGraphHtml(value){
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }
    function ensureDevGraphClickBinding(){
      if (!DEV_GRAPH || DEV_GRAPH_STATE.clickBound) return;
      map.on("click", onDevGraphMapClick);
      DEV_GRAPH_STATE.clickBound = true;
    }
    function onDevGraphMapClick(e){
      if (!DEV_GRAPH) return;
      const clickPx = map.project(e.latlng, map.getZoom());
      let best = null;
      let bestDistSq = Number.POSITIVE_INFINITY;
      for (const rec of DEV_GRAPH_STATE.nodePoints) {
        const pt = map.project(rec.latlng, map.getZoom());
        const dx = pt.x - clickPx.x;
        const dy = pt.y - clickPx.y;
        const distSq = (dx * dx) + (dy * dy);
        if (distSq < bestDistSq) {
          bestDistSq = distSq;
          best = rec;
        }
      }
      let worldX = 0;
      let worldY = 0;
      try {
        const xy = fromLatLngToXY(e.latlng);
        worldX = Number(xy?.X) || 0;
        worldY = Number(xy?.Y) || 0;
      } catch {}
      const thresholdPx = 10;
      if (DBUS_NAV_GRAPH && DEV_GRAPH_STATE.enabled && best && bestDistSq <= (thresholdPx * thresholdPx)) {
        const node = best.node;
        const outgoing = (DBUS_NAV_GRAPH.adjacency.get(node.id) || []).length;
        const incoming = DEV_GRAPH_STATE.incomingByNode.get(node.id) || 0;
        const html = `
          <div style="min-width:220px">
            <div style="font-weight:700;margin-bottom:6px">Point trajectoire</div>
            <div><b>node_id:</b> ${escapeDevGraphHtml(node.id)}</div>
            <div><b>x:</b> ${escapeDevGraphHtml(node.x.toFixed(3))}</div>
            <div><b>y:</b> ${escapeDevGraphHtml(node.y.toFixed(3))}</div>
            <div><b>kind:</b> ${escapeDevGraphHtml(node.kind || "-")}</div>
            <div><b>prefab_id:</b> ${escapeDevGraphHtml(node.prefabId ?? "-")}</div>
            <div><b>connector_id:</b> ${escapeDevGraphHtml(node.connectorId ?? "-")}</div>
            <div><b>liaisons:</b> out=${escapeDevGraphHtml(outgoing)} in=${escapeDevGraphHtml(incoming)}</div>
            <div style="margin-top:6px;color:#999"><b>click X/Y:</b> ${escapeDevGraphHtml(worldX.toFixed(2))} / ${escapeDevGraphHtml(worldY.toFixed(2))}</div>
          </div>`;
        L.popup({ maxWidth: 420, autoPan: true }).setLatLng(e.latlng).setContent(html).openOn(map);
        return;
      }
      const html = `
        <div style="min-width:200px">
          <div style="font-weight:700;margin-bottom:6px">Position</div>
          <div><b>X:</b> ${escapeDevGraphHtml(worldX.toFixed(2))}</div>
          <div><b>Y:</b> ${escapeDevGraphHtml(worldY.toFixed(2))}</div>
        </div>`;
      L.popup({ maxWidth: 320, autoPan: true }).setLatLng(e.latlng).setContent(html).openOn(map);
    }
    function enableDevGraphOverlay(){
      if (!DEV_GRAPH || DEV_GRAPH_STATE.enabled || !DBUS_NAV_GRAPH) return;
      DEV_GRAPH_STATE.enabled = true;
      DEV_GRAPH_STATE.incomingByNode.clear();
      DEV_GRAPH_STATE.nodePoints = [];

      const edges = Array.isArray(DBUS_NAV_GRAPH.edgeList) ? DBUS_NAV_GRAPH.edgeList : [];
      const edgeLatLngs = [];
      edges.forEach((edge) => {
        DEV_GRAPH_STATE.incomingByNode.set(edge.to, (DEV_GRAPH_STATE.incomingByNode.get(edge.to) || 0) + 1);
        const path = (Array.isArray(edge.polyline) ? edge.polyline : [])
          .map((pt) => toLatLng(Number(pt?.x), Number(pt?.y)))
          .filter(Boolean);
        if (path.length >= 2) edgeLatLngs.push(path);
      });
      DEV_GRAPH_STATE.edgeLayer = L.polyline(edgeLatLngs, {
        pane: "devGraphEdgePane",
        color: "#2de2ff",
        weight: 1.6,
        opacity: 0.42,
        interactive: false
      }).addTo(map);

      const nodeLayer = L.layerGroup().addTo(map);
      DBUS_NAV_GRAPH.nodeList.forEach((node) => {
        const latlng = toLatLng(node.x, node.y);
        DEV_GRAPH_STATE.nodePoints.push({ node, latlng });
        L.circleMarker(latlng, {
          pane: "devGraphNodePane",
          radius: 2,
          color: "#0b0b0b",
          weight: 1,
          fillColor: "#ffe66d",
          fillOpacity: 0.95,
          interactive: false
        }).addTo(nodeLayer);
      });
      DEV_GRAPH_STATE.nodeLayer = nodeLayer;

      ensureDevGraphClickBinding();
    }
    function dbusNavHeuristic(fromId, toId){
      const graph = DBUS_NAV_GRAPH;
      if (!graph) return 0;
      const a = graph.nodesById.get(fromId);
      const b = graph.nodesById.get(toId);
      if (!a || !b) return 0;
      return Math.hypot(a.x - b.x, a.y - b.y);
    }
    function findDbusNavPathTransitions(fromId, toId, options = null){
      if (fromId === toId) return [];
      const graph = DBUS_NAV_GRAPH;
      if (!graph) return null;
      const blockedEdgeIds = options?.blockedEdgeIds instanceof Set ? options.blockedEdgeIds : null;
      const open = createDbusMinHeap();
      const best = new Map([[fromId, 0]]);
      const prev = new Map();
      open.push({ id: fromId, g: 0, f: dbusNavHeuristic(fromId, toId) });
      const EPS = 1e-9;
      while (open.size > 0) {
        const current = open.pop();
        if (!current) break;
        const known = best.get(current.id);
        if (!Number.isFinite(known) || current.g > known + EPS) continue;
        if (current.id === toId) break;
        const transitions = graph.adjacency.get(current.id) || [];
        for (const transition of transitions) {
          if (blockedEdgeIds && Number.isFinite(transition?.edgeId) && blockedEdgeIds.has(transition.edgeId)) continue;
          const nextG = current.g + transition.weight;
          const knownNext = best.get(transition.to);
          if (Number.isFinite(knownNext) && nextG >= knownNext - EPS) continue;
          best.set(transition.to, nextG);
          prev.set(transition.to, { from: current.id, transition });
          open.push({
            id: transition.to,
            g: nextG,
            f: nextG + dbusNavHeuristic(transition.to, toId)
          });
        }
      }
      if (!prev.has(toId)) return null;
      const out = [];
      let cursor = toId;
      while (cursor !== fromId) {
        const step = prev.get(cursor);
        if (!step) return null;
        out.push(step.transition);
        cursor = step.from;
      }
      out.reverse();
      return out;
    }
    function appendTransitionWorldPoints(target, transition){
      const graph = DBUS_NAV_GRAPH;
      if (!graph || !transition) return;
      const rawPoints = Array.isArray(transition.points) ? transition.points : [];
      if (rawPoints.length) {
        if (transition.reverse) {
          for (let i = rawPoints.length - 1; i >= 0; i--) appendUniqueWorldPoint(target, rawPoints[i]);
        } else {
          rawPoints.forEach((point) => appendUniqueWorldPoint(target, point));
        }
      } else {
        appendUniqueWorldPoint(target, graph.nodesById.get(transition.from));
        appendUniqueWorldPoint(target, graph.nodesById.get(transition.to));
      }
      appendUniqueWorldPoint(target, graph.nodesById.get(transition.to));
    }
    function getDbusNavPathBetweenNodes(fromId, toId, options = null){
      const hasBlockedEdges = options?.blockedEdgeIds instanceof Set && options.blockedEdgeIds.size > 0;
      const key = hasBlockedEdges ? null : `${fromId}>${toId}`;
      if (key && dbusNavPathCache.has(key)) return dbusNavPathCache.get(key);
      const graph = DBUS_NAV_GRAPH;
      if (!graph) return null;
      const fromNode = graph.nodesById.get(fromId);
      const toNode = graph.nodesById.get(toId);
      if (!fromNode || !toNode) return null;
      const transitions = findDbusNavPathTransitions(fromId, toId, options);
      if (!transitions) {
        if (key) dbusNavPathCache.set(key, null);
        return null;
      }
      const points = [];
      let cost = 0;
      appendUniqueWorldPoint(points, fromNode);
      transitions.forEach((transition) => {
        cost += Number(transition.weight) || 0;
        appendTransitionWorldPoints(points, transition);
      });
      appendUniqueWorldPoint(points, toNode);
      const out = points.length ? { points, cost } : null;
      if (key) dbusNavPathCache.set(key, out);
      return out;
    }
    function getNearestDbusNavNodesForStop(stop, limit = DBUS_NAV_STOP_CANDIDATES){
      const graph = DBUS_NAV_GRAPH;
      if (!graph || !stop) return [];
      const stopId = Number(stop.id);
      if (Number.isFinite(stopId) && dbusNavNodesByStopId.has(stopId)) {
        const cached = dbusNavNodesByStopId.get(stopId) || [];
        return cached.slice(0, Math.max(1, limit));
      }
      const x = Number(stop.X);
      const y = Number(stop.Z);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return [];
      const candidates = [];
      for (const node of graph.nodeList) {
        const dx = node.x - x;
        const dy = node.y - y;
        const distSq = (dx * dx) + (dy * dy);
        const dist = Math.sqrt(distSq);
        if (dist > DBUS_NAV_MAX_SNAP_DISTANCE) continue;
        candidates.push({ nodeId: node.id, distance: dist });
      }
      candidates.sort((a, b) => a.distance - b.distance);
      const out = candidates.slice(0, Math.max(1, DBUS_NAV_STOP_CANDIDATES));
      if (Number.isFinite(stopId)) dbusNavNodesByStopId.set(stopId, out);
      return out.slice(0, Math.max(1, limit));
    }
    function pickBestDbusNavSegment(fromStop, toStop, options = null){
      const fromCandidates = getNearestDbusNavNodesForStop(fromStop);
      const toCandidates = getNearestDbusNavNodesForStop(toStop);
      if (!fromCandidates.length || !toCandidates.length) return null;
      let best = null;
      for (const fromCandidate of fromCandidates) {
        for (const toCandidate of toCandidates) {
          let path = null;
          let cost = 0;
          if (fromCandidate.nodeId === toCandidate.nodeId) {
            const node = DBUS_NAV_GRAPH?.nodesById.get(fromCandidate.nodeId);
            if (!node) continue;
            path = { points: [{ x: node.x, y: node.y }], cost: 0 };
          } else {
            path = getDbusNavPathBetweenNodes(fromCandidate.nodeId, toCandidate.nodeId, options);
            if (!path) continue;
          }
          cost = (path?.cost || 0) + fromCandidate.distance + toCandidate.distance;
          if (!best || cost < best.cost) {
            best = { cost, path };
          }
        }
      }
      return best;
    }
    function getDbusStopWorldPoint(stop){
      if (!stop) return null;
      const x = Number(stop.X);
      const y = Number(stop.Z);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }
    function buildDbusWorldPolylineFromStops(routeStops, startIndex, endIndex, options = null){
      const stops = Array.isArray(routeStops) ? routeStops : [];
      if (!stops.length) return [];
      const start = Math.max(0, Math.min(stops.length - 1, Number(startIndex) || 0));
      const end = Math.max(0, Math.min(stops.length - 1, Number(endIndex) || 0));
      if (start > end) return [];
      const worldPoints = [];
      if (start === end) {
        appendUniqueWorldPoint(worldPoints, getDbusStopWorldPoint(stops[start]));
        return worldPoints;
      }
      for (let i = start; i < end; i++) {
        const fromStop = stops[i];
        const toStop = stops[i + 1];
        if (!fromStop || !toStop) continue;
        const fromPoint = getDbusStopWorldPoint(fromStop);
        const toPoint = getDbusStopWorldPoint(toStop);
        if (i === start) appendUniqueWorldPoint(worldPoints, fromPoint);
        const segment = pickBestDbusNavSegment(fromStop, toStop, options);
        if (segment?.path && Array.isArray(segment.path.points) && segment.path.points.length) {
          segment.path.points.forEach((point) => appendUniqueWorldPoint(worldPoints, point));
        } else {
          appendUniqueWorldPoint(worldPoints, fromPoint);
          appendUniqueWorldPoint(worldPoints, toPoint);
        }
        appendUniqueWorldPoint(worldPoints, toPoint);
      }
      return worldPoints;
    }
    function buildDbusForcedChainWorldPoints(edgeIdChain, options = null){
      const graph = DBUS_NAV_GRAPH;
      if (!graph) return null;
      const ids = Array.isArray(edgeIdChain) ? edgeIdChain.map((id) => Number(id)).filter((id) => Number.isFinite(id)) : [];
      if (!ids.length) return null;
      const anchorStart = options?.anchorStart || null;
      const anchorEnd = options?.anchorEnd || null;
      let out = [];
      let previous = anchorStart;
      for (const edgeId of ids) {
        const edge = graph.edgesById?.get(edgeId);
        if (!edge) return null;
        const raw = Array.isArray(edge.polyline) ? edge.polyline
          .map((pt) => ({ x: Number(pt?.x), y: Number(pt?.y) }))
          .filter((pt) => Number.isFinite(pt.x) && Number.isFinite(pt.y))
          : [];
        if (raw.length < 2) continue;
        const reversed = raw.slice().reverse();
        let chosen = raw;
        if (previous) {
          const distForward = Math.hypot(raw[0].x - previous.x, raw[0].y - previous.y);
          const distReverse = Math.hypot(reversed[0].x - previous.x, reversed[0].y - previous.y);
          chosen = distReverse < distForward ? reversed : raw;
        }
        chosen.forEach((point) => appendUniqueWorldPoint(out, point));
        previous = out[out.length - 1] || previous;
      }
      if (!out.length) return null;
      if (anchorStart && anchorEnd && out.length >= 2) {
        const first = out[0];
        const last = out[out.length - 1];
        const directCost = Math.hypot(first.x - anchorStart.x, first.y - anchorStart.y) + Math.hypot(last.x - anchorEnd.x, last.y - anchorEnd.y);
        const reverseCost = Math.hypot(last.x - anchorStart.x, last.y - anchorStart.y) + Math.hypot(first.x - anchorEnd.x, first.y - anchorEnd.y);
        if (reverseCost < directCost) out = out.slice().reverse();
      }
      if (anchorStart) {
        const first = out[0];
        if (!first || Math.hypot(first.x - anchorStart.x, first.y - anchorStart.y) > 0.001) {
          out.unshift({ x: Number(anchorStart.x), y: Number(anchorStart.y) });
        }
      }
      if (anchorEnd) {
        const last = out[out.length - 1];
        if (!last || Math.hypot(last.x - anchorEnd.x, last.y - anchorEnd.y) > 0.001) {
          out.push({ x: Number(anchorEnd.x), y: Number(anchorEnd.y) });
        }
      }
      return out;
    }
    function getDbusGraphNodeWorldPoint(nodeId){
      const id = Number(nodeId);
      if (!Number.isFinite(id)) return null;
      const node = DBUS_NAV_GRAPH?.nodesById?.get(id);
      if (!node) return null;
      return { x: Number(node.x), y: Number(node.y) };
    }
    function buildDbusForcedNodeChainWorldPoints(nodeIdChain, navOptions = null, options = null){
      const graph = DBUS_NAV_GRAPH;
      if (!graph) return null;
      const ids = Array.isArray(nodeIdChain) ? nodeIdChain.map((id) => Number(id)).filter((id) => Number.isFinite(id)) : [];
      if (ids.length < 2) return null;
      const anchorStart = options?.anchorStart || null;
      const anchorEnd = options?.anchorEnd || null;
      const out = [];
      for (let i = 0; i < ids.length - 1; i++) {
        const fromId = ids[i];
        const toId = ids[i + 1];
        const fromNode = graph.nodesById.get(fromId);
        const toNode = graph.nodesById.get(toId);
        if (!fromNode || !toNode) return null;
        if (i === 0) appendUniqueWorldPoint(out, fromNode);
        const path = getDbusNavPathBetweenNodes(fromId, toId, navOptions);
        if (path?.points && Array.isArray(path.points) && path.points.length >= 2) {
          path.points.forEach((point) => appendUniqueWorldPoint(out, point));
        } else {
          // Allow explicit overrides across disconnected graph sections.
          appendUniqueWorldPoint(out, fromNode);
          appendUniqueWorldPoint(out, toNode);
        }
        appendUniqueWorldPoint(out, toNode);
      }
      if (!out.length) return null;
      if (anchorStart) {
        const first = out[0];
        if (!first || Math.hypot(first.x - anchorStart.x, first.y - anchorStart.y) > 0.001) {
          out.unshift({ x: Number(anchorStart.x), y: Number(anchorStart.y) });
        }
      }
      if (anchorEnd) {
        const last = out[out.length - 1];
        if (!last || Math.hypot(last.x - anchorEnd.x, last.y - anchorEnd.y) > 0.001) {
          out.push({ x: Number(anchorEnd.x), y: Number(anchorEnd.y) });
        }
      }
      return out;
    }
    function findNearestWorldPointMatch(points, worldPoint, maxDistance = Number.POSITIVE_INFINITY){
      const list = Array.isArray(points) ? points : [];
      if (!list.length || !worldPoint) return { index: -1, distance: Number.POSITIVE_INFINITY };
      let bestIndex = -1;
      let bestDistance = Number.POSITIVE_INFINITY;
      for (let i = 0; i < list.length; i++) {
        const point = list[i];
        if (!point) continue;
        const dist = Math.hypot(Number(point.x) - Number(worldPoint.x), Number(point.y) - Number(worldPoint.y));
        if (dist < bestDistance) {
          bestDistance = dist;
          bestIndex = i;
        }
      }
      if (!Number.isFinite(bestDistance) || bestDistance > maxDistance) return { index: -1, distance: bestDistance };
      return { index: bestIndex, distance: bestDistance };
    }
    function parseBridgeControlPoints(rawList){
      const list = Array.isArray(rawList) ? rawList : [];
      const out = [];
      list.forEach((entry) => {
        const x = Number(entry?.x ?? entry?.X);
        const y = Number(entry?.y ?? entry?.Y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) return;
        out.push({ x, y });
      });
      return out;
    }
    function parseBridgeSinglePoint(value){
      if (!value || typeof value !== "object") return null;
      const x = Number(value?.x ?? value?.X);
      const y = Number(value?.y ?? value?.Y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }
    function normalizeBridgePointPair(raw){
      if (!raw || typeof raw !== "object") return null;
      const from = parseBridgeSinglePoint(raw.from ?? raw.start ?? raw.a);
      const to = parseBridgeSinglePoint(raw.to ?? raw.end ?? raw.b);
      if (!from || !to) return null;
      return { from, to };
    }
    function anchorBridgePointChain(points, options = null){
      const source = Array.isArray(points) ? points : [];
      if (!source.length) return [];
      const out = [];
      const anchorStart = parseBridgeSinglePoint(options?.anchorStart || null);
      const anchorEnd = parseBridgeSinglePoint(options?.anchorEnd || null);
      if (anchorStart) appendUniqueWorldPoint(out, anchorStart);
      source.forEach((point) => appendUniqueWorldPoint(out, point));
      if (anchorEnd) appendUniqueWorldPoint(out, anchorEnd);
      return out;
    }
    function getNearestDbusGraphNodeIdForPoint(worldPoint, maxDistance = DBUS_NAV_MAX_SNAP_DISTANCE * 6){
      const graph = DBUS_NAV_GRAPH;
      const ref = parseBridgeSinglePoint(worldPoint);
      if (!graph || !ref) return null;
      let bestId = null;
      let bestDist = Number.POSITIVE_INFINITY;
      for (const node of graph.nodeList || []) {
        const dist = Math.hypot(Number(node.x) - ref.x, Number(node.y) - ref.y);
        if (dist < bestDist) {
          bestDist = dist;
          bestId = Number(node.id);
        }
      }
      if (!Number.isFinite(bestDist) || bestDist > maxDistance) return null;
      return Number.isFinite(bestId) ? bestId : null;
    }
    function resolveBridgeRefPoints(rawValue){
      const out = [];
      const pushOne = (value) => {
        if (value == null) return;
        if (typeof value === "number" || (typeof value === "string" && value.trim() !== "" && Number.isFinite(Number(value)))) {
          const nodePoint = getDbusGraphNodeWorldPoint(Number(value));
          if (nodePoint) out.push(nodePoint);
          return;
        }
        const point = parseBridgeSinglePoint(value);
        if (point) out.push(point);
      };
      if (Array.isArray(rawValue)) {
        rawValue.forEach((value) => pushOne(value));
      } else {
        pushOne(rawValue);
      }
      return out;
    }
    function parseBridgeControlNodeIds(rawValue){
      if (Array.isArray(rawValue)) {
        return rawValue
          .map((value) => Number(value))
          .filter((value) => Number.isFinite(value));
      }
      if (Number.isFinite(Number(rawValue))) {
        return [Number(rawValue)];
      }
      const text = String(rawValue || "").trim();
      if (!text) return [];
      return text
        .split(/[;,\s]+/g)
        .map((value) => Number(value))
        .filter((value) => Number.isFinite(value));
    }
    function buildBridgeControlPoints(entry, navOptions = null, options = null){
      if (!entry || typeof entry !== "object") return [];
      const points = parseBridgeControlPoints(entry.points ?? entry.control_points);
      if (points.length) return points;
      const nodeIds = parseBridgeControlNodeIds(entry.node_ids ?? entry.control_nodes ?? entry.control_node_ids ?? entry.node_ids_csv);
      const forceDirectLinks =
        entry.force_direct_links === true ||
        entry.force_direct === true ||
        entry.ignore_existing_paths === true;
      if (forceDirectLinks) {
        return nodeIds.map((id) => getDbusGraphNodeWorldPoint(id)).filter(Boolean);
      }
      if (nodeIds.length >= 2) {
        const chain = buildDbusForcedNodeChainWorldPoints(nodeIds, navOptions, {
          anchorStart: options?.anchorStart || null,
          anchorEnd: options?.anchorEnd || null
        });
        if (chain && chain.length) return chain;
      }
      return nodeIds.map((id) => getDbusGraphNodeWorldPoint(id)).filter(Boolean);
    }
    function removeBridgeIgnoredNodes(worldPoints, ignoredRefs){
      const base = Array.isArray(worldPoints) ? worldPoints : [];
      const ignoredPoints = resolveBridgeRefPoints(ignoredRefs);
      if (!ignoredPoints.length) return { points: base, removedCount: 0 };
      const OUT = [];
      let removedCount = 0;
      const threshold = 1.5;
      for (const point of base) {
        if (!point) continue;
        let shouldRemove = false;
        for (const ignored of ignoredPoints) {
          if (Math.hypot(Number(point.x) - Number(ignored.x), Number(point.y) - Number(ignored.y)) <= threshold) {
            shouldRemove = true;
            break;
          }
        }
        if (shouldRemove) {
          removedCount++;
          continue;
        }
        appendUniqueWorldPoint(OUT, point);
      }
      if (OUT.length < 2) return { points: base, removedCount: 0 };
      return { points: OUT, removedCount };
    }
    function insertBridgeControlPointsAtIndex(worldPoints, insertIndex, controlPoints, mode = "after"){
      const base = Array.isArray(worldPoints) ? worldPoints : [];
      const points = Array.isArray(controlPoints) ? controlPoints : [];
      if (!base.length || !points.length) return null;
      const idx = Math.max(0, Math.min(base.length - 1, Number(insertIndex) || 0));
      const beforeMode = String(mode || "").toLowerCase() === "before";
      const merged = [];
      for (let i = 0; i < base.length; i++) {
        if (beforeMode && i === idx) points.forEach((point) => appendUniqueWorldPoint(merged, point));
        appendUniqueWorldPoint(merged, base[i]);
        if (!beforeMode && i === idx) points.forEach((point) => appendUniqueWorldPoint(merged, point));
      }
      if (merged.length < 2) return null;
      return { points: merged, insertedAtIndex: idx, insertedCount: points.length };
    }
    function insertBridgeControlPointsRelativeToPoint(worldPoints, worldPoint, controlPointsEntry, mode = "after", navOptions = null){
      const base = Array.isArray(worldPoints) ? worldPoints : [];
      if (!base.length) return null;
      const refPoint = parseBridgeSinglePoint(worldPoint);
      if (!refPoint) return null;
      const match = findNearestWorldPointMatch(base, refPoint, DBUS_NAV_MAX_SNAP_DISTANCE * 10);
      if (!(match.index >= 0)) return null;
      const points = buildBridgeControlPoints(controlPointsEntry, navOptions, {
        anchorStart: mode === "after" ? base[match.index] : null,
        anchorEnd: mode === "before" ? base[match.index] : null
      });
      if (!points.length) return null;
      const inserted = insertBridgeControlPointsAtIndex(base, match.index, points, mode);
      if (!inserted) return null;
      return { ...inserted, matchIndex: match.index, pointDistance: match.distance };
    }
    function insertBridgeControlPointsRelativeToNode(worldPoints, nodeId, controlPointsEntry, mode = "after", navOptions = null){
      const base = Array.isArray(worldPoints) ? worldPoints : [];
      if (!base.length) return null;
      const nodePoint = getDbusGraphNodeWorldPoint(nodeId);
      if (!nodePoint) return null;
      const inserted = insertBridgeControlPointsRelativeToPoint(base, nodePoint, controlPointsEntry, mode, navOptions);
      if (!inserted) return null;
      inserted.nodeDistance = inserted.pointDistance;
      return inserted;
    }
    function insertBridgeControlPointsRelativeToStop(worldPoints, routeStops, stopNumber, controlPointsEntry, mode = "after", navOptions = null){
      const base = Array.isArray(worldPoints) ? worldPoints : [];
      const stops = Array.isArray(routeStops) ? routeStops : [];
      if (!base.length || !stops.length) return null;
      const stopIndex = Math.floor(Number(stopNumber)) - 1;
      if (!(stopIndex >= 0 && stopIndex < stops.length)) return null;
      const stopPoint = getDbusStopWorldPoint(stops[stopIndex]);
      if (!stopPoint) return null;
      const match = findNearestWorldPointMatch(base, stopPoint, DBUS_NAV_MAX_SNAP_DISTANCE * 10);
      if (!(match.index >= 0)) return null;
      const points = buildBridgeControlPoints(controlPointsEntry, navOptions, {
        anchorStart: mode === "after" ? base[match.index] : null,
        anchorEnd: mode === "before" ? base[match.index] : null
      });
      if (!points.length) return null;
      const inserted = insertBridgeControlPointsAtIndex(base, match.index, points, mode);
      if (!inserted) return null;
      return { ...inserted, matchIndex: match.index, stopIndex, stopDistance: match.distance };
    }
    function applyBridgeInsertionOperation(worldPoints, routeStops, operation, navOptions = null){
      if (!operation || typeof operation !== "object") return null;
      const ignoredRefs =
        operation.ignore_points ??
        operation.ignore_point ??
        operation.ignore_node_ids ??
        operation.ignore_nodes ??
        operation.ignore_node;
      const cleaned = removeBridgeIgnoredNodes(worldPoints, ignoredRefs);
      const basePoints = cleaned.points;
      const position = String(operation.position || "").trim().toLowerCase();
      if (position === "after_node") {
        const nodeRef = operation.node ?? operation.after_node ?? operation.node_point ?? operation.after_point;
        let inserted = null;
        const nodeId = Number(nodeRef);
        if (Number.isFinite(nodeId)) {
          inserted = insertBridgeControlPointsRelativeToNode(basePoints, nodeId, operation, "after", navOptions);
        } else {
          inserted = insertBridgeControlPointsRelativeToPoint(basePoints, parseBridgeSinglePoint(nodeRef), operation, "after", navOptions);
        }
        if (!inserted) return null;
        if (!Number.isFinite(inserted.nodeDistance)) inserted.nodeDistance = inserted.pointDistance;
        if (inserted && cleaned.removedCount > 0) inserted.ignoredRemovedCount = cleaned.removedCount;
        return inserted;
      }
      if (position === "after_point") {
        const inserted = insertBridgeControlPointsRelativeToPoint(basePoints, operation.point ?? operation.after_point, operation, "after", navOptions);
        if (!inserted) return null;
        if (inserted && cleaned.removedCount > 0) inserted.ignoredRemovedCount = cleaned.removedCount;
        return inserted;
      }
      if (position === "before_node") {
        const nodeRef = operation.node ?? operation.before_node ?? operation.node_point ?? operation.before_point;
        let inserted = null;
        const nodeId = Number(nodeRef);
        if (Number.isFinite(nodeId)) {
          inserted = insertBridgeControlPointsRelativeToNode(basePoints, nodeId, operation, "before", navOptions);
        } else {
          inserted = insertBridgeControlPointsRelativeToPoint(basePoints, parseBridgeSinglePoint(nodeRef), operation, "before", navOptions);
        }
        if (!inserted) return null;
        if (!Number.isFinite(inserted.nodeDistance)) inserted.nodeDistance = inserted.pointDistance;
        if (inserted && cleaned.removedCount > 0) inserted.ignoredRemovedCount = cleaned.removedCount;
        return inserted;
      }
      if (position === "before_point") {
        const inserted = insertBridgeControlPointsRelativeToPoint(basePoints, operation.point ?? operation.before_point, operation, "before", navOptions);
        if (!inserted) return null;
        if (inserted && cleaned.removedCount > 0) inserted.ignoredRemovedCount = cleaned.removedCount;
        return inserted;
      }
      if (position === "after_stop") {
        const stopNumber = Number(operation.stop_number ?? operation.stop ?? operation.after_stop);
        if (!Number.isFinite(stopNumber)) return null;
        const inserted = insertBridgeControlPointsRelativeToStop(basePoints, routeStops, stopNumber, operation, "after", navOptions);
        if (inserted && cleaned.removedCount > 0) inserted.ignoredRemovedCount = cleaned.removedCount;
        return inserted;
      }
      if (position === "before_stop") {
        const stopNumber = Number(operation.stop_number ?? operation.stop ?? operation.before_stop);
        if (!Number.isFinite(stopNumber)) return null;
        const inserted = insertBridgeControlPointsRelativeToStop(basePoints, routeStops, stopNumber, operation, "before", navOptions);
        if (inserted && cleaned.removedCount > 0) inserted.ignoredRemovedCount = cleaned.removedCount;
        return inserted;
      }
      return null;
    }
    function insertBridgeControlPointsAfterNode(worldPoints, afterNodeId, controlPoints){
      return insertBridgeControlPointsRelativeToNode(
        worldPoints,
        afterNodeId,
        { points: controlPoints },
        "after"
      );
    }
    function findNearestDbusRouteStopIndex(routeStops, worldPoint, maxDistance = DBUS_NAV_MAX_SNAP_DISTANCE * 3){
      if (!Array.isArray(routeStops) || !routeStops.length || !worldPoint) return -1;
      let bestIndex = -1;
      let bestDistance = Number.POSITIVE_INFINITY;
      routeStops.forEach((stop, index) => {
        const stopPoint = getDbusStopWorldPoint(stop);
        if (!stopPoint) return;
        const dist = Math.hypot(stopPoint.x - worldPoint.x, stopPoint.y - worldPoint.y);
        if (dist < bestDistance) {
          bestDistance = dist;
          bestIndex = index;
        }
      });
      if (!Number.isFinite(bestDistance) || bestDistance > maxDistance) return -1;
      return bestIndex;
    }
    function buildDbusRoutePolylineLatLngs(routeStops, line = null, route = null){
      const direct = routeStops.map((stop) => stop?.latlng).filter(Boolean);
      const gpsNavEnabled = (typeof isDbusGpsNavigationMode === "function")
        ? !!isDbusGpsNavigationMode()
        : true;
      if (!gpsNavEnabled) return direct;
      if (direct.length < 2 || !DBUS_NAV_GRAPH) return direct;
      const bridgeRule = getDbusNavBridgeRuleForRoute(line, route);
      if (bridgeRule) {
        debugNavBridgeLog("apply rule candidate", {
          ruleId: bridgeRule.id || null,
          lineNumber: String(line?.number || ""),
          routeUid: String(route?.uid || ""),
          routeName: String(route?.name || "")
        });
      }
      const blockedEdgeIds = new Set(
        (Array.isArray(bridgeRule?.remove_links) ? bridgeRule.remove_links : [])
          .map((id) => Number(id))
          .filter((id) => Number.isFinite(id))
      );
      const navOptions = blockedEdgeIds.size ? { blockedEdgeIds } : null;
      const fallbackWorld = buildDbusWorldPolylineFromStops(routeStops, 0, routeStops.length - 1, navOptions);
      let worldPoints = fallbackWorld;
      let forcedNodeChainApplied = false;

      const replaceBetweenNodes = bridgeRule?.replace_between_nodes && typeof bridgeRule.replace_between_nodes === "object"
        ? bridgeRule.replace_between_nodes
        : null;
      const replaceBetweenPoints = normalizeBridgePointPair(bridgeRule?.replace_between_points);
      let forcedNodeChain = Array.isArray(bridgeRule?.force_node_chain)
        ? bridgeRule.force_node_chain.map((id) => Number(id)).filter((id) => Number.isFinite(id))
        : [];
      const forcedPointChain = parseBridgeControlPoints(bridgeRule?.force_point_chain);
      if (!forcedNodeChain.length && forcedPointChain.length >= 2) {
        const mappedNodeIds = forcedPointChain
          .map((point) => getNearestDbusGraphNodeIdForPoint(point))
          .filter((id) => Number.isFinite(id));
        if (mappedNodeIds.length === forcedPointChain.length) forcedNodeChain = mappedNodeIds;
      }
      if (forcedNodeChain.length >= 2 || forcedPointChain.length >= 2) {
        const fromNodeId = Number(replaceBetweenNodes?.from);
        const toNodeId = Number(replaceBetweenNodes?.to);
        const effectiveFromNodeId = Number.isFinite(fromNodeId) ? fromNodeId : forcedNodeChain[0];
        const effectiveToNodeId = Number.isFinite(toNodeId) ? toNodeId : forcedNodeChain[forcedNodeChain.length - 1];
        const fromNodePoint =
          replaceBetweenPoints?.from ||
          getDbusGraphNodeWorldPoint(effectiveFromNodeId) ||
          forcedPointChain[0] ||
          null;
        const toNodePoint =
          replaceBetweenPoints?.to ||
          getDbusGraphNodeWorldPoint(effectiveToNodeId) ||
          forcedPointChain[forcedPointChain.length - 1] ||
          null;
        const forcedRawNodes = forcedNodeChain.length >= 2
          ? buildDbusForcedNodeChainWorldPoints(forcedNodeChain, navOptions)
          : anchorBridgePointChain(forcedPointChain);
        if (forcedRawNodes && forcedRawNodes.length >= 2 && fromNodePoint && toNodePoint) {
          const startMatch = findNearestWorldPointMatch(worldPoints, fromNodePoint);
          const endMatch = findNearestWorldPointMatch(worldPoints, toNodePoint);
          const startIdx = startMatch.index;
          const endIdx = endMatch.index;
          if (startIdx >= 0 && endIdx > startIdx) {
            const forcedAnchored = (forcedNodeChain.length >= 2
              ? buildDbusForcedNodeChainWorldPoints(forcedNodeChain, navOptions, {
                  anchorStart: worldPoints[startIdx],
                  anchorEnd: worldPoints[endIdx]
                })
              : anchorBridgePointChain(forcedPointChain, {
                  anchorStart: worldPoints[startIdx],
                  anchorEnd: worldPoints[endIdx]
                })) || forcedRawNodes;
            const merged = [];
            for (let i = 0; i <= startIdx; i++) appendUniqueWorldPoint(merged, worldPoints[i]);
            forcedAnchored.forEach((point) => appendUniqueWorldPoint(merged, point));
            for (let i = endIdx; i < worldPoints.length; i++) appendUniqueWorldPoint(merged, worldPoints[i]);
            if (merged.length >= 2) {
              worldPoints = merged;
              forcedNodeChainApplied = true;
              debugNavBridgeLog("forced node chain injected", {
                ruleId: bridgeRule?.id || null,
                fromNodeId: effectiveFromNodeId,
                toNodeId: effectiveToNodeId,
                chain: forcedNodeChain.length >= 2 ? forcedNodeChain : forcedPointChain,
                chainType: forcedNodeChain.length >= 2 ? "node" : "point",
                startIdx,
                endIdx,
                startDistance: Number(startMatch.distance || 0).toFixed(2),
                endDistance: Number(endMatch.distance || 0).toFixed(2),
                mergedPoints: merged.length
              });
            }
          } else {
            const forcedFullRoute = (forcedNodeChain.length >= 2
              ? buildDbusForcedNodeChainWorldPoints(forcedNodeChain, navOptions, {
                  anchorStart: getDbusStopWorldPoint(routeStops[0]),
                  anchorEnd: getDbusStopWorldPoint(routeStops[routeStops.length - 1])
                })
              : anchorBridgePointChain(forcedPointChain, {
                  anchorStart: getDbusStopWorldPoint(routeStops[0]),
                  anchorEnd: getDbusStopWorldPoint(routeStops[routeStops.length - 1])
                })) || forcedRawNodes;
            if (forcedFullRoute && forcedFullRoute.length >= 2) {
              worldPoints = forcedFullRoute;
              forcedNodeChainApplied = true;
              debugNavBridgeLog("forced node chain fallback applied on full route", {
                ruleId: bridgeRule?.id || null,
                fromNodeId: effectiveFromNodeId,
                toNodeId: effectiveToNodeId,
                chain: forcedNodeChain.length >= 2 ? forcedNodeChain : forcedPointChain,
                chainType: forcedNodeChain.length >= 2 ? "node" : "point",
                startIdx,
                endIdx,
                startDistance: Number(startMatch.distance || 0).toFixed(2),
                endDistance: Number(endMatch.distance || 0).toFixed(2),
                points: forcedFullRoute.length
              });
            } else {
              debugNavBridgeLog("forced node chain skipped", {
                ruleId: bridgeRule?.id || null,
                fromNodeId: effectiveFromNodeId,
                toNodeId: effectiveToNodeId,
                chain: forcedNodeChain.length >= 2 ? forcedNodeChain : forcedPointChain,
                startIdx,
                endIdx
              });
            }
          }
        } else {
          debugNavBridgeLog("forced node chain skipped (invalid nodes)", {
            ruleId: bridgeRule?.id || null,
            chain: forcedNodeChain
          });
        }
      }

      const forcedChain = Array.isArray(bridgeRule?.force_link_chain)
        ? bridgeRule.force_link_chain.map((id) => Number(id)).filter((id) => Number.isFinite(id))
        : [];
      if (!forcedNodeChainApplied && forcedChain.length >= 1) {
        const forcedRaw = buildDbusForcedChainWorldPoints(forcedChain);
        if (forcedRaw && forcedRaw.length >= 2) {
          let chainToUse = forcedChain;
          let chainRawToUse = forcedRaw;
          let startIdx = findNearestDbusRouteStopIndex(routeStops, chainRawToUse[0]);
          let endIdx = findNearestDbusRouteStopIndex(routeStops, chainRawToUse[chainRawToUse.length - 1]);
          if (!(startIdx >= 0 && endIdx > startIdx)) {
            const reversedRaw = forcedRaw.slice().reverse();
            const reversedStartIdx = findNearestDbusRouteStopIndex(routeStops, reversedRaw[0]);
            const reversedEndIdx = findNearestDbusRouteStopIndex(routeStops, reversedRaw[reversedRaw.length - 1]);
            if (reversedStartIdx >= 0 && reversedEndIdx > reversedStartIdx) {
              chainToUse = forcedChain.slice().reverse();
              chainRawToUse = reversedRaw;
              startIdx = reversedStartIdx;
              endIdx = reversedEndIdx;
            }
          }
          if (startIdx >= 0 && endIdx > startIdx) {
            const forcedAnchored = buildDbusForcedChainWorldPoints(chainToUse, {
              anchorStart: getDbusStopWorldPoint(routeStops[startIdx]),
              anchorEnd: getDbusStopWorldPoint(routeStops[endIdx])
            }) || chainRawToUse;
            const merged = [];
            const prefixWorld = buildDbusWorldPolylineFromStops(routeStops, 0, startIdx, navOptions);
            const suffixWorld = buildDbusWorldPolylineFromStops(routeStops, endIdx, routeStops.length - 1, navOptions);
            prefixWorld.forEach((point) => appendUniqueWorldPoint(merged, point));
            forcedAnchored.forEach((point) => appendUniqueWorldPoint(merged, point));
            suffixWorld.forEach((point) => appendUniqueWorldPoint(merged, point));
            if (merged.length >= 2) {
              worldPoints = merged;
              debugNavBridgeLog("forced chain injected", {
                ruleId: bridgeRule?.id || null,
                chain: chainToUse,
                fromStopIndex: startIdx,
                toStopIndex: endIdx,
                mergedPoints: merged.length
              });
            }
          } else {
            const forcedFullRoute = buildDbusForcedChainWorldPoints(chainToUse, {
              anchorStart: getDbusStopWorldPoint(routeStops[0]),
              anchorEnd: getDbusStopWorldPoint(routeStops[routeStops.length - 1])
            }) || chainRawToUse;
            if (forcedFullRoute && forcedFullRoute.length >= 2) {
              worldPoints = forcedFullRoute;
              debugNavBridgeLog("forced chain fallback applied on full route", {
                ruleId: bridgeRule?.id || null,
                chain: chainToUse,
                startIdx,
                endIdx,
                points: forcedFullRoute.length
              });
            } else {
              debugNavBridgeLog("forced chain skipped (unable to map on route stops)", {
                ruleId: bridgeRule?.id || null,
                chain: forcedChain,
                startIdx,
                endIdx
              });
            }
          }
        } else {
          debugNavBridgeLog("forced chain skipped (invalid edge ids or no polyline)", {
            ruleId: bridgeRule?.id || null,
            chain: forcedChain
          });
        }
      }

      const insertionOps = [];
      if (bridgeRule?.insert_control_points_after_node && typeof bridgeRule.insert_control_points_after_node === "object") {
        const legacy = bridgeRule.insert_control_points_after_node;
        insertionOps.push({
          position: "after_node",
          node: legacy.after_node ?? legacy.node ?? legacy.after_point ?? legacy.node_point,
          points: legacy.points ?? legacy.control_points,
          node_ids: legacy.node_ids ?? legacy.control_node_ids ?? legacy.control_nodes
        });
      }
      if (Array.isArray(bridgeRule?.insert_control_points)) {
        bridgeRule.insert_control_points.forEach((operation) => {
          if (operation && typeof operation === "object") insertionOps.push(operation);
        });
      }
      insertionOps.forEach((operation) => {
        const injected = applyBridgeInsertionOperation(worldPoints, routeStops, operation, navOptions);
        if (injected?.points?.length >= 2) {
          worldPoints = injected.points;
          debugNavBridgeLog("control points injected", {
            ruleId: bridgeRule?.id || null,
            position: String(operation?.position || ""),
            node: operation?.node ?? operation?.after_node ?? operation?.before_node ?? null,
            stopNumber: operation?.stop_number ?? operation?.stop ?? operation?.after_stop ?? operation?.before_stop ?? null,
            insertedCount: injected.insertedCount,
            insertedAtIndex: injected.insertedAtIndex,
            matchIndex: injected.matchIndex,
            ignoredRemovedCount: injected.ignoredRemovedCount ?? 0,
            nodeDistance: Number(injected.nodeDistance ?? 0).toFixed(2),
            stopDistance: Number(injected.stopDistance ?? 0).toFixed(2)
          });
        } else {
          debugNavBridgeLog("control points skipped", {
            ruleId: bridgeRule?.id || null,
            position: String(operation?.position || ""),
            node: operation?.node ?? operation?.after_node ?? operation?.before_node ?? null,
            stopNumber: operation?.stop_number ?? operation?.stop ?? operation?.after_stop ?? operation?.before_stop ?? null
          });
        }
      });

      const navLatLngs = worldPoints.map((point) => toLatLng(point.x, point.y)).filter(Boolean);
      return navLatLngs.length >= 2 ? navLatLngs : direct;
    }


    const BUS_COLORS = [getComputedStyle(document.documentElement).getPropertyValue('--busA').trim(),
                        getComputedStyle(document.documentElement).getPropertyValue('--busB').trim(),
                        getComputedStyle(document.documentElement).getPropertyValue('--busC').trim(),
                        getComputedStyle(document.documentElement).getPropertyValue('--busD').trim(),
                        getComputedStyle(document.documentElement).getPropertyValue('--busE').trim()];
    function colorFor(index){ return BUS_COLORS[index % BUS_COLORS.length] || "#3aa0ff"; }

    async function getTwoDominantColors(src){
      return new Promise(resolve => {
        const img = new Image(); img.crossOrigin = "anonymous"; img.src = src;
        img.onload = () => {
          const canvas = document.createElement("canvas"); const ctx = canvas.getContext("2d");
          canvas.width  = img.naturalWidth; canvas.height = img.naturalHeight;
          ctx.drawImage(img, 0, 0);
          const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
          const counts = {}; let whiteCount = 0; let blackCount = 0;
          const STEP = 16, WHITE_LUM = 0.92, BLACK_LUM = 0.08;
          for (let i = 0; i < data.length; i += 4*STEP) {
            const a = data[i+3]; if (a < 128) continue;
            const r = data[i], g = data[i+1], b = data[i+2];
            const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
            if (lum > WHITE_LUM) { whiteCount++; continue; }
            if (lum < BLACK_LUM) { blackCount++; continue; }
            const rq = r >> 4, gq = g >> 4, bq = b >> 4;
            const key = `${rq},${gq},${bq}`; counts[key] = (counts[key] || 0) + 1;
          }
          const entries = Object.entries(counts).sort((a,b)=> b[1]-a[1]);
          let bg = "#444"; if (entries.length) { const [rq,gq,bq] = entries[0][0].split(",").map(v => (parseInt(v,10) << 4) + 8); bg = `rgb(${rq},${gq},${bq})`; }
          const text = (whiteCount >= blackCount) ? "#fff" : "#000";
          resolve([bg, text]);
        };
        img.onerror = () => resolve(["#444","#fff"]);
      });
    }

    function isNoctilien2(input){
      const num = typeof input === 'string' ? input : input?.number;
      return /^N\d+$/.test(String(num || "").trim().toUpperCase());
    }

    function getLineStyleEntry(number){
      const n = String(number || "").trim();
      if (!n) return null;
      const STYLE_LC = getLineStyleEntry.STYLE_LC || (
        getLineStyleEntry.STYLE_LC = Object.fromEntries(
          Object.entries(LINE_STYLES).map(([k,v]) => [k.toLowerCase(), v])
        )
      );
      return STYLE_LC[n.toLowerCase()] || null;
    }

    function getLineLink(line, route){
      const candidates = [];
      try {
        const { lineNumber } = parseRouteName(route?.name || "");
        if (lineNumber) candidates.push(lineNumber);
      } catch {}
      if (line?.number) candidates.push(line.number);
      try {
        const cat = getCategory(line);
        if (cat) candidates.push(cat);
        if (cat === "FlixBus") candidates.push("FLIXBUS");
      } catch {}

      const seen = new Set();
      for (const cand of candidates){
        const key = String(cand || "").trim();
        if (!key) continue;
        const lc = key.toLowerCase();
        if (seen.has(lc)) continue;
        seen.add(lc);
        const entry = getLineStyleEntry(key);
        if (entry) {
          const url = (typeof entry[2] === "string") ? entry[2].trim() : "";
          if (url) return url;
        }
      }
      return "";
    }

    const LINE_COLOR_CACHE = new Map();
    function getLineColors(number){
      const n = String(number || "").trim();
      if (isNoctilien2(n)) return Promise.resolve(["#080080", "#FFFFFF"]);

      const STYLE_LC = getLineColors.STYLE_LC || (
        getLineColors.STYLE_LC = Object.fromEntries(
          Object.entries(LINE_STYLES).map(([k,v]) => [k.toLowerCase(), v])
        )
      );
      const hit = STYLE_LC[n.toLowerCase()];
      if (hit) return Promise.resolve(hit);

      const key = n.toLowerCase();
      const hash = Math.abs([...key].reduce((h,c)=>((h<<5)-h + c.charCodeAt(0))|0,0));
      const i = (/^\d+$/.test(n) ? (parseInt(n,10) % BUS_COLORS.length) : (hash % BUS_COLORS.length));
      const bg = BUS_COLORS[i] || "#3aa0ff";
      const text = (() => {
        const m = /^#?([0-9a-f]{6})$/i.exec(bg); if(!m) return "#fff";
        const x = parseInt(m[1],16);
        const r=(x>>16)&255, g=(x>>8)&255, b=x&255;
        const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
        return L > 0.6 ? "#000" : "#fff";
      })();
      return Promise.resolve([bg, text]);
    }


    function noctilienStripeColor(number){
      const DEFAULT = "#080080";
      const n = String(number||"").trim();
      if (LINE_STYLES[n] && LINE_STYLES[n][0]) return LINE_STYLES[n][0];
      return DEFAULT;
    }

    function ensureStripe(badgeEl, color){
      badgeEl.style.position = "relative";
      const old = badgeEl.querySelector(".noctilien-stripe");
      if (old) old.remove();
      badgeEl.classList.add("has-noctilien-stripe");
      const stripe = document.createElement("div");
      stripe.className = "noctilien-stripe";
      stripe.style.position = "absolute";
      stripe.style.left = "0";
      stripe.style.right = "0";
      stripe.style.bottom = "0";
      stripe.style.height = "6px";
      stripe.style.borderBottomLeftRadius = "8px";
      stripe.style.borderBottomRightRadius = "8px";
      stripe.style.background = color;
      badgeEl.appendChild(stripe);
    }

    function parseRouteName(name){
      const raw = String(name || "").trim();

      const hasColon = raw.includes(":");
      const parts = hasColon ? raw.split(":") : [raw];

      let flag = null;
      const flagMatch = parts[0].match(/\(([^)]+)\)/);
      if (flagMatch) flag = flagMatch[1].trim();
      if (flag && /^fict/i.test(flag)) flag = null;

      let lineNumber = parts[0]
        .replace(/\s*\([^)]*\)/g, "")
        .trim();

      let routeTitle;
      if (hasColon) {
        routeTitle = raw.substring(raw.indexOf(":") + 1).trim();
      } else {
        routeTitle = raw;
      }

      return { lineNumber, routeTitle, flag };
    }

    function ensureFictiveStripe(badgeEl) {
      return badgeEl;
    }

    function ensureBadgeLabel(badgeEl, text){
      if (!badgeEl) return null;
      let label = badgeEl.querySelector(".badge-label");
      if (!label){
        label = document.createElement("span");
        label.className = "badge-label";
        badgeEl.appendChild(label);
      }
      if (typeof text === "string") {
        label.textContent = text;
      }
      return label;
    }

    function computeBadgeFontSize(labelText, widthPx, heightPx){
      const txt = String(labelText || "").trim();
      const chars = Math.max(txt.length, 1);
      const safeW = Math.max(Number(widthPx) || 0, 24);
      const safeH = Math.max(Number(heightPx) || 0, 16);
      const byHeight = Math.floor(safeH * 0.62);
      const byWidth = Math.floor((safeW - 10) / (chars * 0.62));
      return Math.max(8, Math.min(byHeight, byWidth));
    }

    function makeLineBadge(number, bg="#444", text="#fff", size="72x32", stripeColor=null, isFictive=false) {
      const [w,h] = size.split("x").map(v=>parseInt(v,10));
      const badge = document.createElement("div");
      badge.className = "badge";
      badge.style.width = w+"px"; 
      badge.style.height = h+"px";
      badge.style.boxSizing = "border-box";
      badge.style.borderRadius = "8px";
      badge.style.display = "flex";
      badge.style.alignItems = "center";
      badge.style.justifyContent = "center";
      badge.style.flex = "0 0 auto";
      badge.style.overflow = "hidden";
      badge.style.fontWeight = "800";
      badge.style.fontVariantNumeric = "tabular-nums";
      badge.style.background = bg; 
      badge.style.color = text;
      badge.style.textShadow = "0 1px 2px rgba(0,0,0,.35)";
      badge.style.position = "relative";
      const rawLabel = String(number || "").trim();
      badge.dataset.badgeRaw = rawLabel;
      const labelText = translateBadgeToken(rawLabel);
      const labelSpan = ensureBadgeLabel(badge, labelText);
      labelSpan.style.fontSize = computeBadgeFontSize(labelText, w, h) + "px";

      if (stripeColor) ensureStripe(badge, stripeColor);
      if (isFictive) ensureFictiveStripe(badge);
      return badge;
    }

    function createNetworkBadgeElement({ label, imgSrc, alt, colorKey, chipClass = "dbus-badge network-chip", stripeColor = null, invertLogo = false }) {
      const wrap = document.createElement("div");
      wrap.className = "network-badge";

      const img = document.createElement("img");
      img.src = imgSrc;
      img.alt = alt;
      if (invertLogo) img.classList.add("network-logo-invert");
      wrap.appendChild(img);

      const [bg, text] = getLineColorsSync(colorKey || label);
      const chip = document.createElement("div");
      chip.className = chipClass;
      chip.dataset.chipRole = "line";
      chip.dataset.networkBadge = "true";
      ensureBadgeLabel(chip, String(label ?? ""));
      chip.style.background = bg;
      chip.style.color = text;
      wrap.appendChild(chip);

      if (stripeColor) ensureStripe(chip, stripeColor);

      return { wrap, chip };
    }

    function networkBadgeHTML({ label, imgSrc, alt, colorKey, chipClass = "dbus-badge network-chip", stripeColor = null, invertLogo = false }) {
      const [bg, text] = getLineColorsSync(colorKey || label);
      const stripe = stripeColor ? `<div class="noctilien-stripe" style="background:${stripeColor}"></div>` : "";
      return `
        <div class="network-badge">
          <img src="${imgSrc}" alt="${escapeHTML(alt)}" ${invertLogo ? 'class="network-logo-invert"' : ''}/>
          <div class="${chipClass}" data-chip-role="line" data-network-badge="true" style="background:${bg};color:${text};">
            ${escapeHTML(label)}
            ${stripe}
          </div>
        </div>
      `;
    }

    function trimByDash(s, mode){
      const txt = String(s || "").trim();
      const parts = txt.split(/\s*[---]\s*/).filter(Boolean);
      if (parts.length < 2) return txt;
      return (mode === 'start') ? parts[0].trim() : parts[parts.length - 1].trim();
    }

    function cleanRERLabel(label){
      return String(label ?? "").replace(/\s*[---]\s*RER\b/gi, " RER");
    }

    function withRERIconInStop(text){
      const esc = escapeHTML(text ?? "");
      return esc.replace(/\s*[---]?\s*RER\s*[---]?\s*/gi,
        ' <span class="rer-ico" aria-label="RER"></span> ')
        .replace(/\s*[---]?\s*M[ée]tro\s*[---]?\s*/gi,
        ' <span class="metro-ico" aria-label="Métro"></span> ');
    }

    const PROV_RE = /\bprovisoire\b/i;
    function hasProvisoire(text){
      return PROV_RE.test(String(text || ""));
    }
    function stripProvisoire(text){
      return String(text || "")
        .replace(/\s*\(\s*provisoire\s*\)\s*/i, " ")
        .replace(/\s*-\s*provisoire\b/i, " ")
        .replace(/\s+/g, " ")
        .trim();
    }
    function getRouteTerminusLabel(route, titleEndFallback = ""){
      const stops = route?.stops || [];
      const lastStopId = stops.length ? stops[stops.length - 1].uid : undefined;
      const lastStop = (typeof lastStopId !== "undefined") ? DBUS_STOPS.get(lastStopId) : null;
      const rawStopName = lastStop?.name || "";
      const rawFallback = String(titleEndFallback || "").trim();
      const raw = rawStopName || rawFallback;
      if (!raw) return "";
      const isProvisoire = hasProvisoire(rawStopName) || hasProvisoire(rawFallback);
      const clean = stripProvisoire(raw);
      const translated = translateStopName(clean);
      return isProvisoire ? `${translated} (${t("temporary_stop")})` : translated;
    }

    function splitRouteEndpoints(routeTitle){
      const s = decodeHTML(String(routeTitle || "").trim());
      const parts = s.split(/\s*(?:>|→|↔|⇄|<->|->|\bvers\b|\bto\b)\s*/i).filter(Boolean);
      if (parts.length >= 2){ return [parts[0].trim(), parts[parts.length-1].trim()]; }
      return [s, s];
    }

    function translateRouteTitle(routeTitle){
      const raw = String(routeTitle || "").trim();
      if (!raw || !TRANSLATE_STOP_TYPES || LANG === "fr") return raw;
      const [start0, end0] = splitRouteEndpoints(raw);
      if (!start0 || !end0 || start0 === end0) return translateStopName(raw);
      const start = translateStopName(start0);
      const end = translateStopName(end0);
      return `${start} > ${end}`;
    }

    function getLineColorsSync(number){
      const n = String(number || "").trim();

      if (isNoctilien2(n)) return ["#080080", "#FFFFFF"];

      const STYLE_LC = Object.fromEntries(
        Object.entries(LINE_STYLES).map(([k,v]) => [k.toLowerCase(), v])
      );
      const hit = STYLE_LC[n.toLowerCase()];
      if (hit) return hit;

      const key = n.toLowerCase();
      const hash = Math.abs([...key].reduce((h,c)=>((h<<5)-h + c.charCodeAt(0))|0,0));
      const i = (/^\d+$/.test(n) ? (parseInt(n,10) % BUS_COLORS.length) : (hash % BUS_COLORS.length));
      const bg = BUS_COLORS[i] || "#3aa0ff";

      const m = /^#?([0-9a-f]{6})$/i.exec(bg);
      if (!m) return [bg, "#fff"];
      const x = parseInt(m[1],16);
      const r=(x>>16)&255, g=(x>>8)&255, b=x&255;
      const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
      const text = L > 0.6 ? "#000" : "#fff";

      return [bg, text];
    }

    function getRouteDirectionSpacingPx(zoom = map.getZoom()){
      return Math.max(34, Math.min(106, 150 - (zoom * 10)));
    }
    function getRouteDirectionSpeedPx(zoom = map.getZoom()){
      return Math.max(12, Math.min(48, 14 + (zoom * 3)));
    }
    function normalizeDirectionArrowColor(color){
      return "#ffffff";
    }
    function buildRouteDirectionGeometry(latlngs){
      if (!Array.isArray(latlngs) || latlngs.length < 2) return null;
      const zoom = map.getZoom();
      const pts = latlngs.map((ll) => map.project(ll, zoom));
      const segments = [];
      let total = 0;
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i];
        const b = pts[i + 1];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const len = Math.hypot(dx, dy);
        if (!Number.isFinite(len) || len < 0.001) continue;
        segments.push({ a, dx, dy, len, start: total });
        total += len;
      }
      if (!segments.length || total < 1) return null;
      return { zoom, total, segments };
    }
    function buildRouteDirectionArrowIcon(angleDeg = 0, color = "#ffffff"){
      const safeAngle = Number.isFinite(angleDeg) ? angleDeg : 0;
      const safeColor = "#ffffff";
      return L.divIcon({
        className: "route-dir-arrow-host",
        html: `<span class="route-dir-arrow-rot" style="--dir-angle:${safeAngle.toFixed(1)}deg;"><span class="route-dir-arrow-glyph" style="--dir-color:${escapeHTML(safeColor)};">➤</span></span>`,
        iconSize: [18, 18],
        iconAnchor: [9, 9]
      });
    }
    function clearRouteDirectionMarkers(bundle){
      if (!bundle) return;
      const markers = Array.isArray(bundle.directionMarkers) ? bundle.directionMarkers : [];
      markers.forEach((marker) => {
        if (!marker) return;
        try { bundle.group.removeLayer(marker); } catch {}
      });
      bundle.directionMarkers = [];
    }
    function ensureRouteDirectionMarkerCount(bundle, count){
      if (!bundle) return;
      const safeCount = Math.max(0, Number(count) || 0);
      if (!Array.isArray(bundle.directionMarkers)) bundle.directionMarkers = [];
      const markers = bundle.directionMarkers;
      while (markers.length > safeCount) {
        const marker = markers.pop();
        if (!marker) continue;
        try { bundle.group.removeLayer(marker); } catch {}
      }
      const baseLatLng = bundle.routeLatLngs?.[0] || map.getCenter();
      while (markers.length < safeCount) {
        const marker = L.marker(baseLatLng, {
          pane: "dbusRouteDirectionPane",
          interactive: false,
          keyboard: false,
          bubblingMouseEvents: false,
          zIndexOffset: 250,
          icon: buildRouteDirectionArrowIcon(0, bundle.directionColor || "#ffffff")
        }).addTo(bundle.group);
        marker._dirAngle = 0;
        markers.push(marker);
      }
    }
    function updateRouteDirectionMarkerColor(bundle, color){
      if (!bundle) return;
      bundle.directionColor = "#ffffff";
      const markers = Array.isArray(bundle.directionMarkers) ? bundle.directionMarkers : [];
      markers.forEach((marker) => {
        const el = marker?.getElement?.();
        if (el) {
          const glyph = el.querySelector(".route-dir-arrow-glyph");
          if (glyph) glyph.style.setProperty("--dir-color", "#ffffff");
          return;
        }
        const angle = Number(marker?._dirAngle) || 0;
        try { marker.setIcon(buildRouteDirectionArrowIcon(angle, "#ffffff")); } catch {}
      });
    }
    function resolveRouteDirectionPoint(geom, offsetPx){
      if (!geom || !Array.isArray(geom.segments) || !geom.segments.length || !Number.isFinite(geom.total) || geom.total <= 0) return null;
      const total = geom.total;
      let d = Number(offsetPx) || 0;
      d = ((d % total) + total) % total;
      let lo = 0;
      let hi = geom.segments.length - 1;
      let idx = hi;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const seg = geom.segments[mid];
        if (d < seg.start) {
          hi = mid - 1;
          continue;
        }
        if (d >= seg.start + seg.len) {
          lo = mid + 1;
          continue;
        }
        idx = mid;
        break;
      }
      const seg = geom.segments[idx];
      if (!seg || !Number.isFinite(seg.len) || seg.len <= 0) return null;
      const t = (d - seg.start) / seg.len;
      const x = seg.a.x + (seg.dx * t);
      const y = seg.a.y + (seg.dy * t);
      const angle = Math.atan2(seg.dy, seg.dx) * (180 / Math.PI);
      return { latlng: map.unproject(L.point(x, y), geom.zoom), angle };
    }
    function updateRouteDirectionMarkersAtPhase(bundle, phasePx){
      if (!bundle) return;
      const geom = bundle.directionGeometry;
      const markers = Array.isArray(bundle.directionMarkers) ? bundle.directionMarkers : [];
      if (!geom || !markers.length) return;
      const spacing = Number(bundle.directionSpacingPx) || getRouteDirectionSpacingPx();
      for (let i = 0; i < markers.length; i++) {
        const marker = markers[i];
        if (!marker) continue;
        const point = resolveRouteDirectionPoint(geom, phasePx + (i * spacing));
        if (!point) continue;
        try { marker.setLatLng(point.latlng); } catch {}
        marker._dirAngle = point.angle;
        const el = marker.getElement?.();
        if (el) {
          const rot = el.querySelector(".route-dir-arrow-rot");
          if (rot) rot.style.setProperty("--dir-angle", `${Number(point.angle).toFixed(1)}deg`);
        } else {
          try { marker.setIcon(buildRouteDirectionArrowIcon(point.angle, bundle.directionColor || "#ffffff")); } catch {}
        }
      }
    }
    function refreshRouteDirectionMarkers(bundle){
      if (!bundle) return;
      const latlngs = Array.isArray(bundle.routeLatLngs) ? bundle.routeLatLngs : [];
      const geometry = buildRouteDirectionGeometry(latlngs);
      if (!geometry) {
        clearRouteDirectionMarkers(bundle);
        bundle.directionGeometry = null;
        return;
      }
      bundle.directionGeometry = geometry;
      const spacing = getRouteDirectionSpacingPx(geometry.zoom);
      bundle.directionSpacingPx = spacing;
      bundle.directionSpeedPx = getRouteDirectionSpeedPx(geometry.zoom);
      const count = Math.max(1, Math.min(180, Math.floor(geometry.total / spacing)));
      ensureRouteDirectionMarkerCount(bundle, count);
      updateRouteDirectionMarkersAtPhase(bundle, bundle.directionPhasePx || 0);
    }
    function stopRouteDirectionAnimation(bundle){
      if (!bundle) return;
      if (bundle.directionAnimRaf) cancelAnimationFrame(bundle.directionAnimRaf);
      bundle.directionAnimRaf = 0;
      bundle.directionAnimating = false;
      bundle.directionLastTs = 0;
      bundle.directionLastPaintTs = 0;
    }
    function startRouteDirectionAnimation(bundle){
      if (!bundle) return;
      stopRouteDirectionAnimation(bundle);
      bundle.directionAnimating = true;
      bundle.directionLastTs = 0;
      bundle.directionLastPaintTs = 0;
      if (!Number.isFinite(bundle.directionPhasePx)) bundle.directionPhasePx = 0;
      const tick = (ts) => {
        if (!bundle.directionAnimating) return;
        if (!bundle.directionLastTs) bundle.directionLastTs = ts;
        const dt = Math.min(0.1, Math.max(0, (ts - bundle.directionLastTs) / 1000));
        bundle.directionLastTs = ts;
        const speed = Number(bundle.directionSpeedPx) || getRouteDirectionSpeedPx();
        bundle.directionPhasePx = (Number(bundle.directionPhasePx) || 0) + (speed * dt);
        if (!bundle.directionLastPaintTs || (ts - bundle.directionLastPaintTs) >= 33) {
          bundle.directionLastPaintTs = ts;
          updateRouteDirectionMarkersAtPhase(bundle, bundle.directionPhasePx || 0);
        }
        bundle.directionAnimRaf = requestAnimationFrame(tick);
      };
      bundle.directionAnimRaf = requestAnimationFrame(tick);
    }
    function stopAllRouteDirectionAnimations(){
      dbusRouteLayers.forEach((bundle) => stopRouteDirectionAnimation(bundle));
    }


    function drawRoute(lineIdx, line, route){
      const key = `${line.uid}:${route.uid}`;
      if(dbusRouteLayers.has(key)) return dbusRouteLayers.get(key);

      let bundleRef = null;
      const group = L.layerGroup().addTo(dbusLayers);
      const poly  = L.polyline([], {
        color: colorFor(lineIdx),
        weight: 8,
        opacity: 1,
        interactive: false,
        pane: "dbusRoutePane"
      }).addTo(group);

      const routeStops = route.stops.map(s => DBUS_STOPS.get(s.uid)).filter(Boolean);
      const latlngs = buildDbusRoutePolylineLatLngs(routeStops, line, route);

      if (latlngs.length >= 2){
        poly.setLatLngs(latlngs);
        startLineAnim(key, poly);
      }

      const effNum = getLineNumber(line, route);
      const parsedRouteLine = String(parseRouteName(route.name || "").lineNumber || "").trim();
      const routeColorToken = routeColorKey(line, route, parsedRouteLine || effNum);
      getLineColors(routeColorToken).then(([bg])=>{
        if(!bg) return;
        poly.setStyle({color:bg});
        if (bundleRef) updateRouteDirectionMarkerColor(bundleRef, bg);
      });

      const { lineNumber, routeTitle, flag } = parseRouteName(route.name || "");
      const { titleStart, titleEnd } = getRouteEndpoints(route);

      const lineCategory = getCategory(line);
      const stops = route.stops.map((s, idx, arr)=> {
        const id = s.uid;
        const st = DBUS_STOPS.get(id);
        const isFirst = (idx===0), isLast=(idx===arr.length-1);
        const n = String(line.number||"").trim();

        if (!st) return null;
        const rawStopName = st.name || "";
        let displayName = rawStopName;

        if (isFirst) displayName = titleStart;
        if (isLast)  displayName = titleEnd;

        const isProvisoireStop = hasProvisoire(rawStopName) || hasProvisoire(displayName);
        const cleanDisplayName = stripProvisoire(displayName);
        const translatedDisplayName = translateStopName(cleanDisplayName);
        const stopNameHTML = withRERIconInStop(translatedDisplayName);
        const xyzCoordParts = [st.X, st.Y, st.Z].map(v => (v == null ? "" : String(v)));
        const xyzCoords = xyzCoordParts.join(";");
        const coordsDisplay = escapeHTML(xyzCoords);
        const gotoCmd = `goto ${xyzCoords}`;

        const { lineNumber } = parseRouteName(route.name || "");
        let cleanNum = String(lineNumber || "").trim();
        cleanNum = cleanNum.replace(/\s*\([^)]*\)/, "").trim();

        const [bg, text] = getLineColorsSync(cleanNum);
        
        const stopOrderLabel = `${idx+1} / ${arr.length}`;
        const temporaryStopLabel = escapeHTML(t("temporary_stop"));
        const coordinatesLabel = escapeHTML(t("coordinates"));
        const copyCommandLabel = escapeHTML(t("copy_command_button"));
        const copyCommandCopiedLabel = escapeHTML(t("copy_command_copied"));
        const copyCommandFailedLabel = escapeHTML(t("copy_command_failed"));
        const gotoCmdAttr = escapeHTML(gotoCmd);
        const html = `
          <div class="stop-popup">
            <div class="sp-header">
              <div class="sp-title">${stopNameHTML}${isProvisoireStop ? ` <span class="stop-flag" aria-label="${temporaryStopLabel}">${temporaryStopLabel}</span>` : ''}</div>
              <div class="sp-index">${stopOrderLabel}</div>
            </div>
            <div class="sp-body">
              <div class="sp-coords">
                <span>${coordinatesLabel}</span>
                <div class="sp-coords-row">
                  <div class="sp-coords-code">${coordsDisplay}</div>
                  <button type="button" class="sp-copy-cmd" data-command="${gotoCmdAttr}" data-copied-label="${copyCommandCopiedLabel}" data-copy-failed-label="${copyCommandFailedLabel}" aria-label="${copyCommandLabel}" title="${copyCommandLabel}">${copyCommandLabel}</button>
                </div>
              </div>
            </div>
          </div>`;

        const marker = L.marker(st.latlng, {
          pane: "dbusRouteMarkerPane",
          interactive: true,
          keyboard: false,
          bubblingMouseEvents: false,
          icon: L.divIcon({
            className: "stop-number",
            // Smaller stop circles for better map readability.
            html: (() => {
              const circleSize = isFirst || isLast ? 22 : 18;
              return `<div style="
                width:${circleSize}px;
                height:${circleSize}px;
                border-radius:50%;
                background:#fff;
                border:2px solid #000;
                display:flex;
                align-items:center;
                justify-content:center;
                font-size:12px;
                font-weight:700;
                color:#000;
              ">${idx+1}</div>`;
            })(),
            iconSize: [isFirst || isLast ? 22 : 18, isFirst || isLast ? 22 : 18],
            iconAnchor: [(isFirst || isLast ? 22 : 18)/2, (isFirst || isLast ? 22 : 18)/2]
          })
        }).addTo(group).bindPopup(
          L.popup({ maxWidth: 420, autoPan: true }).setContent(html)
        );

        marker._routeKey = key;
        marker._stopId = id;

        marker.on('popupopen', (e) => {
          setActiveStopById(id);
          if (marker._routeKey !== currentSelectedKey) {
            e.popup.remove();
            return;
          }
          const el = e.popup.getElement();
          if (!el) return;
          const chip = el.querySelector(".titus-chip") || el.querySelector(".dbus-badge");
          if (!chip) return;
          const isNetworkChip = chip.dataset?.networkBadge === "true";
          if (isNetworkChip) return;

          const { cleanNum } = parseRouteName(route.name || "")
           getLineColors(cleanNum).then(([bg, text]) => {
              const pop = marker.getPopup();
              if (!pop) return;
              const el = pop.getElement();
              if (!el) return;
              const chip = el.querySelector(".titus-chip") || el.querySelector(".dbus-badge");
              if (!chip) return;
              const isNetworkChip = chip.dataset?.networkBadge === "true";

              if (isNetworkChip) return;

              if (isNoctilien2(n)) {
                chip.style.background = "#080080";
                chip.style.color = text;
                if (!el.querySelector('.noctilien-stripe')) {
                  ensureStripe(chip, noctilienStripeColor(n));
                }
              } else {
                chip.style.background = bg;
                chip.style.color = text;
              }
            });

        });

        marker.on('popupclose', ()=>{
          if (currentActiveStopId === id) clearActiveStop();
        });

        getLineColors(cleanNum).then(([bg, text]) => {
          const pop = marker.getPopup();
          if (!pop) return;
          const el = pop.getElement();
          if (!el) return;
          const chip = el.querySelector(".titus-chip") || el.querySelector(".dbus-badge");
          if (!chip) return;
          const isNetworkChip = chip.dataset?.networkBadge === "true";
          if (isNetworkChip) return;

          if (isNoctilien2(n)) {
            chip.style.background = "#080080";
            chip.style.color = text;
            ensureStripe(chip, noctilienStripeColor(n));
          } else {
            chip.style.background = bg;
            chip.style.color = text;
          }
        });


        return marker;
      }).filter(Boolean);

      const bundle = { group, poly, stops, routeLatLngs: latlngs, directionMarkers: [], directionColor: "#ffffff" };
      bundleRef = bundle;
      refreshRouteDirectionMarkers(bundle);
      dbusRouteLayers.set(key, bundle);
      return bundle;
    }

    function hideAllRoutes(){
      stopAllRouteDirectionAnimations();
      dbusLayers.clearLayers();
      routeAnimHandles.forEach(h => h.stop());
      routeAnimHandles.clear();
      hideLinePreview();
      clearActiveStop()
    }
    function forceRouteBundlePassive(bundle){
      if (!bundle) return;
      try {
        if (bundle.poly && typeof bundle.poly.setStyle === "function") {
          bundle.poly.setStyle({ interactive: false, pane: "dbusRoutePane" });
        }
        const polyEl = bundle.poly?._path;
        if (polyEl) polyEl.style.pointerEvents = "none";
      } catch {}
      (bundle.stops || []).forEach(marker => {
        if (!marker) return;
        try {
          marker.options.interactive = true;
          marker.options.keyboard = false;
          marker.options.bubblingMouseEvents = false;
          marker.options.pane = "dbusRouteMarkerPane";
        } catch {}
        try {
          const el = marker.getElement?.();
          if (el) el.style.pointerEvents = "auto";
        } catch {}
      });
    }

    function showOnlyRoute(lineIdx, line, route){
      hideAllRoutes();
      const key = `${line.uid}:${route.uid}`;
      const existing = dbusRouteLayers.get(key);
      let bundle;

      if (existing) {
        dbusLayers.addLayer(existing.group);
        bundle = existing;
        if (existing.poly?._path) startLineAnim(key, existing.poly);
        else existing.poly.once('add', () => startLineAnim(key, existing.poly));
        refreshRouteDirectionMarkers(existing);
      } else {
        bundle = drawRoute(lineIdx, line, route);
      }
      forceRouteBundlePassive(bundle);
      requestAnimationFrame(() => forceRouteBundlePassive(bundle));
      startRouteDirectionAnimation(bundle);

      if (CENTER_ON_LINE_SELECT && route.stops && route.stops.length){
        const first = DBUS_STOPS.get(route.stops[0].uid);
        const marker = bundle.stops[0];
        centerMarkerWithPreview(marker, first?.latlng, { zoom: map.getZoom(), openPopup: true });
      }

      renderLinePreview(line, route);
      bringPoiOverlaysToFront();

      return bundle;
    }
    function invalidateDbusRouteCache(){
      dbusRouteLayers.forEach((bundle) => {
        if (!bundle) return;
        stopRouteDirectionAnimation(bundle);
        clearRouteDirectionMarkers(bundle);
        try { dbusLayers.removeLayer(bundle.group); } catch {}
      });
      dbusRouteLayers.clear();
      routeAnimHandles.forEach((h) => {
        try { h.stop(); } catch {}
      });
      routeAnimHandles.clear();
    }
    function refreshSelectedDbusRouteNavigationMode(){
      if (!currentSelectedKey || !Array.isArray(DBUS_LINES) || !DBUS_LINES.length) return;
      const [lineUid, routeUid] = String(currentSelectedKey).split(":");
      if (!lineUid || !routeUid) return;
      const lineIdx = DBUS_LINES.findIndex((line) => String(line?.uid || "") === String(lineUid));
      if (lineIdx < 0) return;
      const line = DBUS_LINES[lineIdx];
      const route = (line?.routes || []).find((item) => String(item?.uid || "") === String(routeUid));
      if (!line || !route) return;
      hideAllRoutes();
      invalidateDbusRouteCache();
      showOnlyRoute(lineIdx, line, route);
      updateUiOverlays();
    }
    window.refreshSelectedDbusRouteNavigationMode = refreshSelectedDbusRouteNavigationMode;
    let routeDirectionRefreshRaf = 0;
    function refreshActiveRouteDirectionMarkers(){
      if (!currentSelectedKey) return;
      const bundle = dbusRouteLayers.get(currentSelectedKey);
      if (!bundle) return;
      if (!dbusLayers.hasLayer(bundle.group)) return;
      refreshRouteDirectionMarkers(bundle);
    }
    function scheduleActiveRouteDirectionRefresh(){
      if (routeDirectionRefreshRaf) return;
      routeDirectionRefreshRaf = requestAnimationFrame(() => {
        routeDirectionRefreshRaf = 0;
        refreshActiveRouteDirectionMarkers();
      });
    }
    map.on("zoom", scheduleActiveRouteDirectionRefresh);
    map.on("zoomend", refreshActiveRouteDirectionMarkers);
    map.on("moveend", refreshActiveRouteDirectionMarkers);
    map.on("viewreset", refreshActiveRouteDirectionMarkers);
    map.on("resize", scheduleActiveRouteDirectionRefresh);
    map.on("move", scheduleActiveRouteDirectionRefresh);

    function getRouteEndpoints(route){
      const routeTitleRaw = route.name.includes(":") ? route.name.split(":")[1].trim() : route.name;
      const [titleStart0, titleEnd0] = splitRouteEndpoints(routeTitleRaw);
      const rawStart = trimAroundRER(titleStart0, 'start');
      const rawEnd   = trimAroundRER(titleEnd0,   'end');
      const titleStart = translateStopName(rawStart);
      const titleEnd   = translateStopName(rawEnd);
      return { routeTitleRaw, titleStart, titleEnd, rawStart, rawEnd };
    }

    let PREVIEW_STOP_ELEMS = new Map();

    function setActiveStopById(stopId){
      if (!isLinePreviewHorizontal()) {
        PREVIEW_STOP_ELEMS.forEach(({el, routeKey}) => {
          if (routeKey === currentSelectedKey) el.classList.remove('active');
        });
        currentActiveStopId = stopId;
        return;
      }
      PREVIEW_STOP_ELEMS.forEach(({el, routeKey}) => {
        if (routeKey === currentSelectedKey) el.classList.remove('active');
      });
      const rec = PREVIEW_STOP_ELEMS.get(stopId);
      if (rec && rec.routeKey === currentSelectedKey) {
        rec.el.classList.add('active');
        currentActiveStopId = stopId;
      }
    }

    function centerWithPreview(latlng, { zoom = null } = {}) {
      const targetZoom = zoom ?? map.getZoom();
      const paneH = document.getElementById('linePreview')?.offsetHeight || 0;
      const offsetY = Math.round(paneH / 2);
      const p = map.project(latlng, targetZoom);
      const targetPt = L.point(p.x, p.y + offsetY);
      const targetLL = map.unproject(targetPt, targetZoom);
      map.setView(targetLL, targetZoom, { animate: UI_ANIMATIONS });
    }
    function centerWithPreviewAndThen(latlng, { zoom = null, onDone = null, timeoutMs = null } = {}) {
      if (!latlng) {
        if (typeof onDone === "function") onDone();
        return;
      }
      let done = false;
      const finish = () => {
        if (done) return;
        done = true;
        map.off("moveend", onMoveEnd);
        if (typeof onDone === "function") {
          try { onDone(); } catch {}
        }
      };
      const onMoveEnd = () => finish();
      map.once("moveend", onMoveEnd);
      centerWithPreview(latlng, { zoom });
      const wait = Number.isFinite(timeoutMs) ? timeoutMs : Math.max(140, menuAnimDurationMs() + 80);
      setTimeout(finish, wait);
    }
    function centerMarkerWithPreview(marker, latlng, { zoom = null, openPopup = true } = {}) {
      if (!latlng) {
        if (openPopup && marker?.openPopup) marker.openPopup();
        return;
      }
      const popup = marker?.getPopup?.();
      const hadPopup = !!popup;
      const prevAutoPan = hadPopup ? popup.options.autoPan : null;
      if (hadPopup) popup.options.autoPan = false;
      centerWithPreviewAndThen(latlng, {
        zoom,
        onDone: () => {
          if (openPopup && marker?.openPopup) marker.openPopup();
          if (hadPopup) popup.options.autoPan = prevAutoPan;
        }
      });
    }

    function getLineNumber(line, route) {
      if (line.number && line.number !== "?") {
        return line.number;
      }
      const { lineNumber } = parseRouteName(route.name || "");
      return lineNumber || "?";
    }

    function refreshLinePreviewRail(){
      const transit = document.getElementById("lpTransit");
      if (!transit) return;
      const rail = transit.querySelector(".transit-main-line");
      if (!rail) return;
      const stops = [...transit.querySelectorAll(".stop")];
      if (stops.length < 2) {
        rail.style.width = "0px";
        rail.style.height = "0px";
        return;
      }
      const firstStop = stops[0];
      const lastStop = stops[stops.length - 1];
      const firstDot = firstStop.querySelector(".dot");
      const lastDot = lastStop.querySelector(".dot");
      if (!firstDot || !lastDot) return;

      const transitRect = transit.getBoundingClientRect();
      const firstRect = firstDot.getBoundingClientRect();
      const firstX = (firstRect.left - transitRect.left) + (firstRect.width / 2);
      const firstY = (firstRect.top - transitRect.top) + (firstRect.height / 2);
      const trimEndPx = 1;
      if (isLinePreviewHorizontal()) {
        const lastRect = lastDot.getBoundingClientRect();
        const lastX = (lastRect.left - transitRect.left) + (lastRect.width / 2);
        const railHeight = Math.max(1, rail.offsetHeight || 4);
        const goesRight = lastX >= firstX;
        const left = goesRight ? firstX : (lastX + trimEndPx);
        const width = Math.max(0, Math.abs(lastX - firstX) - trimEndPx);
        const top = firstY - (railHeight / 2);
        rail.style.left = `${left}px`;
        rail.style.top = `${top}px`;
        rail.style.width = `${width}px`;
        rail.style.height = `${railHeight}px`;
        return;
      }
      const lastRect = lastDot.getBoundingClientRect();
      const lastY = (lastRect.top - transitRect.top) + (lastRect.height / 2);
      const railWidth = Math.max(1, rail.offsetWidth || 4);
      const goesDown = lastY >= firstY;
      const top = goesDown ? firstY : (lastY + trimEndPx);
      const height = Math.max(0, Math.abs(lastY - firstY) - trimEndPx);
      const left = firstX - (railWidth / 2);
      rail.style.left = `${left}px`;
      rail.style.top = `${top}px`;
      rail.style.width = `${railWidth}px`;
      rail.style.height = `${height}px`;
    }

    function renderLinePreview(line, route){
      PREVIEW_STOP_ELEMS = new Map();

      const wrap = document.getElementById("linePreviewWrap");
      const badge = document.getElementById("lpBadge");
      const title = document.getElementById("lpRouteTitle");
      const meta = document.getElementById("lpRouteMeta");
      const transit = document.getElementById("lpTransit");
      if(!wrap || !badge || !title || !transit || !meta) return;

      const { titleStart, titleEnd, rawStart, rawEnd } = getRouteEndpoints(route);
      const cleanedStart = withRERIcon(titleStart);
      const cleanedEnd   = withRERIcon(titleEnd);
      const { lineNumber } = parseRouteName(route.name || "");
      const lineCategory = getCategory(line);

      const stopCount = route.stops.length;

      let durationText;
      if (route.totalMinutes >= 60) {
        const h = Math.floor(route.totalMinutes / 60);
        const m = route.totalMinutes % 60;
          if (m > 0) {
            durationText = `${h} h ${m} ${minuteShortLabel()}`;
          } else {
            durationText = `${h} h`;
          }
        } else {
          durationText = `${route.totalMinutes} ${minuteShortLabel()}`;
        }
      
      title.innerHTML = `${cleanedStart} &gt; ${cleanedEnd}`;
      title.dataset.rawStart = rawStart || "";
      title.dataset.rawEnd = rawEnd || "";
      setStopDurationText(meta, stopCount, durationText, "dash");
      const isExpressLinePreview = isExpress(line) || isExpressNumber(lineNumber) || isFlix(line) || lineCategory === "FlixBus" || isAutocar(line) || isFictive(line);
      const linePreviewChipClass = isExpressLinePreview
        ? "dbus-badge network-chip network-chip-express"
        : "dbus-badge network-chip";
      const mTitusLP = /^titus\s*(\d+)/i.exec(String(lineNumber||""));
      const isNoctLinePreview = isNoctilien2(lineNumber);
      let previewBadgeChip = null;

      const lpLink = document.getElementById("lpLink");
      if (lpLink){
        const url = getLineLink(line, route);
        const hasUrl = !!url;
        if (hasUrl) {
          lpLink.href = url;
          lpLink.hidden = false;
          lpLink.style.display = "";
        } else {
          lpLink.removeAttribute("href");
          lpLink.hidden = true;
          lpLink.style.display = "none";
        }
      }
      updateLinePreviewAudioButton(line, route);

      function applyNetworkBadgeToPreview(opts){
        badge.innerHTML = "";
        badge.className = "lp-badge-wrapper";
        badge.style.background = "transparent";
        badge.style.color = "#fff";
        delete badge.dataset.networkBadge;
        delete badge.dataset.badgeRaw;
        const { wrap, chip } = createNetworkBadgeElement(opts);
        badge.appendChild(wrap);
        previewBadgeChip = chip;
      }

      function applyDefaultBadgeToPreview(extraClass = ""){
        const safeExtra = String(extraClass || "").trim();
        badge.className = `dbus-badge${safeExtra ? ` ${safeExtra}` : ""}`;
        badge.innerHTML = "";
        delete badge.dataset.networkBadge;
        badge.dataset.badgeRaw = String(lineNumber || "").trim();
        ensureBadgeLabel(badge, translateBadgeToken(lineNumber));
        badge.style.background = "#444";
        badge.style.color = "#fff";
        previewBadgeChip = badge;
      }

      function applySchoolBadgeToPreview(){
        badge.innerHTML = "";
        badge.className = "lp-badge-wrapper";
        badge.style.background = "transparent";
        badge.style.color = "#fff";
        badge.dataset.networkBadge = "true";
        delete badge.dataset.badgeRaw;
        const wrap = document.createElement("div");
        wrap.className = "network-badge";
        const school = document.createElement("img");
        school.src = overlayPath("bus_school.png");
        school.alt = t("dbus_school_toggle");
        wrap.appendChild(school);
        badge.appendChild(wrap);
        previewBadgeChip = badge;
      }

      if (mTitusLP) {
        applyNetworkBadgeToPreview({
          label: mTitusLP[1],
          imgSrc: overlayPath("reseau_titus.png"),
          alt: "Reseau Titus",
          colorKey: lineNumber,
          chipClass: "dbus-badge titus-chip"
        });
      } else if (isNoctLinePreview) {
        applyNetworkBadgeToPreview({
          label: lineNumber,
          imgSrc: overlayPath("noctilien_logo_idfm.png"),
          alt: "Noctilien",
          stripeColor: noctilienStripeColor(lineNumber)
        });
      } else if (lineCategory === "Scolaire") {
        applySchoolBadgeToPreview();
      } else if (lineCategory === "FlixBus") {
        applyDefaultBadgeToPreview("network-chip network-chip-express");
      } else if (lineCategory === "Urbain") {
        applyNetworkBadgeToPreview({
          label: lineNumber,
          imgSrc: overlayPath("bus_logo_idfm.png"),
          alt: "Reseau urbain Ile-de-France Mobilites",
          chipClass: linePreviewChipClass
        });
      } else if (lineCategory === "Autres") {
        const previewChipClassOnly = linePreviewChipClass.replace(/\bdbus-badge\b/g, "").trim();
        applyDefaultBadgeToPreview(previewChipClassOnly);
      } else {
        applyDefaultBadgeToPreview();
      }

      if (transit) transit.style.setProperty('--lineColor', '#8a8a8a');
      if (linePreviewStopsBox) linePreviewStopsBox.style.setProperty('--lineColor', '#8a8a8a');

      const previewBadgeTarget = previewBadgeChip || badge;
      const isPreviewNetwork = previewBadgeTarget?.dataset?.networkBadge === "true";
      if (!isPreviewNetwork && isNoctilien2(line.number)) {
        ensureStripe(previewBadgeTarget, noctilienStripeColor(line.number));
      }

      const colorKeyLP = lineNumber || getLineNumber(line, route);
      getLineColors(colorKeyLP).then(([bg, text])=>{
        if (previewBadgeTarget && !isPreviewNetwork){
          previewBadgeTarget.style.background = bg;
          previewBadgeTarget.style.color = text;
        }
        if (transit) transit.style.setProperty('--lineColor', bg);
        if (linePreviewStopsBox) linePreviewStopsBox.style.setProperty('--lineColor', bg);
        if (!isPreviewNetwork && isNoctilien2(colorKeyLP)) {
          ensureStripe(previewBadgeTarget, noctilienStripeColor(colorKeyLP));
        }
      });

      transit.innerHTML = "";
      if (transitScroll) transitScroll.scrollTop = 0;
      const rail = document.createElement("div");
      rail.className = "transit-main-line";
      transit.appendChild(rail);
      const temporaryStopLabel = escapeHTML(t("temporary_stop"));
      const ids = route.stops.map(s => s.uid);
      ids.forEach((id, idx) => {
        const st = DBUS_STOPS.get(id); if(!st) return;
        const rawStopName = st.name || "";
        let label = rawStopName;
        if (idx === 0) label = titleStart;
        else if (idx === ids.length-1) label = titleEnd;

        const stopEl = document.createElement("div");
        stopEl.className = "stop" + (idx===0 ? " first" : (idx===ids.length-1 ? " last" : ""));
        stopEl.dataset.stopId = String(id);
        const isProvisoire = hasProvisoire(rawStopName) || hasProvisoire(label);
        const cleanLabel = stripProvisoire(label);
        const translatedLabel = translateStopName(cleanLabel);
        stopEl.dataset.rawLabel = cleanLabel;
        stopEl.dataset.provisoire = isProvisoire ? "1" : "0";
        stopEl.innerHTML = `
          <div class="dot"></div>
          <div class="name">${withRERIcon(translatedLabel)}${isProvisoire ? ` <span class="stop-flag" aria-label="${temporaryStopLabel}">${temporaryStopLabel}</span>` : ''}</div>
        `;
        
        stopEl.addEventListener('click', ()=>{
          const bundle = dbusRouteLayers.get(currentSelectedKey);
          const mk  = bundle?.stops?.[idx];
          const stObj = DBUS_STOPS.get(id);
          centerMarkerWithPreview(mk, stObj?.latlng, { zoom: map.getZoom(), openPopup: true });
          setActiveStopById(id);
        });
        PREVIEW_STOP_ELEMS.set(id, { el: stopEl, idx, routeKey: currentSelectedKey });

        transit.appendChild(stopEl);
      });
      const firstId = route.stops[0]?.uid;
      if (typeof firstId !== 'undefined') setActiveStopById(firstId);

      if (typeof closeSearchUI === "function" && typeof isSearchOpen === "function" && isSearchOpen()) {
        closeSearchUI({ reset: true });
      }
      clearPanelCloseTimer(wrap);
      wrap.style.display = "block";
      wrap.classList.add("is-open");
      wrap.classList.remove("is-closing");
      refreshLinePreviewRail();
      requestAnimationFrame(() => {
        refreshLinePreviewRail();
        updateLinePreviewScrollCues();
      });
      updateUiOverlays();
      applyI18N();
    }

    function restoreLinePreview(key){
      const routeKey = key || currentSelectedKey;
      if (!routeKey) return;
      const [lineUid, routeUid] = routeKey.split(":");
      const line = (DBUS_LINES || []).find(l => String(l.uid) === String(lineUid));
      const route = line?.routes?.find(r => String(r.uid) === String(routeUid));
      if (line && route) renderLinePreview(line, route);
    }
    window.restoreLinePreview = restoreLinePreview;

    function hideLinePreview(){
      const wrap = document.getElementById("linePreviewWrap");
      if (wrap) {
        wrap.classList.remove("is-open");
        clearPanelCloseTimer(wrap);
        if (UI_ANIMATIONS) {
          wrap.classList.add("is-closing");
          const timer = setTimeout(() => {
            if (PANEL_CLOSE_TIMERS.get(wrap) !== timer) return;
            PANEL_CLOSE_TIMERS.delete(wrap);
            wrap.classList.remove("is-closing");
            wrap.style.display = "none";
            updateUiOverlays();
          }, previewAnimDurationMs());
          PANEL_CLOSE_TIMERS.set(wrap, timer);
        } else {
          wrap.classList.remove("is-closing");
          wrap.style.display = "none";
        }
      }
      if (linePreviewStopsBox) {
        linePreviewStopsBox.classList.remove("can-scroll-up", "can-scroll-down");
      }
      clearLinePreviewAudioRouteState({ closePanel: false, stopPlayback: true });
      updateLinePreviewAudioGlobalFolderSelect();
      clearActiveStop()
      updateUiOverlays();
    }

    document.getElementById("lpClose")?.addEventListener("click", () => {
      currentSelectedKey = "";
      hideAllRoutes();
      document.getElementById("dbusPanel")?.querySelectorAll(".dbus-item")?.forEach(it => {
        it.classList.remove("active");
        it.style.outline = "none";
      });
      renderSelectedChip();
      updateDbusModeUI();
    });
    document.getElementById("lpAudioLink")?.addEventListener("click", (event) => {
      event.preventDefault();
      if (isLinePreviewAudioPanelOpen()) {
        closeLinePreviewAudioPanel({ stopPlayback: true });
        return;
      }
      openLinePreviewAudioPanel();
    });
    document.getElementById("lpAudioPanelClose")?.addEventListener("click", () => {
      closeLinePreviewAudioPanel({ stopPlayback: true });
    });
    document.getElementById("lpAudioPanelClose")?.addEventListener("pointerdown", (event) => {
      event.stopPropagation();
    });
    document.getElementById("lpAudioPrevBtn")?.addEventListener("click", () => {
      if (!LINE_PREVIEW_AUDIO_STATE.enabled) return;
      setLinePreviewAudioCurrentIndex((LINE_PREVIEW_AUDIO_STATE.currentIndex || 0) - 1);
    });
    document.getElementById("lpAudioCurrentBtn")?.addEventListener("click", () => {
      if (!LINE_PREVIEW_AUDIO_STATE.enabled) return;
      playLinePreviewCurrentStop(LINE_PREVIEW_AUDIO_STATE.currentIndex || 0);
    });
    document.getElementById("lpAudioNextBtn")?.addEventListener("click", () => {
      if (!LINE_PREVIEW_AUDIO_STATE.enabled) return;
      setLinePreviewAudioCurrentIndex((LINE_PREVIEW_AUDIO_STATE.currentIndex || 0) + 1);
    });
    document.getElementById("lpAudioTerminusBtn")?.addEventListener("click", () => {
      if (!LINE_PREVIEW_AUDIO_STATE.enabled) return;
      playLinePreviewTerminusSequence();
    });
    document.getElementById("lpAudioVolumeRange")?.addEventListener("input", (event) => {
      const value = Number(event?.target?.value);
      if (!Number.isFinite(value)) return;
      setLinePreviewAudioVolume(value / 100);
    });
    document.getElementById("lpAudioStopBtn")?.addEventListener("click", () => {
      stopLinePreviewAudioPlayback();
    });
    document.getElementById("lpAudioStyleSelect")?.addEventListener("change", (event) => {
      const nextPath = String(event?.target?.value || "");
      if (!nextPath) return;
      setLinePreviewAudioStyleByPath(nextPath, { stopPlayback: true });
    });
    document.getElementById("lpAudioGlobalFolderSelect")?.addEventListener("change", (event) => {
      const nextPath = String(event?.target?.value || "");
      setLinePreviewAudioGlobalFolderByPath(nextPath);
    });
    setLinePreviewAudioVolume(1);
    ensureLinePreviewAudioGlobalFoldersLoaded();

    function openSettingsPanel() {
      closeSearchUI({ reset: true });
      closeDbusPanel();
      resetDbusSelection();
      closeLangMenu();
      if (!$panelSettings) return;
      openPanel($panelSettings, { display: "flex", ariaHidden: false });
      $btnSettings?.setAttribute("aria-expanded", "true");
      updateUiOverlays();
    }
    function closeSettingsPanel() {
      if (!$panelSettings) return;
      closePanel($panelSettings, { durationMs: menuAnimDurationMs(), ariaHidden: true });
      $btnSettings?.setAttribute("aria-expanded", "false");
      updateUiOverlays();
    }
    function isSettingsOpen() {
      return !!$panelSettings && getComputedStyle($panelSettings).display !== "none" && !$panelSettings.classList.contains("is-closing");
    }

    function isDbusDisplayModeForced(){
      return dbusDisplayMode === "dbus";
    }
    function applyDbusDisplayMode(forceRender = false){
      if (isDbusDisplayModeForced()) {
        dbusDepartPreviewActive = true;
        if (currentDbusMode === DBUS_MODES.DEPARTS) currentDbusMode = DBUS_MODES.LINES;
        updateDbusModeUI();
        if (forceRender || !dbusDepartGroups.length) refreshDbusDepartures(true);
        else showDbusDepartures();
      } else {
        if (currentDbusMode === DBUS_MODES.DEPARTS) currentDbusMode = DBUS_MODES.LINES;
        dbusDepartPreviewActive = false;
        hideDbusDepartures();
        closeDbusStopPanel();
        updateDbusModeUI();
        if (typeof renderDbusLinesList === "function") renderDbusLinesList(currentDbusMode);
      }
      updateDbusDepartIndicator();
    }

    function openDbusPanel() {
      if (!isDbusDisplayModeForced() && dbusDepartPreviewActive) {
        dbusDepartPreviewActive = false;
        hideDbusDepartures();
      }
      closeLangMenu();
      closeSearchUI({ reset: true });
      closeSettingsPanel();
      closeDbusStopPanel();
      updateDbusModeUI();
      if (typeof renderDbusLinesList === "function" && currentDbusMode !== DBUS_MODES.DEPARTS) {
        renderDbusLinesList(currentDbusMode);
      }
      openPanel($panelDbus, { display: "flex" });
      $btnDbus?.setAttribute('aria-expanded','true');
      updateDbusDepartIndicator();
      updateUiOverlays();
    }
    function shouldKeepDbusSelectionOnClose() {
      return window.matchMedia("(max-width: 980px), (max-height: 700px)").matches;
    }
    function closeDbusPanel() {
      closePanel($panelDbus, { durationMs: menuAnimDurationMs() });
      $btnDbus?.setAttribute('aria-expanded','false');
      dbusRoutesClosedByPanel = true;
      applyDbusDisplayMode(true);
      closeDbusStopPanel();
      updateDbusDepartIndicator();
      updateUiOverlays();
    }
    document.getElementById("dbusPanelClose")?.addEventListener("click", closeDbusPanel);
    document.getElementById("dbusStopClose")?.addEventListener("click", closeDbusStopPanel);
    $settingsPanelClose?.addEventListener("click", closeSettingsPanel);
    function parseCssDurationMs(value, fallbackMs = 0){
      const raw = String(value || "").trim();
      const m = raw.match(/^(-?\d*\.?\d+)(ms|s)$/i);
      if (!m) return fallbackMs;
      const amount = parseFloat(m[1]);
      if (!Number.isFinite(amount)) return fallbackMs;
      return m[2].toLowerCase() === "s" ? Math.max(0, Math.round(amount * 1000)) : Math.max(0, Math.round(amount));
    }
    function readDurationVarMs(varName, fallbackMs){
      const raw = getComputedStyle(document.documentElement).getPropertyValue(varName);
      return parseCssDurationMs(raw, fallbackMs);
    }
    function menuAnimDurationMs(){
      return readDurationVarMs("--anim-med", 240);
    }
    function previewAnimDurationMs(){
      return readDurationVarMs("--anim-slow", 340);
    }
    const PANEL_CLOSE_TIMERS = new WeakMap();
    function clearPanelCloseTimer(el){
      if (!el) return;
      const t = PANEL_CLOSE_TIMERS.get(el);
      if (t) {
        clearTimeout(t);
        PANEL_CLOSE_TIMERS.delete(el);
      }
      el.classList.remove("is-closing");
    }
    function finishPanelClose(el, { ariaHidden } = {}){
      if (!el) return;
      clearPanelCloseTimer(el);
      el.style.display = "none";
      if (typeof ariaHidden === "boolean") {
        el.setAttribute("aria-hidden", ariaHidden ? "true" : "false");
      }
    }
    function openPanel(el, { display = "flex", ariaHidden } = {}){
      if (!el) return;
      clearPanelCloseTimer(el);
      el.style.display = display;
      if (typeof ariaHidden === "boolean") {
        el.setAttribute("aria-hidden", ariaHidden ? "true" : "false");
      }
      setMenuOpen(el, true);
    }
    function closePanel(el, { durationMs = 0, ariaHidden } = {}){
      if (!el) return;
      clearPanelCloseTimer(el);
      setMenuOpen(el, false);
      if (typeof ariaHidden === "boolean") {
        el.setAttribute("aria-hidden", ariaHidden ? "true" : "false");
      }
      if (!UI_ANIMATIONS || durationMs <= 0) {
        finishPanelClose(el, { ariaHidden });
        return;
      }
      el.classList.add("is-closing");
      const timer = setTimeout(() => {
        if (PANEL_CLOSE_TIMERS.get(el) !== timer) return;
        PANEL_CLOSE_TIMERS.delete(el);
        finishPanelClose(el, { ariaHidden });
      }, durationMs);
      PANEL_CLOSE_TIMERS.set(el, timer);
    }
    function isDbusOpen() {
      return !!$panelDbus && getComputedStyle($panelDbus).display !== "none" && !$panelDbus.classList.contains("is-closing");
    }
    function isDbusStopOpen() {
      return !!$dbusStopPanel && getComputedStyle($dbusStopPanel).display !== "none" && !$dbusStopPanel.classList.contains("is-closing");
    }
    function isLinePreviewOpen() {
      const wrap = document.getElementById("linePreviewWrap");
      return !!wrap && getComputedStyle(wrap).display !== "none" && !wrap.classList.contains("is-closing");
    }
    function isButtonDisabled(btn){
      return !!btn && (btn.classList.contains("is-disabled") || btn.getAttribute("aria-disabled") === "true");
    }
    function setButtonDisabled(btn, disabled){
      if (!btn) return;
      btn.classList.toggle("is-disabled", disabled);
      if (disabled) btn.setAttribute("aria-disabled", "true");
      else btn.removeAttribute("aria-disabled");
    }
    function setMenuOpen(el, open){
      if (!el) return;
      if (open) el.classList.remove("is-closing");
      el.classList.toggle("is-open", !!open);
    }
    function closeAllMenus({ resetSearch = true } = {}){
      closeSearchUI({ reset: resetSearch });
      closeDbusPanel();
      closeSettingsPanel();
      closeDbusStopPanel();
      hideLinePreview();
      try { resetDbusSelection(); } catch {}
      try { closeLangMenu(); } catch {}
    }
    function syncMapIconInteractivity(disabled){
      const isDisabled = !!disabled;
      if (MAP_POI_OVERLAYS_HIDDEN !== isDisabled) {
        MAP_POI_OVERLAYS_HIDDEN = isDisabled;
        ZOOM_SIZED_IMAGE_OVERLAYS.forEach(rec => {
          const overlay = rec?.overlay;
          if (!overlay) return;
          if (isDisabled) {
            try { if (map.hasLayer(overlay)) map.removeLayer(overlay); } catch {}
            return;
          }
          try {
            if (!map.hasLayer(overlay)) overlay.addTo(map);
            applyZoomSizedOverlayBounds(rec);
          } catch {}
        });
      }
      document.querySelectorAll(".leaflet-image-layer.leaflet-zoom-animated.leaflet-interactive").forEach(el => {
        el.style.pointerEvents = isDisabled ? "none" : "auto";
        el.style.visibility = isDisabled ? "hidden" : "visible";
      });
      document.querySelectorAll(".leaflet-marker-icon.dbus-stop-marker-host").forEach(el => {
        el.style.pointerEvents = isDisabled ? "none" : "auto";
        el.style.visibility = isDisabled ? "hidden" : "visible";
      });
    }
    function updateUiOverlays() {
      refreshHeaderMetrics();
      refreshSaeivTopButtonVisibility();
      refreshLinePreviewAudioTopButtonVisibility({ closePanelOnHide: true });
      const hasSelectedRoute = !!String(currentSelectedKey || "").trim();
      document.body.classList.toggle("route-selected", hasSelectedRoute);
      const isDbusMenuOpen = isDbusOpen() || isDbusStopOpen();
      const isSettingsPanelOpen = isSettingsOpen();
      const isMenuOpen = isDbusMenuOpen || isSettingsPanelOpen;
      const isRightSidePanelOpen = isDbusOpen() || isSettingsPanelOpen;
      const activeRightPanelWidth = isRightSidePanelOpen ? getActiveRightPanelWidth() : 0;
      if (activeRightPanelWidth > 0) {
        document.documentElement.style.setProperty("--activePanelShift", `${activeRightPanelWidth}px`);
      } else {
        document.documentElement.style.removeProperty("--activePanelShift");
      }
      const shouldHideMapTopbarControls = isRightSidePanelOpen && isCompactViewportForOpenPanels();
      document.body.classList.toggle("compact-open-ui", shouldHideMapTopbarControls);
      const isPreviewOpen = isLinePreviewOpen();
      document.body.classList.toggle("preview-open", isPreviewOpen);
      document.body.classList.remove("map-icons-disabled");
      syncMapIconInteractivity(false);
      const lockSearch = isPreviewOpen;
      const isDepartIndicatorOpen = !!$dbusDepartIndicatorWrap && !$dbusDepartIndicatorWrap.hidden;
      const isSearchPanelOpen = isSearchOpen();
      const isSaeivPanelOpenNow = isSaeivPanelOpen();
      const isAudioPanelOpen = isLinePreviewAudioPanelOpen();
      if (lockSearch && isSearchPanelOpen && typeof closeSearchUI === "function") {
        closeSearchUI({ reset: true });
      }
      if ($btnSearch) $btnSearch.classList.toggle("is-open", isSearchPanelOpen);
      if ($btnDbus) $btnDbus.classList.toggle("is-open", isDbusMenuOpen || isPreviewOpen || isDepartIndicatorOpen);
      if ($btnSaeivPanel) {
        $btnSaeivPanel.classList.toggle("is-open", isSaeivPanelOpenNow);
        $btnSaeivPanel.setAttribute("aria-expanded", isSaeivPanelOpenNow ? "true" : "false");
      }
      if ($btnAudioPanel) {
        $btnAudioPanel.classList.toggle("is-open", isAudioPanelOpen);
        $btnAudioPanel.setAttribute("aria-expanded", isAudioPanelOpen ? "true" : "false");
      }
      if ($btnLang) $btnLang.classList.toggle("is-open", isLangMenuOpen());
      if ($btnSettings) $btnSettings.classList.toggle("is-open", isSettingsPanelOpen);
      if ($topBar) $topBar.classList.toggle("dbus-open", isRightSidePanelOpen);
      if ($topActions) $topActions.classList.toggle("dbus-open", isRightSidePanelOpen);
      if ($searchPanelHost) $searchPanelHost.classList.toggle("dbus-open", isRightSidePanelOpen);
      if ($watermark) $watermark.classList.toggle("dbus-open", isMenuOpen);
      const linePreviewWrapEl = document.getElementById("linePreviewWrap");
      if (linePreviewWrapEl) {
        const canOffsetPreview = window.matchMedia("(min-width: 981px)").matches;
        linePreviewWrapEl.classList.toggle("with-side-panel", isRightSidePanelOpen && canOffsetPreview);
      }
      if (isPreviewOpen) {
        refreshLinePreviewRail();
        updateLinePreviewScrollCues();
      }
      setButtonDisabled($btnSearch, lockSearch);
      setButtonDisabled($btnDbus, false);
      setButtonDisabled($btnSettings, false);
      setButtonDisabled($btnSaeivPanel, !(
        SAEIV_FEATURE_ALLOWED &&
        isLinePreviewAudioLanguageAllowed() &&
        !!SAEIV_PANEL_BUTTON_ENABLED
      ));
      if ($search) {
        $search.disabled = lockSearch;
        if (lockSearch) $search.setAttribute("aria-disabled", "true");
        else $search.removeAttribute("aria-disabled");
      }
      const scaleEl = document.getElementById("custom-scale");
      if (scaleEl) scaleEl.hidden = isPreviewOpen;
      syncSaeivExternalState({ force: false });
    }
    function updateDbusDepartIndicator(){
      if (!$dbusDepartIndicatorWrap) return;
      $dbusDepartIndicatorWrap.hidden = true;
      updateUiOverlays();
    }
    function refreshDbusDepartures(showOnMap){
      const needsBuild = !dbusDepartGroups.length || dbusDepartFilterKey !== `${showSchoolLines}-${showFictiveLines}`;
      if (needsBuild) buildDbusDepartures();
      else renderDbusDepartList();
      if (showOnMap) showDbusDepartures();
      else hideDbusDepartures();
    }
    function openSearchUI({ focus = false, refresh = false } = {}) {
      if (isButtonDisabled($btnSearch)) return;
      closeLangMenu();
      closeDbusPanel();
      closeSettingsPanel();
      if ($searchPanel) {
        openPanel($searchPanel, { display: "flex", ariaHidden: false });
      }
      $btnSearch?.setAttribute("aria-expanded", "true");
      if (refresh) doSearch($search.value);
      $results.hidden = false;
      if (focus) setTimeout(() => $search?.focus(), 0);
      updateUiOverlays();
    }
    function closeSearchUI({ reset = false } = {}) {
      if (reset) $search.value = '';
      renderResults([]); 
      $results.hidden = true;
      $search.blur();
      if ($searchPanel) {
        closePanel($searchPanel, { durationMs: menuAnimDurationMs(), ariaHidden: true });
      }
      $btnSearch?.setAttribute("aria-expanded", "false");
      updateUiOverlays();
    }
    function isSearchOpen(){
      return !!$searchPanel && getComputedStyle($searchPanel).display !== 'none' && !$searchPanel.classList.contains("is-closing");
    }

    if ($btnSearch) {
      $btnSearch.addEventListener("click", () => {
        if (isButtonDisabled($btnSearch)) {
          closeAllMenus({ resetSearch: true });
          return;
        }
        if (isSearchOpen()) closeSearchUI({ reset: true });
        else {
          setActiveSearchCategory(SEARCH_CATEGORY_ALL);
          $search.value = "";
          openSearchUI({ focus: true, refresh: true });
        }
      });
    }
    $searchPanelClose?.addEventListener("click", () => closeSearchUI({ reset: true }));

    $dbusModeButtons.forEach(btn => {
      btn.addEventListener("click", () => setDbusMode(btn.dataset.mode));
    });
    updateDbusModeUI();
    function onDbusFilterChange() {
      dbusRoutesClosedByPanel = true;
      updateDbusModeUI();
      const selectedLineUid = (() => {
        if (currentSelectedKey) {
          const [uid] = String(currentSelectedKey).split(":");
          return uid || "";
        }
        return currentSelectedLineUid || "";
      })();
      if ((!showSchoolLines || !showFictiveLines) && selectedLineUid) {
        try {
          const line = DBUS_LINES.find(l => String(l.uid) === String(selectedLineUid));
          const cat = line ? getCategory(line) : "";
          if (!showSchoolLines && cat === "Scolaire") clearDbusSelection();
          if (!showFictiveLines && cat === "Autres") clearDbusSelection();
        } catch {}
      }
      if (isDbusDisplayModeForced()) {
        closeDbusStopPanel();
        refreshDbusDepartures(true);
        if (typeof renderDbusLinesList === "function") renderDbusLinesList(currentDbusMode);
        renderDbusStopsLayer();
        return;
      }
      if (currentDbusMode === DBUS_MODES.DEPARTS) {
        closeDbusStopPanel();
        refreshDbusDepartures(dbusDepartPreviewActive);
        renderDbusStopsLayer();
        return;
      }
      if (typeof renderDbusLinesList === "function") renderDbusLinesList(currentDbusMode);
      renderDbusStopsLayer();
    }
    function syncFilterTogglesUI() {
      if ($dbusSchoolToggle) $dbusSchoolToggle.checked = !!showSchoolLines;
      if ($settingsSchoolToggle) $settingsSchoolToggle.checked = !!showSchoolLines;
      if ($dbusFictiveToggle) $dbusFictiveToggle.checked = !!showFictiveLines;
      if ($settingsFictiveToggle) $settingsFictiveToggle.checked = !!showFictiveLines;
    }
    function setSchoolFilter(next, { apply = true } = {}) {
      showSchoolLines = !!next;
      syncFilterTogglesUI();
      if (apply) onDbusFilterChange();
    }
    function setFictiveFilter(next, { apply = true } = {}) {
      showFictiveLines = !!next;
      syncFilterTogglesUI();
      if (apply) onDbusFilterChange();
    }
    if ($dbusSchoolToggle) setSchoolFilter($dbusSchoolToggle.checked, { apply: false });
    else if ($settingsSchoolToggle) setSchoolFilter($settingsSchoolToggle.checked, { apply: false });
    if ($dbusFictiveToggle) setFictiveFilter($dbusFictiveToggle.checked, { apply: false });
    else if ($settingsFictiveToggle) setFictiveFilter($settingsFictiveToggle.checked, { apply: false });

    $dbusSchoolToggle?.addEventListener("change", () => setSchoolFilter($dbusSchoolToggle.checked));
    $settingsSchoolToggle?.addEventListener("change", () => setSchoolFilter($settingsSchoolToggle.checked));
    $dbusFictiveToggle?.addEventListener("change", () => setFictiveFilter($dbusFictiveToggle.checked));
    $settingsFictiveToggle?.addEventListener("change", () => setFictiveFilter($settingsFictiveToggle.checked));

    $btnSaeivPanel?.addEventListener("click", async () => {
      if (isButtonDisabled($btnSaeivPanel)) return;
      if (!SAEIV_FEATURE_ALLOWED || !isLinePreviewAudioLanguageAllowed() || !SAEIV_PANEL_BUTTON_ENABLED) {
        closeSaeivPanel();
        return;
      }
      if (isSaeivPanelOpen()) {
        closeSaeivPanel();
        return;
      }
      await openSaeivPanel();
      updateUiOverlays();
    });
    window.addEventListener("beforeunload", () => {
      closeSaeivPanel({ update: false });
    });

    $btnAudioPanel?.addEventListener("click", () => {
      if (isButtonDisabled($btnAudioPanel)) return;
      if (!isLinePreviewAudioLanguageAllowed()) {
        closeLinePreviewAudioPanel({ stopPlayback: true });
        updateUiOverlays();
        return;
      }
      if (isLinePreviewAudioPanelOpen()) {
        closeLinePreviewAudioPanel({ stopPlayback: true });
        updateUiOverlays();
        return;
      }
      closeSearchUI({ reset: true });
      try { closeLangMenu(); } catch {}
      openLinePreviewAudioPanel();
      updateUiOverlays();
    });

    $btnDbus.addEventListener('click', () => {
      if (isButtonDisabled($btnDbus)) {
        closeAllMenus({ resetSearch: true });
        return;
      }
      if (isDbusOpen()) closeDbusPanel();
      else openDbusPanel();
      renderSelectedChip();
    });
    $dbusRoutesClear?.addEventListener("click", () => {
      clearDbusSelection($panelDbus);
    });

    $dbusDepartIndicatorClose?.addEventListener("click", () => {
      dbusDepartPreviewActive = false;
      if (isDbusDisplayModeForced()) {
        dbusDisplayMode = "normal";
      }
      setDbusMode(DBUS_MODES.LINES);
      updateDbusDepartIndicator();
    });
    $dbusDepartMapBtn?.addEventListener("click", () => {
      dbusDepartPreviewActive = true;
      if (currentDbusMode !== DBUS_MODES.DEPARTS) setDbusMode(DBUS_MODES.DEPARTS);
      else refreshDbusDepartures(true);
      closeDbusPanel();
    });


    function renderSelectedChip(){
      const host = $selectedChip;
      if (!currentSelectedKey) { host.style.display="none"; host.innerHTML=""; return; }
      host.style.display = "none";
      host.innerHTML = "";
    }

    function createDbusNoneAction(onActivate){
      const empty = document.createElement("div");
      empty.className = "dbus-none";
      empty.textContent = t("none");
      empty.tabIndex = 0;
      empty.setAttribute("role", "button");
      const activate = () => {
        if (typeof onActivate === "function") onActivate();
      };
      empty.addEventListener("click", activate);
      empty.addEventListener("keydown", (event) => {
        if (event.key !== "Enter" && event.key !== " ") return;
        event.preventDefault();
        activate();
      });
      return empty;
    }

    function showDbusRoutesPlaceholder(){
      if (!$dbusRoutesList) return;
      $dbusRoutesList.innerHTML = "";
      const empty = createDbusNoneAction(() => {
        if (window.__DBUS_GRID_OPEN && typeof window.__DBUS_GRID_OPEN.clear === "function") {
          try { window.__DBUS_GRID_OPEN.clear(); } catch {}
          window.__DBUS_GRID_OPEN = null;
          return;
        }
        resetDbusSelection();
      });
      $dbusRoutesList.appendChild(empty);
      setDbusRoutesTitleCount(null);
    }
    function setDbusRoutesTitleCount(count = null){
      if (!$dbusRoutesTitleLabel) return;
      const n = Number(count);
      if (Number.isFinite(n) && n >= 0) {
        $dbusRoutesTitleLabel.dataset.routeCount = String(Math.round(n));
        $dbusRoutesTitleLabel.textContent = `${t("dbus_routes_title")} (${Math.round(n)})`;
        return;
      }
      delete $dbusRoutesTitleLabel.dataset.routeCount;
      $dbusRoutesTitleLabel.textContent = t("dbus_routes_title");
    }

    function resetDbusSelection(){
      document.getElementById("dbusList")?.querySelectorAll(".dbus-item.active")?.forEach(item => {
        item.classList.remove("active");
        item.style.outline = "none";
      });
      currentSelectedKey = "";
      currentSelectedLineUid = "";
      dbusRoutesClosedByPanel = false;
      hideAllRoutes();
      hideLinePreview();
      renderSelectedChip();
      if (window.__DBUS_GRID_OPEN && typeof window.__DBUS_GRID_OPEN.clear === "function") {
        try { window.__DBUS_GRID_OPEN.clear(); } catch {}
        window.__DBUS_GRID_OPEN = null;
      }
      showDbusRoutesPlaceholder();
      updateDbusModeUI();
    }
    var dbusSelectionScrollTimer = 0;
    function clearDbusSelectionScrollTimer(){
      if (!dbusSelectionScrollTimer) return;
      clearTimeout(dbusSelectionScrollTimer);
      dbusSelectionScrollTimer = 0;
    }
    function keepDbusSelectionVisible({ smooth = false } = {}){
      const container = $dbusLinesContent || $dbusList?.closest(".dbus-content");
      if (!container || container.offsetParent === null) return;
      const target =
        $dbusList?.querySelector(".dbus-item.active") ||
        $dbusList?.querySelector(".dbus-logo.sel");
      if (!target || target.offsetParent === null) return;

      const cRect = container.getBoundingClientRect();
      const tRect = target.getBoundingClientRect();
      const pad = 10;
      let nextTop = container.scrollTop;
      if (tRect.top < (cRect.top + pad)) {
        nextTop += (tRect.top - (cRect.top + pad));
      } else if (tRect.bottom > (cRect.bottom - pad)) {
        nextTop += (tRect.bottom - (cRect.bottom - pad));
      } else {
        return;
      }
      const maxTop = Math.max(0, container.scrollHeight - container.clientHeight);
      const clamped = Math.max(0, Math.min(maxTop, nextTop));
      container.scrollTo({ top: clamped, behavior: (smooth && UI_ANIMATIONS) ? "smooth" : "auto" });
    }
    function scheduleKeepDbusSelectionVisible(){
      clearDbusSelectionScrollTimer();
      requestAnimationFrame(() => keepDbusSelectionVisible({ smooth: false }));
      if (!UI_ANIMATIONS) return;
      dbusSelectionScrollTimer = setTimeout(() => {
        dbusSelectionScrollTimer = 0;
        keepDbusSelectionVisible({ smooth: true });
      }, 120);
    }

    function updateDbusModeUI(){
      $dbusModeButtons.forEach(btn => {
        const active = btn.dataset.mode === currentDbusMode;
        btn.classList.toggle("active", active);
        btn.setAttribute("aria-pressed", active ? "true" : "false");
        btn.disabled = false;
      });
      const isDepartMode = currentDbusMode === DBUS_MODES.DEPARTS;
      const isListMode = (currentDbusMode === DBUS_MODES.LINES || currentDbusMode === DBUS_MODES.LENGTH);
      const hasLineSelection = !!currentSelectedKey || !!currentSelectedLineUid;
      const showRoutesBox = currentDbusMode === DBUS_MODES.LINES && hasLineSelection && !dbusRoutesClosedByPanel;
      if ($dbusList) $dbusList.style.display = isListMode ? "" : "none";
      if ($dbusDepartActions) $dbusDepartActions.hidden = !isDepartMode;
      if ($dbusDepartList) $dbusDepartList.style.display = isDepartMode ? "" : "none";
      if ($dbusRoutesBox) {
        $dbusRoutesBox.hidden = !showRoutesBox;
        $dbusRoutesBox.style.display = showRoutesBox ? "flex" : "none";
      }
      if ($dbusLinesBox) {
        $dbusLinesBox.style.flex = showRoutesBox ? "0 0 43vh" : "1 1 auto";
        $dbusLinesBox.style.minHeight = "0";
        $dbusLinesBox.style.maxHeight = showRoutesBox ? "43vh" : "";
      }
      if ($dbusRoutesBox && showRoutesBox) {
        $dbusRoutesBox.style.flex = "1 1 0";
        $dbusRoutesBox.style.minHeight = "0";
      } else if ($dbusRoutesBox) {
        $dbusRoutesBox.style.flex = "";
        $dbusRoutesBox.style.minHeight = "";
      }
      if ($dbusLinesContent) $dbusLinesContent.style.maxHeight = "";
      if (!showRoutesBox) showDbusRoutesPlaceholder();
      if ($dbusRoutesClear) $dbusRoutesClear.hidden = !hasLineSelection;
      if (showRoutesBox && hasLineSelection) scheduleKeepDbusSelectionVisible();
      else clearDbusSelectionScrollTimer();
      if (typeof updateDbusPanelTitles === "function") updateDbusPanelTitles();
      updateUiOverlays();
    }

    function setDbusMode(mode){
      if (!mode || currentDbusMode === mode) return;
      currentDbusMode = mode;
      updateDbusModeUI();
      const forced = isDbusDisplayModeForced();
      if (mode === DBUS_MODES.DEPARTS) {
        resetDbusSelection();
        refreshDbusDepartures(dbusDepartPreviewActive || forced);
      } else {
        resetDbusSelection();
        if (typeof renderDbusLinesList === "function") renderDbusLinesList(mode);
        if (forced) {
          dbusDepartPreviewActive = true;
          refreshDbusDepartures(true);
        } else {
          dbusDepartPreviewActive = false;
          hideDbusDepartures();
          closeDbusStopPanel();
        }
      }
      updateDbusDepartIndicator();
    }

    function clearDbusSelection(scope = $dbusList){
      const activeItems = scope ? scope.querySelectorAll(".dbus-item.active") : [];
      activeItems.forEach(item => {
        item.classList.remove("active");
        item.style.outline = "none";
      });
      currentSelectedKey = "";
      currentSelectedLineUid = "";
      dbusRoutesClosedByPanel = false;
      hideAllRoutes();
      hideLinePreview();
      renderSelectedChip();
      if (window.__DBUS_GRID_OPEN && typeof window.__DBUS_GRID_OPEN.clear === "function") {
        try { window.__DBUS_GRID_OPEN.clear(); } catch {}
        window.__DBUS_GRID_OPEN = null;
      }
      showDbusRoutesPlaceholder();
      updateDbusModeUI();
    }
    function selectDbusLineRouteFromStopEntry(entry, opts = {}){
      const lineUid = String(entry?.line?.uid || "");
      if (!lineUid) return;
      const forcedGroupUid = String(opts?.groupUid || "").trim();
      const routeRaw = String(entry?.route?.name || "").trim();
      const lineRaw = String(entry?.line?.number || "").trim();
      const parsedLineRaw = String(parseRouteName(routeRaw || "").lineNumber || "").trim();
      const entryLooksExpress =
        /^express\b/i.test(routeRaw) ||
        /^express\b/i.test(parsedLineRaw) ||
        /^express\b/i.test(lineRaw);
      const entryLooksAutocar =
        /^autocar\b/i.test(routeRaw) ||
        /^fict/i.test(routeRaw) ||
        /^autocar\b/i.test(parsedLineRaw) ||
        /^fict/i.test(parsedLineRaw) ||
        /^autocar\b/i.test(lineRaw) ||
        /^fict/i.test(lineRaw);

      openDbusPanel();
      if (currentDbusMode !== DBUS_MODES.LINES) setDbusMode(DBUS_MODES.LINES);
      dbusRoutesClosedByPanel = false;
      if (typeof renderDbusLinesList === "function") renderDbusLinesList(DBUS_MODES.LINES);
      updateDbusModeUI();

      const findLineLogo = () => {
        const all = $dbusList ? [...$dbusList.querySelectorAll(".dbus-logo[data-line-uid]")] : [];
        return all.find(el => String(el.dataset.lineUid || "") === lineUid) || null;
      };
      const findGroupedLineLogo = () => {
        let groupUid = forcedGroupUid;
        if (!groupUid && entryLooksExpress) {
          try {
            groupUid = getExpressGroupMeta(entry?.line, entry?.route).uid || "";
          } catch {
            groupUid = "";
          }
        } else if (!groupUid && entryLooksAutocar) {
          groupUid = "group:autocar";
        }
        if (!groupUid) return null;
        const all = $dbusList ? [...$dbusList.querySelectorAll(".dbus-logo[data-line-uid]")] : [];
        return all.find(el => String(el.dataset.lineUid || "") === groupUid) || null;
      };

      const lineLogo = findLineLogo();
      const groupLogo = findGroupedLineLogo();
      const targetLogo = (entryLooksExpress || entryLooksAutocar)
        ? (groupLogo || lineLogo)
        : (lineLogo || groupLogo);
      if (targetLogo) {
        targetLogo.click();
        return;
      }

      const lineIdx = DBUS_LINES.findIndex(l => String(l.uid || "") === lineUid);
      const line = lineIdx >= 0 ? DBUS_LINES[lineIdx] : null;
      if (!line) return;
      currentSelectedKey = "";
      currentSelectedLineUid = line.uid;
      dbusRoutesClosedByPanel = false;
      hideAllRoutes();
      hideLinePreview();
      renderSelectedChip();
      updateDbusModeUI();
      requestAnimationFrame(() => {
        const retryLogo = findLineLogo() || findGroupedLineLogo();
        if (retryLogo) retryLogo.click();
      });
    }

    function isNumericOnly(s){ return /^\d+$/.test(String(s||"").trim()); }
    function isFlix(line){
      const num = String(line.number||"").toLowerCase();
      if (num.includes("flix")) return true;
      return (line.routes||[]).some(r => String(r.name||"").toLowerCase().includes("flix"));
    }
    function isNoctilien(line){
      const num = String(line.number||"").trim().toUpperCase();
      return /^N\d+$/.test(num);
    }
    function isAutocar(line){
      const num = String(line.number||"").toLowerCase();
      if (num.includes("autocar")) return true;
      return (line.routes||[]).some(r => String(r.name||"").toLowerCase().includes("autocar"));
    }
    function isFictive(line){
      const num = String(line.number||"").toLowerCase();
      if (num.includes("fictive")) return true;
      return (line.routes||[]).some(r => String(r.name||"").toLowerCase().includes("fictive"));
    }
    function isExpress(line){
      const num = String(line.number||"").trim().toLowerCase();
      if (/^express\b/.test(num)) return true;
      return (line.routes||[]).some(r => /^express\b/i.test(String(r.name||"").trim()));
    }
    function isExpressNumber(value){
      return /^express\b/i.test(String(value || "").trim());
    }
    function routeBadgeSizeFor(value){
      return isExpressNumber(value) ? "116x32" : "92x32";
    }
    function routeColorKey(line, route, parsedLineNumber){
      const routeName = String(route?.name || "").trim();
      const parsed = String(parsedLineNumber || "").trim();
      const routeIsExpressLike =
        /^express\b/i.test(routeName) ||
        /^express\b/i.test(parsed);
      if (routeIsExpressLike) {
        if (parsed) return parsed;
        const m = routeName.match(/\bexpress\b\s*([0-9a-z]+)/i);
        if (m && m[1]) return `Express ${m[1]}`;
        return "Express";
      }
      const routeIsAutocarLike =
        /^autocar\b/i.test(routeName) ||
        /^fict/i.test(routeName) ||
        /^autocar\b/i.test(parsed) ||
        /^fict/i.test(parsed);
      if (routeIsAutocarLike || (!routeIsExpressLike && (isAutocar(line) || isFictive(line)))) {
        return "Autocar";
      }
      if (parsed) return parsed;
      return getLineNumber(line, route);
    }
    function isTitusLine(line){
      const num = String(line.number||"").trim().toLowerCase();
      return /titus/i.test(num);
    }
    function getCategory(line){
      if (isNoctilien(line))          return "Noctilien";
      if (isFlix(line))               return "FlixBus";
      if (isAutocar(line))            return "Autres";
      if (isExpress(line))            return "Urbain";
      if (isNumericOnly(line.number)) return "Urbain";
      if (isTitusLine(line))          return "Urbain";
      if (/^scolaire/i.test(line.number)) return "Scolaire";
      return "Autres";
    }

    function compareDepartRoutes(a, b) {
      const numA = String(getLineNumber(a.line, a.route) || "").trim();
      const numB = String(getLineNumber(b.line, b.route) || "").trim();
      const aNum = isNumericOnly(numA);
      const bNum = isNumericOnly(numB);
      if (aNum !== bNum) return aNum ? -1 : 1;
      const cmp = numA.localeCompare(numB, 'fr', { numeric: true, sensitivity: "base" });
      if (cmp !== 0) return cmp;
      const uidCmp = String(a.line?.uid || "").localeCompare(String(b.line?.uid || ""), 'fr', { numeric: true, sensitivity: "base" });
      if (uidCmp !== 0) return uidCmp;
      const durDiff = (b.route?.totalMinutes || 0) - (a.route?.totalMinutes || 0);
      if (durDiff !== 0) return durDiff;
      return String(a.route?.name || "").localeCompare(String(b.route?.name || ""), 'fr', { numeric: true, sensitivity: "base" });
    }

    function countDepartEntries(entries) {
      let total = 0;
      const scolaireLines = new Set();
      entries.forEach(entry => {
        if (getCategory(entry.line) === "Scolaire") {
          scolaireLines.add(entry.line.uid);
        } else {
          total += 1;
        }
      });
      return total + scolaireLines.size;
    }

    const DEPART_CATEGORY_ORDER = ["Urbain", "Noctilien", "FlixBus", "Scolaire", "Autres"];
    function dbusSectionHeadHTML(key, count){
      const safeCount = Number.isFinite(Number(count)) ? Number(count) : 0;
      if (key === "Scolaire") {
        return `
          <span style="display:inline-flex;align-items:center;gap:8px;">
            <img class="dbus-sechead-logo" src="${overlayPath("bus_school.png")}" alt="${escapeHTML(t("dbus_school_toggle"))}"/>
            <span>(${safeCount})</span>
          </span>
          <span class="chev" style="margin-left:auto">▼</span>
        `;
      }
      const title = dbusCategoryTitle(key);
      return `<span>${title} (${safeCount})</span><span class="chev" style="margin-left:auto">▼</span>`;
    }

    function buildDepartBuckets(entries) {
      const buckets = {
        "Urbain": [],
        "Noctilien": [],
        "FlixBus": [],
        "Scolaire": [],
        "Autres": []
      };
      entries.forEach(entry => {
        const cat = getCategory(entry.line);
        if (buckets[cat]) buckets[cat].push(entry);
      });
      return buckets;
    }

    function renderDepartCategorySection(key, entries, container, isOpenByDefault = false) {
      if (!entries.length) return;
      const sec = document.createElement("div");
      sec.className = "dbus-sec";
      container.appendChild(sec);

      const head = document.createElement("div");
      head.className = "dbus-sechead";
      head.setAttribute("aria-expanded", isOpenByDefault ? "true" : "false");
      head.dataset.cat = key;
      head.dataset.count = String(entries.length);
      head.innerHTML = dbusSectionHeadHTML(key, entries.length);
      sec.appendChild(head);

      const body = document.createElement("div");
      body.className = "dbus-secbody";
      body.hidden = !isOpenByDefault;
      sec.appendChild(body);

      const sorted = [...entries].sort(compareDepartRoutes);
      sorted.forEach(({ line, route }) => renderDepartLineItem(line, route, body));

      head.addEventListener("click", () => {
        const expanded = head.getAttribute("aria-expanded") === "true";
        head.setAttribute("aria-expanded", expanded ? "false" : "true");
        body.hidden = expanded;
      });
    }

    function renderDepartCategories(entries, container) {
      if (!entries.length) {
        const empty = document.createElement("div");
        empty.className = "dbus-none";
        empty.textContent = t("none");
        container.appendChild(empty);
        return;
      }

      const buckets = buildDepartBuckets(entries);
      DEPART_CATEGORY_ORDER.forEach((key) => {
        const list = buckets[key] || [];
        if (!list.length) return;
        renderDepartCategorySection(key, list, container, true);
      });
    }

    function appendRouteLogo(item, line, lineNumber, showLogo) {
      if (!showLogo) return;
      const rawLineNumber = String(lineNumber || line.number || "").trim();
      const isNoct = isNoctilien2(rawLineNumber);
      const isTitusLogo = /^titus\s*(\d+)/i.test(rawLineNumber) || isTitusLine(line);
      const cat = getCategory(line);
      const logos = [];
      if (isTitusLogo) {
        logos.push({ src: overlayPath("reseau_titus.png"), alt: "Reseau Titus" });
      } else if (isNoct) {
        logos.push({ src: overlayPath("noctilien_logo_idfm.png"), alt: "Noctilien" });
      } else if (cat === "Scolaire") {
        logos.push({ src: overlayPath("bus_school.png"), alt: "Scolaire" });
      } else if (cat === "Urbain") {
        logos.push({ src: overlayPath("bus_logo_idfm.png"), alt: "IDFM" });
      }
      if (!logos.length) return;
      logos.forEach(({ src, alt }) => {
        const logo = document.createElement("img");
        logo.className = "dbus-route-logo";
        logo.src = src;
        logo.alt = alt;
        item.appendChild(logo);
      });
    }

    function renderDepartLineItem(line, route, container) {
      const item = document.createElement("div");
      item.className = "dbus-item";

      const { lineNumber, routeTitle, flag } = parseRouteName(route.name || "");
      const { titleEnd } = getRouteEndpoints(route);
      const mTitus = /^titus\s*(\d+)/i.exec(String(lineNumber||""));
      const displayNumber = mTitus ? mTitus[1] : lineNumber;
      const isScolaire = getCategory(line) === "Scolaire";
      const badge = isScolaire ? null : makeLineBadge(displayNumber, "#444", "#fff", routeBadgeSizeFor(lineNumber));
      appendRouteLogo(item, line, lineNumber, true);

      const titleEl = document.createElement("div");
      titleEl.className = "rname";
      titleEl.style.flex = "1 1 auto";
      const dirName = getRouteTerminusLabel(route, titleEnd) || String(titleEnd || routeTitle || "").trim();
      const dirLabel = t("destination");
      const dirText = dirName || routeTitle || "?";
      titleEl.dataset.routeKind = "depart";
      titleEl.dataset.routeTitle = routeTitle || "";
      titleEl.dataset.routeEnd = titleEnd || "";
      if (flag) titleEl.dataset.routeFlag = flag;
      let titleHtml = `${dirLabel} : ${withRERIcon(dirText)}`;
      if (flag) titleHtml = titleHtml + ` <span class="route-flag">${flag}</span>`;
      titleEl.innerHTML = titleHtml; 

      const duration = document.createElement("div");
      duration.className = "dbus-duration";

      const stopCount = route.stops.length;
      let durationText;
      if (route.totalMinutes >= 60) {
        const h = Math.floor(route.totalMinutes / 60);
        const m = route.totalMinutes % 60;
          if (m > 0) {
            durationText = `${h} h ${m} ${minuteShortLabel()}`;
          } else {
            durationText = `${h} h`;
          }
        } else {
          durationText = `${route.totalMinutes} ${minuteShortLabel()}`;
        }
      setStopDurationText(duration, stopCount, durationText, "paren");

      if (badge) item.appendChild(badge);
      item.appendChild(titleEl);
      item.appendChild(duration);

      const colorKey = routeColorKey(line, route, lineNumber);
      if (badge) {
        getLineColors(colorKey).then(([bg,text])=>{
          badge.style.background = bg;
          badge.style.color = text;
          if (isNoctilien2(colorKey)) {
            ensureStripe(badge, noctilienStripeColor(colorKey));
          }
        });
      }

      item.addEventListener("click", () => {
        const lineIdx = DBUS_LINES.indexOf(line);
        setDbusMode(DBUS_MODES.LINES);
        currentSelectedKey = `${line.uid}:${route.uid}`;
        currentSelectedLineUid = line.uid;
        dbusRoutesClosedByPanel = false;
        showOnlyRoute(lineIdx >= 0 ? lineIdx : 0, line, route);
        renderSelectedChip();
        closeDbusStopPanel();
        closeDbusPanel();
      });

      container.appendChild(item);
    }

    function updateDepartMarkerClasses(marker, { hover = false, selected = false } = {}) {
      const el = marker?.getElement?.();
      if (!el) return;
      const dot = el.querySelector(".dbus-depart-dot");
      if (!dot) return;
      dot.classList.toggle("is-hover", hover);
      dot.classList.toggle("is-selected", selected);
    }

    function setDepartMarkerHover(marker, isHover) {
      if (!marker) return;
      marker._departHover = !!isHover;
      updateDepartMarkerClasses(marker, {
        hover: marker._departHover,
        selected: marker === selectedDepartMarker
      });
    }

    function clearDepartMarkerSelection() {
      if (!selectedDepartMarker) return;
      updateDepartMarkerClasses(selectedDepartMarker, { hover: !!selectedDepartMarker._departHover, selected: false });
      selectedDepartMarker = null;
    }

    function setSelectedDepartMarker(marker) {
      if (!marker) return;
      if (selectedDepartMarker && selectedDepartMarker !== marker) {
        updateDepartMarkerClasses(selectedDepartMarker, { hover: !!selectedDepartMarker._departHover, selected: false });
      }
      selectedDepartMarker = marker;
      updateDepartMarkerClasses(marker, { hover: !!marker._departHover, selected: true });
    }

    function closeDbusStopPanel() {
      closePanel($dbusStopPanel, { durationMs: menuAnimDurationMs() });
      clearDepartMarkerSelection();
      updateUiOverlays();
    }

    function normalizeDepartName(name) {
      const txt = String(name || "").trim();
      return txt || t("stop");
    }

    function getDepartGroupNames(group) {
      const names = [...group.nameMap.keys()].map(n => String(n || "").trim()).filter(Boolean);
      const translated = names.map(n => translateStopName(n));
      translated.sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: "base" }));
      if (!translated.length) return [t("stop")];
      return translated;
    }

    function renderDepartStopSection(nameRec, container) {
      const sec = document.createElement("div");
      sec.className = "dbus-sec";
      const h = document.createElement("h4");
      const displayName = translateStopName(nameRec.name);
      h.dataset.stopName = nameRec.name;
      const stopCount = countDepartEntries(nameRec.routes);
      h.dataset.stopCount = String(stopCount);
      h.innerHTML = `${withRERIcon(displayName)} (${stopCount})`;
      sec.appendChild(h);

      const body = document.createElement("div");
      sec.appendChild(body);
      renderDepartCategories(nameRec.routes, body);

      container.appendChild(sec);
    }

    function openDbusStopPanelForGroup(group) {
      if (!$dbusStopPanel || !$dbusStopTitle || !$dbusStopList) return;
      const rawNames = [...group.nameMap.keys()].map(n => String(n || "").trim()).filter(Boolean);
      const nameList = rawNames.map(n => translateStopName(n));
      $dbusStopTitle.innerHTML = nameList.map(n => withRERIcon(n)).join(" / ");
      $dbusStopTitle.dataset.stopMode = "group";
      $dbusStopTitle.dataset.stopNames = JSON.stringify(rawNames);
      delete $dbusStopTitle.dataset.stopName;
      $dbusStopList.innerHTML = "";

      const sections = [...group.nameMap.values()].sort((a, b) => {
        const countA = countDepartEntries(a.routes);
        const countB = countDepartEntries(b.routes);
        if (countB !== countA) return countB - countA;
        return a.name.localeCompare(b.name, 'fr', { sensitivity: "base" });
      });
      if (sections.length <= 1) {
        const routes = sections[0]?.routes ? [...sections[0].routes] : [];
        renderDepartCategories(routes, $dbusStopList);
      } else {
        sections.forEach(section => renderDepartStopSection(section, $dbusStopList));
      }
      openPanel($dbusStopPanel, { display: "flex" });
      updateUiOverlays();
    }

    function openDbusStopPanelForName(nameRec) {
      if (!$dbusStopPanel || !$dbusStopTitle || !$dbusStopList) return;
      $dbusStopTitle.dataset.stopMode = "single";
      $dbusStopTitle.dataset.stopName = nameRec.name;
      $dbusStopTitle.innerHTML = `${t("stop")} : ${withRERIcon(translateStopName(nameRec.name))}`;
      $dbusStopList.innerHTML = "";

      renderDepartCategories(nameRec.routes, $dbusStopList);

      openPanel($dbusStopPanel, { display: "flex" });
      updateUiOverlays();
    }

    function renderDbusDepartList() {
      if (!$dbusDepartList) return;
      $dbusDepartList.innerHTML = "";
      const items = [...dbusDepartNameIndex.values()];
      items.sort((a, b) => {
        const countA = countDepartEntries(a.routes);
        const countB = countDepartEntries(b.routes);
        if (countB !== countA) return countB - countA;
        return a.name.localeCompare(b.name, 'fr', { sensitivity: "base" });
      });

      if (!items.length) {
        const empty = document.createElement("div");
        empty.className = "dbus-none";
        empty.textContent = t("none");
        $dbusDepartList.appendChild(empty);
        return;
      }

      items.forEach(rec => {
        const item = document.createElement("div");
        item.className = "dbus-item";

        const count = document.createElement("div");
        count.className = "dbus-stop-count";
        count.textContent = String(countDepartEntries(rec.routes));

        const titleEl = document.createElement("div");
        titleEl.className = "rname";
        titleEl.style.flex = "1 1 auto";
        titleEl.dataset.rawName = rec.name || "";
        titleEl.innerHTML = withRERIcon(translateStopName(rec.name));

        item.appendChild(count);
        item.appendChild(titleEl);

        item.addEventListener("click", () => {
          openDbusStopPanelForName(rec);
          if (rec.centerLatLng) centerWithPreview(rec.centerLatLng, { zoom: map.getZoom() });
          let bestGroupId = null;
          let bestCount = -1;
          rec.groupIds?.forEach(id => {
            const group = dbusDepartGroups.find(g => g.id === id);
            if (group && group.lineCount > bestCount) {
              bestCount = group.lineCount;
              bestGroupId = id;
            }
          });
          if (bestGroupId && dbusDepartMarkers.has(bestGroupId)) {
            setSelectedDepartMarker(dbusDepartMarkers.get(bestGroupId));
          }
        });

        $dbusDepartList.appendChild(item);
      });
    }

    function buildDbusDepartures() {
      dbusDepartGroups = [];
      dbusDepartMarkers = new Map();
      dbusDepartNameIndex = new Map();
      dbusDepartLayers.clearLayers();

      const entries = [];
      DBUS_LINES.forEach((line, lineIdx) => {
        const cat = getCategory(line);
        if (!showSchoolLines && cat === "Scolaire") return;
        if (!showFictiveLines && cat === "Autres") return;
        line.routes.forEach(route => {
          const firstStopId = route.stops[0]?.uid;
          if (typeof firstStopId === "undefined") return;
          const stop = DBUS_STOPS.get(firstStopId);
          if (!stop?.latlng) return;
          const pt = map.project(stop.latlng, maxNativeZoom);
          const { titleStart } = getRouteEndpoints(route);
          const rawStartName = titleStart || stop.name || "";
          const isProvisoireStart = hasProvisoire(stop.name) || hasProvisoire(titleStart);
          const cleanStartName = stripProvisoire(rawStartName);
          const startName = normalizeDepartName(isProvisoireStart ? `${cleanStartName} (Provisoire)` : cleanStartName);
          const entry = { line, lineIdx, route, stop, pt, startName };
          entries.push(entry);

          let nameRec = dbusDepartNameIndex.get(startName);
          if (!nameRec) {
            nameRec = { name: startName, routes: [], lineIds: new Set(), stopIds: new Set(), latlngs: [], groupIds: new Set() };
            dbusDepartNameIndex.set(startName, nameRec);
          }
          nameRec.routes.push(entry);
          nameRec.lineIds.add(line.uid);
          if (!nameRec.stopIds.has(stop.id)) {
            nameRec.stopIds.add(stop.id);
            if (stop.latlng) nameRec.latlngs.push(stop.latlng);
          }
        });
      });

      const groups = [];
      const distSq = DBUS_DEPART_MERGE_PX * DBUS_DEPART_MERGE_PX;

      entries.forEach(entry => {
        const { stop, pt } = entry;
        let target = null;
        for (const g of groups) {
          const dx = pt.x - g.centerPt.x;
          const dy = pt.y - g.centerPt.y;
          if ((dx * dx + dy * dy) <= distSq) { target = g; break; }
        }
        if (!target) {
          target = {
            id: groups.length + 1,
            centerPt: { x: pt.x, y: pt.y },
            stopIds: new Set(),
            stops: [],
            routes: [],
            lineIds: new Set(),
            nameMap: new Map()
          };
          groups.push(target);
        }
        target.routes.push(entry);
        target.lineIds.add(entry.line.uid);

        let nameRec = target.nameMap.get(entry.startName);
        if (!nameRec) {
          nameRec = { name: entry.startName, routes: [], lineIds: new Set(), stopIds: new Set() };
          target.nameMap.set(entry.startName, nameRec);
        }
        nameRec.routes.push(entry);
        nameRec.lineIds.add(entry.line.uid);
        nameRec.stopIds.add(stop.id);

        if (!target.stopIds.has(stop.id)) {
          target.stopIds.add(stop.id);
          target.stops.push(stop);
          const count = target.stops.length;
          target.centerPt.x = target.centerPt.x + (pt.x - target.centerPt.x) / count;
          target.centerPt.y = target.centerPt.y + (pt.y - target.centerPt.y) / count;
        }
      });

      groups.forEach(group => {
        const nameList = getDepartGroupNames(group);
        group.displayName = nameList.join(" / ");
        group.latlng = map.unproject(L.point(group.centerPt.x, group.centerPt.y), maxNativeZoom);
        group.lineCount = countDepartEntries(group.routes);
        group.nameMap.forEach((rec, nameKey) => {
          const nameRec = dbusDepartNameIndex.get(nameKey);
          if (nameRec) nameRec.groupIds.add(group.id);
        });
      });

      dbusDepartNameIndex.forEach(rec => {
        if (!rec.latlngs.length) return;
        let lat = 0, lng = 0;
        rec.latlngs.forEach(ll => { lat += ll.lat; lng += ll.lng; });
        rec.centerLatLng = L.latLng(lat / rec.latlngs.length, lng / rec.latlngs.length);
      });

      dbusDepartGroups = groups;

      groups.forEach(group => {
        const icon = L.divIcon({
          className: "dbus-depart-icon",
          html: `<div class="dbus-depart-dot">${group.lineCount}</div>`,
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        });
        const marker = L.marker(group.latlng, { icon, riseOnHover: true });
        marker._departGroupId = group.id;
        marker._departHover = false;
        marker.on("click", () => {
          openDbusStopPanelForGroup(group);
          setSelectedDepartMarker(marker);
        });
        marker.on("mouseover", () => setDepartMarkerHover(marker, true));
        marker.on("mouseout", () => setDepartMarkerHover(marker, false));

        const tooltipHtml = escapeHTML(group.displayName);
        const tooltipOpts = { direction: "top", className: "dbus-depart-tooltip", offset: [0, -10] };
        marker.bindTooltip(tooltipHtml, tooltipOpts);

        dbusDepartMarkers.set(group.id, marker);
        dbusDepartLayers.addLayer(marker);
      });

      dbusDepartFilterKey = `${showSchoolLines}-${showFictiveLines}`;
      renderDbusDepartList();
    }

    function showDbusDepartures() {
      if (!DBUS_LINES.length || !DBUS_STOPS.size) return;
      if (!dbusDepartGroups.length || dbusDepartFilterKey !== `${showSchoolLines}-${showFictiveLines}`) buildDbusDepartures();
      if (!map.hasLayer(dbusDepartLayers)) dbusDepartLayers.addTo(map);
    }

    function hideDbusDepartures() {
      if (map.hasLayer(dbusDepartLayers)) map.removeLayer(dbusDepartLayers);
      clearDepartMarkerSelection();
    }

    async function initDbusUI(){
      try{
        await loadStops();
        await loadLines();
        await loadDbusNavGraph();
        await loadDbusNavBridges();
        enableDevGraphOverlay();
        ensureDevGraphClickBinding();
        buildDbusStopLineEntries();
        renderDbusStopsLayer();
      }catch(err){
        console.error("DBus: chargement échoué", err);
        return;
      }

      $dbusList.innerHTML = "";

      function compareUrbainLines(a,b){

        const aNum = isNumericOnly(a.number);
        const bNum = isNumericOnly(b.number);
        if (aNum && !bNum) return -1;
        if (!aNum && bNum) return 1;
        if (aNum && bNum) return (parseInt(a.number,10)||0) - (parseInt(b.number,10)||0);

        return String(a.number).localeCompare(String(b.number), 'fr', {numeric:true});
      }

      function buildLineBuckets(){
        const buckets = { "Urbain": [], "FlixBus": [], "Noctilien": [], "Autres": [], "Scolaire": [] };
        DBUS_LINES.forEach(line => {
          const cat = getCategory(line);
          if (!showSchoolLines && cat === "Scolaire") return;
          if (!showFictiveLines && cat === "Autres") return;
          buckets[cat].push(line);
        });

        buckets["Urbain"].sort(compareUrbainLines);
        buckets["Noctilien"].sort((a,b)=> String(a.number).localeCompare(String(b.number), 'fr', {numeric:true}));
        buckets["FlixBus"].sort((a,b)=> String(a.number).localeCompare(String(b.number), 'fr', {numeric:true}));
        buckets["Autres"].sort((a,b)=> String(a.number).localeCompare(String(b.number), 'fr', {numeric:true}));
        buckets["Scolaire"].sort((a, b) => {
          return String(a.number).localeCompare(String(b.number), 'fr', {numeric:true});
        });
        return buckets;
      }

      function buildRouteBuckets(){
        const buckets = { "Urbain": [], "FlixBus": [], "Noctilien": [], "Autres": [], "Scolaire": [] };
        DBUS_LINES.forEach(line => {
          const cat = getCategory(line);
          if (!showSchoolLines && cat === "Scolaire") return;
          if (!showFictiveLines && cat === "Autres") return;
          line.routes.forEach(route => buckets[cat].push({ line, route }));
        });
        Object.values(buckets).forEach(list => {
          list.sort((a, b) => {
            const diff = lengthScoreForLengthMode(b.line, b.route) - lengthScoreForLengthMode(a.line, a.route);
            if (diff) return diff;
            return String(a.route.name || "").localeCompare(String(b.route.name || ""), 'fr', {numeric:true, sensitivity:"base"});
          });
        });
        return buckets;
      }

      function isExpressRoute(route){
        const raw = String(route?.name || "").trim();
        return /^express\b/i.test(raw);
      }
      function getExpressGroupMeta(line, route){
        const routeName = String(route?.name || "").trim();
        const parsedLineNumber = String(parseRouteName(routeName || "").lineNumber || "").trim();
        const lineNumber = String(line?.number || "").trim();
        let number = "";

        const fromParsed = /^express\b\s*(.*)$/i.exec(parsedLineNumber);
        if (fromParsed) number = String(fromParsed[1] || "").trim();
        if (!number) {
          const fromRoute = routeName.match(/\bexpress\b\s*([0-9a-z]+)/i);
          if (fromRoute && fromRoute[1]) number = String(fromRoute[1]).trim();
        }
        if (!number) {
          const fromLine = /^express\b\s*(.*)$/i.exec(lineNumber);
          if (fromLine) number = String(fromLine[1] || "").trim();
        }
        if (!number && /^\d+$/.test(parsedLineNumber)) number = parsedLineNumber;
        if (!number && /^\d+$/.test(lineNumber)) number = lineNumber;
        if (!number) number = "Express";

        const displayNumber = number.replace(/^express\b/i, "").trim() || "Express";
        const uidPart = normalizeBadgeToken(displayNumber || "express");
        const colorKey = /^express\b/i.test(displayNumber) ? displayNumber : `Express ${displayNumber}`;
        return {
          uid: `group:express:${uidPart}`,
          number: displayNumber,
          colorKey
        };
      }
      function lengthScoreForLengthMode(line, route){
        const base = Number(route?.totalMinutes || 0);
        const express = isExpress(line) || isExpressRoute(route);
        return express ? base * 0.75 : base;
      }

      function isAutocarRoute(route){
        const raw = String(route?.name || "").trim();
        return /^autocar\b/i.test(raw) || /^fict/i.test(raw);
      }

      function buildGroupedLineFromRoutes(uid, label, sourceLines, routeFilter){
        const routes = [];
        sourceLines.forEach(srcLine => {
          (srcLine.routes || []).forEach(route => {
            if (!routeFilter(route)) return;
            routes.push({ ...route, __sourceLine: srcLine });
          });
        });
        if (!routes.length) return null;
        return { uid: `group:${uid}`, number: label, routes, __isGroup: true };
      }
      function buildGroupedExpressLines(urbanLines, extraSourceLines){
        const groups = new Map();
        const seenRouteKeys = new Set();
        const addRoute = (srcLine, route) => {
          const routeUid = String(route?.uid || "");
          const lineUid = String(srcLine?.uid || "");
          if (!routeUid || !lineUid) return;
          const routeKey = `${lineUid}:${routeUid}`;
          if (seenRouteKeys.has(routeKey)) return;
          seenRouteKeys.add(routeKey);

          const meta = getExpressGroupMeta(srcLine, route);
          let group = groups.get(meta.uid);
          if (!group) {
            group = {
              uid: meta.uid,
              number: meta.number,
              routes: [],
              __isGroup: true,
              __isExpressGroup: true,
              __expressColorKey: meta.colorKey
            };
            groups.set(meta.uid, group);
          }
          group.routes.push({ ...route, __sourceLine: srcLine });
        };

        (urbanLines || []).forEach(line => {
          if (!isExpress(line)) return;
          (line.routes || []).forEach(route => addRoute(line, route));
        });
        (extraSourceLines || []).forEach(line => {
          (line.routes || []).forEach(route => {
            if (!isExpressRoute(route)) return;
            addRoute(line, route);
          });
        });

        const all = [...groups.values()];
        all.sort((a, b) => {
          const aNum = parseInt(String(a.number || "").replace(/\D+/g, ""), 10);
          const bNum = parseInt(String(b.number || "").replace(/\D+/g, ""), 10);
          const aHas = Number.isFinite(aNum);
          const bHas = Number.isFinite(bNum);
          if (aHas && bHas) return aNum - bNum;
          if (aHas !== bHas) return aHas ? -1 : 1;
          return String(a.number || "").localeCompare(String(b.number || ""), "fr", { numeric: true, sensitivity: "base" });
        });
        return all;
      }

      function renderSection(key, lines) {
        if (!lines.length) return;
        const title = dbusCategoryTitle(key);

        const sec = document.createElement("div");
        sec.className = "dbus-sec";
        $dbusList.appendChild(sec);

        let totalRoutes = 0;
        lines.forEach(line => {
          totalRoutes += (line.routes ? line.routes.length : 0);
        });

        const isOpenByDefault = (key === "Urbain" || key === "Noctilien" || key === "urban" || key === "noctilien");

        const head = document.createElement("div");
        head.className = "dbus-sechead";
        head.setAttribute("aria-expanded", isOpenByDefault ? "true" : "false");
        head.dataset.cat = key;
        head.dataset.count = String(totalRoutes);
        head.innerHTML = `
          <span>${title} (${totalRoutes})</span>
          <span class="chev" style="margin-left:auto">▼</span>
        `;
        sec.appendChild(head);

        const body = document.createElement("div");
        body.className = "dbus-secbody";
        body.hidden = !isOpenByDefault; 
        sec.appendChild(body);

        head.addEventListener("click", () => {
          const expanded = head.getAttribute("aria-expanded") === "true";
          head.setAttribute("aria-expanded", expanded ? "false" : "true");
          body.hidden = expanded;
          if (expanded) {
            clearDbusSelection(body);
            return;
          }
        });

        const showSchoolLogo = key === "Scolaire";
        if (key === "Scolaire") {
          const allRoutes = [];
          lines.forEach(line => {
            line.routes.forEach(route => allRoutes.push({ line, route }));
          });

          allRoutes.sort((a, b) => {
            const depA = String(a.route.name).split(">")[0].trim();
            const depB = String(b.route.name).split(">")[0].trim();
            return depA.localeCompare(depB, 'fr', { numeric: true, sensitivity: "base" });
          });

          allRoutes.forEach(({ line, route }) => renderLineItem(line, route, body, { showLogo: showSchoolLogo }));
        } else {
          lines.forEach(line => {
            line.routes.forEach(route => renderLineItem(line, route, body, { showLogo: showSchoolLogo }));
          });
        }
      }

      function renderSectionGrid(key, lines) {
        if (!lines.length) return;
        const title = dbusCategoryTitle(key);

        const sec = document.createElement("div");
        sec.className = "dbus-sec";
        $dbusList.appendChild(sec);

        const head = document.createElement("h4");
        head.textContent = title;
        sec.appendChild(head);

        const body = document.createElement("div");
        body.className = "dbus-secbody";
        body.hidden = false;
        sec.appendChild(body);

        let selectedLineUid = null;

        function clearLocal(){
          selectedLineUid = null;
          showDbusRoutesPlaceholder();
          ($dbusList || body).querySelectorAll(".dbus-logo").forEach(el=>{
            el.style.outline = "none";
            el.classList.remove("dim", "sel");
            el.style.removeProperty("--selColor");
          });
          try { currentSelectedKey = ""; } catch {}
          try { currentSelectedLineUid = ""; } catch {}
          try { dbusRoutesClosedByPanel = false; } catch {}
          try { if (typeof hideAllRoutes === "function") hideAllRoutes(); } catch {}
          try { if (typeof hideLinePreview === "function") hideLinePreview(); } catch {}
          try { if (typeof updateDbusModeUI === "function") updateDbusModeUI(); } catch {}
        }

        function selectionColorForLine(line) {
          const rawNum = String(line.number || "").trim();
          if (isTitusLine(line)) return "#ffffff";
          if (/^N\d+$/i.test(rawNum)) return noctilienStripeColor(rawNum);
          if (line && line.__isExpressGroup) {
            const [bg] = getLineColorsSync(line.__expressColorKey || `Express ${rawNum}`);
            return bg;
          }
          return null;
        }

        function createLogoForLine(line) {
          const raw = String(line.number || "").trim();
          const wrap = document.createElement("div");
          wrap.className = "dbus-logo";

          if (/^scolaire\b/i.test(raw) || getCategory(line) === "Scolaire") {
            wrap.style.background = "transparent";
            wrap.style.border = "none";
            wrap.style.boxShadow = "none";
            const img = document.createElement("img");
            img.alt = "Scolaire";
            img.src = overlayPath("bus_school.png");
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "contain";
            wrap.appendChild(img);
            return wrap;
          }

          if (isTitusLine(line)) {
            wrap.classList.add("dbus-logo--titus");
            wrap.style.background = "transparent";
            const img = document.createElement("img");
            img.alt = "Reseau Titus";
            img.src = overlayPath("reseau_titus.png");
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "contain";
            img.onerror = () => {
              wrap.textContent = "Reseau Titus";
              wrap.style.color = "#522a8a";
              wrap.style.background = "transparent";
            };
            wrap.appendChild(img);
            return wrap;
          }

          const isExpressGroup = !!line.__isGroup && /^express$/i.test(raw);
          const badgeSize = "88x36";
          const badge = makeLineBadge(raw, "#444", "#fff", badgeSize);
          badge.classList.add("dbus-logo");
          getLineColors(raw).then(([bg,text])=>{
            if (line && line.__isExpressGroup) {
              const expressKey = line.__expressColorKey || `Express ${raw}`;
              const [xbg, xtext] = getLineColorsSync(expressKey);
              badge.style.background = xbg || "#6fb2e1";
              badge.style.color = xtext || "#FFFFFF";
            } else {
              badge.style.background = bg;
              badge.style.color = text;
            }
            if (isNoctilien2(raw)) ensureStripe(badge, noctilienStripeColor(raw));
          });
          return badge;
        }

        function renderRoutesForLine(line){
          if (!$dbusRoutesList) return;
          $dbusRoutesList.innerHTML = "";
          $dbusRoutesList.appendChild(createDbusNoneAction(() => {
            $panelDbus?.querySelectorAll(".dbus-item.active").forEach(it => {
              it.classList.remove("active");
              it.style.outline = "none";
            });
            currentSelectedKey = "";
            currentSelectedLineUid = String(line?.uid || currentSelectedLineUid || "");
            dbusRoutesClosedByPanel = false;
            hideAllRoutes();
            hideLinePreview();
            renderSelectedChip();
            updateDbusModeUI();
          }));
        const routes = Array.isArray(line.routes) ? line.routes : [];
        setDbusRoutesTitleCount(routes.length);
        if (!routes.length) return;
        routes.forEach(route => {
          const sourceLine = route && route.__sourceLine ? route.__sourceLine : line;
          const showSchoolLogo = getCategory(sourceLine) === "Scolaire";
          renderLineItem(sourceLine, route, $dbusRoutesList, {
            showLogo: showSchoolLogo,
            compactBadges: true
          });
        });
      }

        function bindLogoClick(logo, line, sectionId){
          logo.addEventListener("click", () => {
            const isSame = selectedLineUid === line.uid;
            if (!isSame && window.__DBUS_GRID_OPEN && window.__DBUS_GRID_OPEN.section !== sectionId) {
              try { window.__DBUS_GRID_OPEN.clear && window.__DBUS_GRID_OPEN.clear(); } catch {}
              window.__DBUS_GRID_OPEN = null;
            }
            if (isSame) {
              clearLocal();
              if (window.__DBUS_GRID_OPEN && window.__DBUS_GRID_OPEN.section === sectionId) window.__DBUS_GRID_OPEN = null;
              return;
            }
            clearLocal();
            selectedLineUid = line.uid;
            currentSelectedLineUid = line.uid;
            dbusRoutesClosedByPanel = false;
            const raw = String(line.number || "");
            const selColor = selectionColorForLine(line);
            if (selColor) logo.style.setProperty("--selColor", selColor);
            else { getLineColors(raw).then(([bg])=>{ logo.style.setProperty("--selColor", bg); }); }
            renderRoutesForLine(line);
            ($dbusList || body).querySelectorAll(".dbus-logo").forEach(el=>{ if (el!==logo) el.classList.add("dim"); else el.classList.remove("dim"); });
            ($dbusList || body).querySelectorAll(".dbus-logo.sel").forEach(el=> el.classList.remove("sel"));
            logo.classList.add("sel");
            window.__DBUS_GRID_OPEN = { section: sectionId, clear: clearLocal };
            updateDbusModeUI();
          });
        }

        function renderLogoGrid(host, items, sectionId){
          if (!items.length) return;
          const grid = document.createElement("div");
          grid.className = "dbus-grid";
          host.appendChild(grid);
          items.forEach(line => {
            const block = document.createElement("div");
            block.className = "line-block";
            const logo = createLogoForLine(line);
            logo.dataset.lineUid = String(line.uid || "");
            block.appendChild(logo);
            bindLogoClick(logo, line, sectionId);
            grid.appendChild(block);
          });
        }

        renderLogoGrid(body, lines, key);
      }
      function getLineId(line, route) {
        if (line.number && line.number !== "?") {
          return line.number;
        }
        const { lineNumber } = parseRouteName(route.name || "");
        return lineNumber || "?";
      }

      function renderLineItem(line, route, container, { showLogo = false, lengthMode = false, compactBadges = false } = {}) {
        const item = document.createElement("div");
        item.className = "dbus-item";
        if (lengthMode) item.classList.add("dbus-item-length");
        item.dataset.lineUid = String(line?.uid || "");
        item.dataset.routeUid = String(route?.uid || "");

      const { lineNumber, routeTitle, flag } = parseRouteName(route.name || "");
      const parsedLineRaw = String(lineNumber || "").trim();
      let parsedNumber = String(lineNumber || "").trim();
      const prefixedMatch = /^(?:express|scolaire|autocar)\s+(.+)$/i.exec(parsedNumber);
      if (prefixedMatch && prefixedMatch[1]) {
        parsedNumber = prefixedMatch[1].trim();
      }
      const fallbackNumber = String(getLineNumber(line, route) || "").trim();
      const needsFallback =
        !parsedNumber ||
        /^express\b/i.test(parsedNumber) ||
        /^scolaire\b/i.test(parsedNumber) ||
        /^autocar\b/i.test(parsedNumber) ||
        /^[a-z]+$/i.test(parsedNumber);
      const badgeRawNumber = needsFallback ? fallbackNumber : parsedNumber;
      const mTitus = /^titus\s*(\d+)/i.exec(String(badgeRawNumber || ""));
      const category = getCategory(line);
      const routeRaw = String(route?.name || "").trim();
      const routeIsExpressLike =
        /^express\b/i.test(routeRaw) ||
        /^express\b/i.test(parsedLineRaw) ||
        /^express\b/i.test(String(line?.number || "").trim());
      const routeIsAutocarLike =
        /^autocar\b/i.test(routeRaw) ||
        /^fict/i.test(routeRaw) ||
        /^autocar\b/i.test(parsedLineRaw) ||
        /^fict/i.test(parsedLineRaw);
      const isExpressItem = routeIsExpressLike;
      const isAutresLike = routeIsAutocarLike || (!isExpressItem && category === "Autres");
      const expressMeta = isExpressItem ? getExpressGroupMeta(line, route) : null;
      let displayNumber = mTitus ? mTitus[1] : badgeRawNumber;
      if (isAutresLike) {
        displayNumber = "Autocar";
      }
      if (lengthMode && isExpressItem) {
        const expressNum = String(expressMeta?.number || "").trim();
        if (!expressNum) displayNumber = "Express";
        else displayNumber = /^express\b/i.test(expressNum) ? expressNum : `Express ${expressNum}`;
      }
      const isScolaire = getCategory(line) === "Scolaire";
      const effectiveShowLogo = (lengthMode && isExpressItem) ? false : showLogo;
      const forceExpressLengthSize = lengthMode && (isExpressItem || isAutresLike || category === "FlixBus");
      const compactLengthBadge = ((lengthMode && !isExpressItem && !isExpressNumber(badgeRawNumber) && !forceExpressLengthSize) || compactBadges);
      const badgeSize = forceExpressLengthSize ? routeBadgeSizeFor("Express") : (compactLengthBadge ? "72x28" : routeBadgeSizeFor(displayNumber));
      const badge = isScolaire ? null : makeLineBadge(displayNumber, "#444", "#fff", badgeSize);
      appendRouteLogo(item, line, badgeRawNumber, effectiveShowLogo);
      if (lengthMode && effectiveShowLogo && badge) item.classList.add("logo-badge-tight");
        
        const titleEl = document.createElement("div");
        titleEl.className = "rname";
        titleEl.style.flex = "1 1 auto";
        const displayTitle = translateRouteTitle(routeTitle);
        titleEl.dataset.routeKind = "line";
        titleEl.dataset.routeTitle = routeTitle || "";
        if (flag) titleEl.dataset.routeFlag = flag;
        let titleHtml = withRERIcon(displayTitle || routeTitle);
        if (flag) {
          titleHtml = titleHtml + ` <span class="route-flag">${flag}</span>`;
        }
        titleEl.innerHTML = titleHtml;

        const duration = document.createElement("div");
        duration.className = "dbus-duration";

        const stopCount = route.stops.length;

        let durationText;
        if (route.totalMinutes >= 60) {
          const h = Math.floor(route.totalMinutes / 60);
          const m = route.totalMinutes % 60;
          if (m > 0) {
            durationText = `${h} h ${m} ${minuteShortLabel()}`;
          } else {
            durationText = `${h} h`;
          }
        } else {
          durationText = `${route.totalMinutes} ${minuteShortLabel()}`;
        }

        setStopDurationText(duration, stopCount, durationText, "paren");

      if (badge) item.appendChild(badge);
      if (lengthMode) {
        const meta = document.createElement("div");
        meta.className = "dbus-item-meta";
        meta.appendChild(titleEl);
        meta.appendChild(duration);
        item.appendChild(meta);
      } else {
        item.appendChild(titleEl);
        item.appendChild(duration);
      }

        const colorKey = routeColorKey(line, route, badgeRawNumber);
        const expressStyleKey = /^\d+$/.test(String(displayNumber || "").trim())
          ? `Express ${displayNumber}`
          : "Express";
        const expressStyle = isExpressItem
          ? (getLineStyleEntry(expressMeta?.colorKey || expressStyleKey) || getLineStyleEntry("Express"))
          : null;
        const routeColorsPromise = expressStyle
          ? Promise.resolve([expressStyle[0], expressStyle[1]])
          : (isExpressItem ? Promise.resolve(["#6fb2e1", "#FFFFFF"]) : getLineColors(colorKey));
      if (badge) {
        routeColorsPromise.then(([bg,text])=>{
          badge.style.background = bg;
          badge.style.color = text;
          if (isNoctilien2(colorKey)) {
            ensureStripe(badge, noctilienStripeColor(colorKey));
          }
        });
      }
      const routeKey = `${line.uid}:${route.uid}`;
      if (currentSelectedKey === routeKey) {
        item.classList.add("active");
        routeColorsPromise.then(([bg]) => {
          if (item.classList.contains("active")) item.style.outline = `2px solid ${bg}`;
        });
      }


        item.addEventListener("click", ()=> {
          $panelDbus?.querySelectorAll(".dbus-item").forEach(it=>{
            it.classList.remove("active");
            it.style.outline = "none";
          });
          item.classList.add("active");
          routeColorsPromise.then(([bg])=>{
            if (item.classList.contains("active")) item.style.outline = `2px solid ${bg}`;
          });

          currentSelectedKey = routeKey;
          currentSelectedLineUid = line.uid;
          dbusRoutesClosedByPanel = false;
          showOnlyRoute(0, line, route);
          renderSelectedChip();
          updateDbusModeUI();
        });

        container.appendChild(item);
      }

      function renderSectionByDuration(title, entries) {
        if (!entries.length) return;

        const sec = document.createElement("div");
        sec.className = "dbus-sec";
        $dbusList.appendChild(sec);

        const isOpenByDefault = (
          title === "IDFM" ||
          title === "Noctiliens" ||
          normalizeBadgeToken(title) === normalizeBadgeToken(translatedNightBusLabel())
        );

        const head = document.createElement("div");
        head.className = "dbus-sechead";
        head.setAttribute("aria-expanded", isOpenByDefault ? "true" : "false");
        head.innerHTML = `
          <span>${title} (${entries.length})</span>
          <span class="chev" style="margin-left:auto">▼</span>
        `;
        sec.appendChild(head);

        const body = document.createElement("div");
        body.className = "dbus-secbody";
        body.hidden = !isOpenByDefault;
        sec.appendChild(body);

        head.addEventListener("click", () => {
          const expanded = head.getAttribute("aria-expanded") === "true";
          const willOpen = !expanded;
          head.setAttribute("aria-expanded", expanded ? "false" : "true");
          body.hidden = expanded;
          if (expanded) {
            clearDbusSelection(body);
            return;
          }
          if (willOpen) {
            try {
              $dbusList.querySelectorAll('.dbus-sechead').forEach(h => {
                if (h !== head) {
                  h.setAttribute('aria-expanded','false');
                  const b = h.nextElementSibling;
                  if (b && b.classList.contains('dbus-secbody')) {
                    b.hidden = true;
                    clearDbusSelection(b);
                  }
                }
              });
              if (window.__DBUS_GRID_OPEN && typeof window.__DBUS_GRID_OPEN.clear === 'function') {
                window.__DBUS_GRID_OPEN.clear();
                window.__DBUS_GRID_OPEN = null;
              }
            } catch {}
          }
        });

        entries.forEach(({ line, route }) => renderLineItem(line, route, body, { showLogo: true }));
      }
      function renderDbusLinesListInner(mode) {
        if (!$dbusList) return;
        $dbusList.innerHTML = "";
        if (mode === DBUS_MODES.LINES) showDbusRoutesPlaceholder();
        if (mode === DBUS_MODES.LENGTH) {
          const routeBuckets = buildRouteBuckets();
          const entries = [];
          Object.values(routeBuckets).forEach(list => entries.push(...list));
          entries.sort((a, b) => {
            const diff = lengthScoreForLengthMode(b.line, b.route) - lengthScoreForLengthMode(a.line, a.route);
            if (diff) return diff;
            return String(a.route.name || "").localeCompare(
              String(b.route.name || ""),
              "fr",
              { numeric: true, sensitivity: "base" }
            );
          });
          if (!entries.length) {
            const empty = document.createElement("div");
            empty.className = "dbus-none";
            empty.textContent = t("none");
            $dbusList.appendChild(empty);
            return;
          }
          entries.forEach(({ line, route }) => renderLineItem(line, route, $dbusList, { showLogo: true, lengthMode: true }));
          return;
        }
        const lineBuckets = buildLineBuckets();
        const extraSourceLines = lineBuckets["Autres"];
        const expressGroups = buildGroupedExpressLines(lineBuckets["Urbain"], extraSourceLines);
        const autocarGroupLine = buildGroupedLineFromRoutes("autocar", "Autocar", extraSourceLines, isAutocarRoute);

        const urbanLines = lineBuckets["Urbain"].filter(line => !isTitusLine(line) && !isExpress(line));
        const titusLines = lineBuckets["Urbain"].filter(line => isTitusLine(line));

        const others = [
          ...lineBuckets["FlixBus"],
          ...lineBuckets["Scolaire"],
          ...lineBuckets["Autres"].filter(line => {
            const n = String(line.number || "").trim().toLowerCase();
            return !/^fict/i.test(n) && !/^autocar\b/i.test(n);
          })
        ];
        if (autocarGroupLine) others.push(autocarGroupLine);
        others.sort((a,b)=> String(a.number).localeCompare(String(b.number), 'fr', {numeric:true}));

        renderSectionGrid("urban", urbanLines);
        renderSectionGrid("Express", expressGroups);
        renderSectionGrid("noctilien",  lineBuckets["Noctilien"]);
        renderSectionGrid("other_networks", titusLines);
        renderSectionGrid("others", others);
      }

      renderDbusLinesList = renderDbusLinesListInner;
      renderDbusLinesList(currentDbusMode);
      applyI18N();
      buildDbusDepartures();
      if (currentDbusMode === DBUS_MODES.DEPARTS && dbusDepartPreviewActive) showDbusDepartures();

    }
    initDbusUI().then(()=>renderSelectedChip()).catch(()=>{});

    let currentActiveStopId = null;
    function clearActiveStop(){
      PREVIEW_STOP_ELEMS.forEach(({el}) => el.classList.remove('active'));
      currentActiveStopId = null;
    }

    function norm(s){
      return String(s||"")
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g,'')
        .replace(/\s+/g,' ')
        .trim();
    }
    function includesNorm(hay, needle){ return norm(hay).includes(norm(needle)); }

    function detectTypeFilter(q){
      const n = norm(q);

      const MAP = [
        {types:["Atelier"],      keys:["atelier","atelier de reparation","reparation","atelier reparation"]},
        {types:["Agence"],       keys:["agence","agence de recrutement","recrutement"]},
        {types:["Garage"],       keys:["garage"]},
        {types:["Concessionnaire"], keys:["concessionnaire","dealer","concess"]},
        {types:["Entreprise"],   keys:["entreprise","societe","company"]},
        {types:["Ville"],        keys:["ville","commune","city"]},
        {types:["Monument"],     keys:["monument","monuments","monu","lieu","lieu emblématique","lieux emblématiques","lieux","emblématique","emblématiques"]},
      ];

      for(const row of MAP){
        for(const k of row.keys){
          if(n === k || n.startsWith(k+" ") || n.endsWith(" "+k) || n.includes(" "+k+" ")){
            return { types: row.types, hit: k };
          }
        }
      }
      return null;
    }
      
    let sectionState = {};
    function getExpanded(key){ return sectionState[key] !== false; }
    function setExpanded(key, val){ sectionState[key] = !!val; }
    
    const ORDER = [
      ["Ville","Villes"],
      ["Monument","Lieux Emblématiques"],
      ["Atelier","Ateliers de réparation"],
      ["Agence","Agences de recrutement"],
      ["Concessionnaire","Concessionnaires"],
      ["Entreprise","Entreprises"]
    ];
    const PLURIEL = Object.fromEntries(ORDER);

    const SEARCH_CATEGORIES = [SEARCH_CATEGORY_ALL, ...ALL_TYPES];
    function setActiveSearchCategory(next){
      if (!next || ACTIVE_SEARCH_CATEGORY === next) return;
      ACTIVE_SEARCH_CATEGORY = next;
    }
    function filterSearchList(list, raw, allowTypeFilter){
      const nQ = norm(raw);
      if (nQ === "") return list.slice();
      let filtered = list.slice();
      const typeInfo = allowTypeFilter ? detectTypeFilter(nQ) : null;

      if (typeInfo){
        filtered = filtered.filter(it => typeInfo.types.includes(it.type));
        let rest = norm(raw.replace(new RegExp(typeInfo.hit,'i'), '').trim())
                    .replace(/^[\s,;:>-]+|[\s,;:>-]+$/g,'');
        if (rest){
          filtered = filtered.filter(it => {
            const hay = [it.name, it.city, it.brand].filter(Boolean).join(" ");
            return includesNorm(hay, rest);
          });
        }
      } else {
        const words = norm(raw).split(/\s+/).filter(Boolean);
        filtered = filtered.filter(it => {
          const hay = [it.type, it.name, it.city, it.brand].filter(Boolean).join(" ");
          const normHay = norm(hay);
          return words.every(w => normHay.includes(w));
        });
      }
      return filtered;
    }
    function updateSearchCategoryCounts(list){
      const counts = Object.fromEntries(ALL_TYPES.map(t => [t, 0]));
      for (const it of list){
        if (counts[it.type] !== undefined) counts[it.type] += 1;
      }
      SEARCH_CATEGORY_COUNTS = counts;
      SEARCH_CATEGORY_TOTAL = Object.values(counts).reduce((sum, n) => sum + n, 0);
    }

    function buildResultsFilterBar(host = ($searchFilters || $results)){
      if (!host) return;
      host.querySelector(".results-filters")?.remove();

      const bar = document.createElement("div");
      bar.className = "search-categories results-filters";

      SEARCH_CATEGORIES.forEach(typeKey=>{
        const labelText = searchCategoryButtonLabel(typeKey);
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "dbus-mode-btn";
        btn.dataset.category = typeKey;
        const active = typeKey === ACTIVE_SEARCH_CATEGORY;
        btn.classList.toggle("active", active);
        btn.setAttribute("aria-pressed", active ? "true" : "false");
        btn.textContent = labelText;
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (ACTIVE_SEARCH_CATEGORY === typeKey) return;
          setActiveSearchCategory(typeKey);
          doSearch($search.value);
        });
        bar.appendChild(btn);
      });

      host.prepend(bar);
    }

    function renderResults(list){
      $results.innerHTML = "";
      buildResultsFilterBar();
      if (!list.length){
        const empty = document.createElement("div");
        empty.className = "result-empty";
        empty.textContent = resultsEmptyText();
        $results.appendChild(empty);
        $results.hidden = false;
        return;
      }

      const buckets = {
        "Ville": [],
        "Atelier": [],
        "Agence": [],
        "Garage": [],
        "Concessionnaire": [],
        "Entreprise": [],
        "Monument": []
      };
      for (const it of list){ if (buckets[it.type]) buckets[it.type].push(it); }

      function addSectionBlockLocal(typeKey, label, count){
        const head = document.createElement("div");
        head.className = "result-sechead";
        const mapLbl = {
          "Ville": t("villes"),
          "Monument": t("emblematic"),
          "Atelier": t("repair_shops"),
          "Agence": t("agencies"),
          "Concessionnaire": t("dealers"),
          "Entreprise": t("companies")
        };
        const base = mapLbl[typeKey] || label;
        head.dataset.type = typeKey;
        head.dataset.count = String(count);
        head.textContent = `${base} (${count})`;
        $results.appendChild(head);

        const body = document.createElement("div");
        body.className = "result-secbody";
        $results.appendChild(body);

        return body;
      }

      function addItem(container, item){
        const div = document.createElement("div");
        div.className = "result-item";

          if (item.type === "Lignes DBus") {
          const img = document.createElement("img");
          img.className = "ico ico-service";
          img.src = overlayPath("bus_ico.png");
          img.alt = "Bus";
          div.appendChild(img);

          let lineNumber = "";
          let routeName  = "";
          if (item.name.includes(":")) {
            const [left, right] = item.name.split(":");
            lineNumber = left.replace("Ligne","").trim();
            routeName  = right.trim();
          } else {
            lineNumber = item.name.trim();
            routeName  = "";
          }

          const category = getCategory({ number: lineNumber });

          if (category !== "Autres") {
            const tnum = item.titusNum || (/^titus\s*(\d+)/i.exec(String(lineNumber||""))?.[1] ?? null);
            if (tnum) {
              const wrap = document.createElement('div');
              wrap.style.display = 'inline-flex';
              wrap.style.alignItems = 'center';
              wrap.style.gap = '6px';
              const img = document.createElement('img');
              img.src = overlayPath("reseau_titus.png");
              img.alt = 'Réseau Titus';
              img.style.height = '22px';
              img.style.width = 'auto';
              const [bg, text] = getLineColorsSync('Titus ' + tnum);
              const chip = makeLineBadge(tnum, bg, text, '48x24');
              wrap.appendChild(img);
              wrap.appendChild(chip);
              div.appendChild(wrap);
            } else {
              const [bg, text] = getLineColorsSync(lineNumber);
              const badge = makeLineBadge(
                lineNumber,
                bg,
                text,
                routeBadgeSizeFor(lineNumber),
                isNoctilien2(lineNumber) ? noctilienStripeColor(lineNumber) : null,
                false
              );
              div.appendChild(badge);
            }
          }

          const span = document.createElement("div");
          span.className = "result-text";
          const cleanTitle = routeName.replace(/^\s*Titus\s*\d+\s*[:-]?\s*/i, '');
          span.dataset.routeTitle = cleanTitle;
          span.textContent = translateRouteTitle(cleanTitle);
          div.appendChild(span);
        } else {
          if (item.logo) {
            const img = document.createElement("img");
            img.className = "ico";
            if (["Atelier","Agence","Garage","Ville","Monument","Centre commercial"].includes(item.type)) {
              img.classList.add("ico-service");
            }
            img.src = item.logo;
            img.alt = "";
            img.onerror = () => {
              if (item.fallbackLogo && img.src !== item.fallbackLogo) img.src = item.fallbackLogo;
            };
            div.appendChild(img);
          }

          let label;
          if (item.type === "Concessionnaire"){
            const brand = (item.brand || String(item.name||"").replace(/^Concessionnaire\s+/i,"")).trim();
            label = item.city ? `${brand} - ${item.city}` : brand;
          } else if (["Atelier","Agence","Garage"].includes(item.type)){
            label = item.city || typeFallbackLabel(item.type);
          } else if (item.type === "Monument"){
            label = item.city ? `${item.name} - ${item.city}` : item.name; 
          } else {
            label = item.city ? `${item.name} - ${item.city}` : item.name;
          }

          const span = document.createElement("div");
          span.className = "result-text";
          span.textContent = label;
          div.appendChild(span);
        }

        div.addEventListener("click", () => {
          closeSearchUI({ reset: true });
          map.setView(item.center, Math.max(map.getZoom(), minNativeZoom + 4));
          if (item.open) setTimeout(()=> item.open(), 150);
        });

        container.appendChild(div);
      }



      let shown = 0;
      for (const [typeKey,label] of ORDER){
        const arr = buckets[typeKey];
        if (!arr.length) continue;
        const body = addSectionBlockLocal(typeKey,label, arr.length);
        for (const it of arr){
          if (shown >= 250) break;
          addItem(body,it);
          shown++;
        }
        if (shown >= 250) break;
      }

      $results.hidden = false;
      applyI18N();
    }

    function doSearch(q){
      const raw = String(q||"");
      const allowTypeFilter = ACTIVE_SEARCH_CATEGORY === SEARCH_CATEGORY_ALL;
      const baseFiltered = filterSearchList(searchIndex, raw, allowTypeFilter);
      updateSearchCategoryCounts(baseFiltered);

      const activeTypes = (ACTIVE_SEARCH_CATEGORY === SEARCH_CATEGORY_ALL)
        ? ALL_TYPES
        : [ACTIVE_SEARCH_CATEGORY];
      const ALLOWED = new Set(activeTypes);
      let filtered = baseFiltered.filter(it => ALLOWED.has(it.type));

      if (!raw.trim()){
        renderResults(filtered);
        $results.hidden = false;
        return;
      }

      filtered.sort((a,b)=>{
        const pa = (a.type==="Ville")?0:1, pb=(b.type==="Ville")?0:1;
        if(pa!==pb) return pa-pb;
        return String(a.name).localeCompare(String(b.name), LANG==='en'?'en':'fr', {numeric:true});
      });

      filtered.sort((a,b)=>{
        if (a.type === "Lignes DBus" && b.type === "Lignes DBus") {
          return (a.num ?? Infinity) - (b.num ?? Infinity);
        }
        return 0;
      });



      renderResults(filtered);
      $results.hidden = false;
    }

    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); } }
    const doSearchDebounced = debounce(q => {
      doSearch(String(q||''));
      openSearchUI();
      _resIdx = -1;
    }, 120);

    $search.addEventListener('focus', () => { closeDbusPanel(); openSearchUI({ refresh: true }); doSearch($search.value); });
    $search.addEventListener('input', e => doSearchDebounced(e.target.value));
    $search.addEventListener('keydown', e => { if (e.key === 'Enter') { const first = $results.querySelector('.result-item'); if (first) first.click(); } });

    document.addEventListener('click', (e) => {
      const target = e.target;
      if (!(target instanceof Element)) return;
      const path = (typeof e.composedPath === "function") ? e.composedPath() : [];
      const clickInSearch = path.includes($searchPanel)
        || path.includes($search)
        || ((!!$searchPanel && $searchPanel.contains(target)) || target === $search);
      const clickInLang = path.some(node => node instanceof Element && node.classList?.contains("lang-switch"))
        || !!target.closest(".lang-switch");

      if (!clickInSearch) closeSearchUI({ reset: true });
      if (!clickInLang) closeLangMenu();
    });

    window.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        document.getElementById('lpClose')?.click();
        closeSearchUI({ reset: true });
        closeDbusPanel();
        closeSettingsPanel();
        closeLangMenu();
        try { map.closePopup(); } catch {}
        updateUiOverlays();
      }
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openSearchUI({ focus: true, refresh: true });
      }
    });
  </script>
  <script>
    window.__setAppReady?.();
  </script>

  <script>
    const CLOSED = false 
      || (new URLSearchParams(location.search).get('closed') === '1');

    if (CLOSED) {
      const html = `
        <div style="
          position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
          background:#121212;color:#ececec;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
          text-align:center;padding:24px
        ">
          <div>
            <div style="font-size:28px;font-weight:800;margin-bottom:10px">${t("maintenance_title")}</div>
          </div>
        </div>
      `;
      document.body.innerHTML = html;
      throw new Error('Maintenance');
    }

    LINE_PREVIEW_AUDIO_EXTENSION.nonce = "";
    LINE_PREVIEW_AUDIO_EXTENSION.checked = false;
    LINE_PREVIEW_AUDIO_EXTENSION.detected = false;
    LINE_PREVIEW_AUDIO_EXTENSION.version = "";
    LINE_PREVIEW_AUDIO_EXTENSION.lastSeenAt = 0;
    LINE_PREVIEW_AUDIO_EXTENSION.pendingNonce = "";
    updateLinePreviewAudioExtensionState();

    let myExtHandshakeTimeoutId = 0;
    const MYEXT_PING_TIMEOUT_MS = 900;

    function generateMyExtNonce() {
      if (globalThis.crypto && typeof globalThis.crypto.randomUUID === "function") {
        return globalThis.crypto.randomUUID();
      }
      return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    }

    function markMyExtDetected(versionValue = "") {
      LINE_PREVIEW_AUDIO_EXTENSION.checked = true;
      LINE_PREVIEW_AUDIO_EXTENSION.detected = true;
      LINE_PREVIEW_AUDIO_EXTENSION.version = String(versionValue || LINE_PREVIEW_AUDIO_EXTENSION.version || "");
      LINE_PREVIEW_AUDIO_EXTENSION.lastSeenAt = Date.now();
      updateLinePreviewAudioExtensionState();
    }

    function markMyExtMissing() {
      LINE_PREVIEW_AUDIO_EXTENSION.checked = true;
      LINE_PREVIEW_AUDIO_EXTENSION.detected = false;
      updateLinePreviewAudioExtensionState();
    }

    function requestMyExtPing() {
      const nonce = generateMyExtNonce();
      LINE_PREVIEW_AUDIO_EXTENSION.nonce = nonce;
      LINE_PREVIEW_AUDIO_EXTENSION.pendingNonce = nonce;
      if (myExtHandshakeTimeoutId) {
        clearTimeout(myExtHandshakeTimeoutId);
        myExtHandshakeTimeoutId = 0;
      }
      window.postMessage({ type: "MYEXT_PING", nonce }, location.origin);
      myExtHandshakeTimeoutId = setTimeout(() => {
        if (LINE_PREVIEW_AUDIO_EXTENSION.pendingNonce !== nonce) return;
        LINE_PREVIEW_AUDIO_EXTENSION.pendingNonce = "";
        markMyExtMissing();
      }, MYEXT_PING_TIMEOUT_MS);
    }

    const onMyExtHandshakeMessage = (event) => {
      if (event.source !== window) return;
      if (event.origin !== location.origin) return;
      const data = event.data;
      if (!data) return;
      const isPong = data.type === "MYEXT_PONG";
      const nonceOk = !data.nonce || data.nonce === LINE_PREVIEW_AUDIO_EXTENSION.nonce;
      if (isPong && nonceOk) {
        const wasDetected = !!LINE_PREVIEW_AUDIO_EXTENSION.detected;
        LINE_PREVIEW_AUDIO_EXTENSION.pendingNonce = "";
        if (myExtHandshakeTimeoutId) {
          clearTimeout(myExtHandshakeTimeoutId);
          myExtHandshakeTimeoutId = 0;
        }
        markMyExtDetected(data.version || "");
        if (!wasDetected) console.log("Extension détectée", data.version);
      }
    };
    window.addEventListener("message", onMyExtHandshakeMessage);
    requestMyExtPing();

    function isFisAudioPanelReady(action = "") {
      const panel = document.getElementById("lpAudioPanel");
      if (!panel) return false;
      const panelOpen = panel.classList.contains("is-open")
        && panel.style.display !== "none"
        && panel.getAttribute("aria-hidden") !== "true";
      if (!panelOpen) return false;
      const normalizedAction = String(action || "").trim().toLowerCase();
      const stops = Array.isArray(LINE_PREVIEW_AUDIO_STATE.stopNames) ? LINE_PREVIEW_AUDIO_STATE.stopNames : [];
      const hasRouteAudio = !!LINE_PREVIEW_AUDIO_STATE.enabled && stops.length > 0;
      const hasGlobalAudio = document.querySelector("#lpAudioGlobalButtons .line-preview-audio-btn") !== null;
      if (/^key([1-4])$/.test(normalizedAction)) return hasRouteAudio;
      if (/^key([5-9]|10)$/.test(normalizedAction)) return hasGlobalAudio;
      return hasRouteAudio || hasGlobalAudio;
    }

    function triggerFisAudioButton(buttonId) {
      const btn = document.getElementById(buttonId);
      if (!btn || btn.disabled) return false;
      btn.click();
      return true;
    }

    function triggerFisGlobalAudioByIndex(index) {
      const idx = Number(index);
      if (!Number.isInteger(idx) || idx < 0) return false;
      const buttons = Array.from(document.querySelectorAll("#lpAudioGlobalButtons .line-preview-audio-btn"));
      if (!buttons.length || idx >= buttons.length) return false;
      const btn = buttons[idx];
      if (!btn || btn.disabled) return false;
      btn.click();
      return true;
    }

    async function triggerSaeivGlobalAudioByIndex(index) {
      const idx = Number(index);
      if (!Number.isInteger(idx) || idx < 0) return false;
      const hasRouteSelected = !!String(currentSelectedKey || "").trim();
      try { await ensureLinePreviewAudioGlobalFoldersLoaded(); } catch {}
      if (hasRouteSelected && triggerFisGlobalAudioByIndex(idx)) return true;
      const allFolders = Array.isArray(LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders) ? LINE_PREVIEW_AUDIO_GLOBAL_STATE.folders : [];
      const folders = getLinePreviewAudioGlobalAvailableFolders(allFolders);
      if (!folders.length && !allFolders.length) return false;
      let selectedPath = String(LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath || "");
      let selectedFolder = folders.find((folder) => String(folder?.path || "") === selectedPath) || null;
      if (!hasRouteSelected) {
        selectedFolder = findSaeivRatpGlobalFolder(folders, { requirePlayable: true })
          || findSaeivRatpGlobalFolder(folders)
          || findSaeivRatpGlobalFolder(allFolders, { requirePlayable: true })
          || findSaeivRatpGlobalFolder(allFolders)
          || selectedFolder;
        selectedPath = String(selectedFolder?.path || selectedPath || "");
        if (selectedPath) LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = selectedPath;
      }
      if (!selectedFolder) {
        selectedFolder = folders[0] || allFolders[0] || null;
        selectedPath = String(selectedFolder?.path || "");
        if (selectedPath) LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = selectedPath;
      }
      if (!selectedPath || !selectedFolder) return false;
      let clips = getSaeivGlobalFolderPlayableClips(selectedFolder);
      if (!clips.length) {
        const ratpFallback = findSaeivRatpGlobalFolder(folders, { requirePlayable: true })
          || findSaeivRatpGlobalFolder(allFolders, { requirePlayable: true });
        if (ratpFallback) {
          selectedFolder = ratpFallback;
          selectedPath = String(ratpFallback?.path || "");
          if (selectedPath) LINE_PREVIEW_AUDIO_GLOBAL_STATE.selectedFolderPath = selectedPath;
          clips = getSaeivGlobalFolderPlayableClips(ratpFallback);
        }
      }
      if (!clips.length || idx >= clips.length) return false;
      const clipName = String(clips[idx] || "").trim();
      if (!clipName) return false;
      const folderMeta = parseLinePreviewAudioGlobalFolderMeta(selectedFolder?.name || "");
      const folderVolumeMultiplier = Number.isFinite(Number(folderMeta?.volumeMultiplier))
        ? Number(folderMeta.volumeMultiplier)
        : 1;
      playLinePreviewAudioSequenceFromFolder(selectedPath, [clipName], {
        advanceOnFinish: false,
        lockNavigation: false,
        volumeMultiplier: folderVolumeMultiplier
      });
      updateLinePreviewAudioButtonsState();
      return true;
    }

    window.addEventListener("message", (ev) => {
      const data = ev.data;
      if (!data || !data.__FIS_BRIDGE__) return;
      if (!LINE_PREVIEW_AUDIO_EXTENSION.detected) {
        markMyExtDetected(data.version || "bridge");
        if (myExtHandshakeTimeoutId) {
          clearTimeout(myExtHandshakeTimeoutId);
          myExtHandshakeTimeoutId = 0;
        }
      }
      const action = String(data.action || "").trim().toLowerCase();
      if (!action) return;
      if (!isFisAudioPanelReady(action)) return;
      if (action === "key1") triggerFisAudioButton("lpAudioTerminusBtn");
      if (action === "key2") triggerFisAudioButton("lpAudioPrevBtn");
      if (action === "key3") {
        const currentBtn = document.getElementById("lpAudioCurrentBtn");
        if (!currentBtn || currentBtn.disabled) return;
        playLinePreviewCurrentStop(LINE_PREVIEW_AUDIO_STATE.currentIndex || 0, { advanceOnFinish: true });
        return;
      }
      if (action === "key4") triggerFisAudioButton("lpAudioNextBtn");
      const keyMatch = /^key(\d+)$/.exec(action);
      if (!keyMatch) return;
      const keyNum = Number(keyMatch[1]);
      if (!Number.isInteger(keyNum)) return;
      if (keyNum >= 5 && keyNum <= 10) {
        triggerFisGlobalAudioByIndex(keyNum - 5);
      }
    });
    </script>
</body>
</html>



























